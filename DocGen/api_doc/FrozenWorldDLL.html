<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typedefs, structs, and constants used throughout this documentation | World Locking Tools for Unity Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Typedefs, structs, and constants used throughout this documentation | World Locking Tools for Unity Documentation ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../DocGen/Images/Logos/favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../DocGen/Images/Logos/WorldLock64.png" alt="">
              </a>
            </div>
          
          <div class="version-dropdown" id="versionDropdown">
           </div>
         
          <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="typedefs-structs-and-constants-used-throughout-this-documentation">Typedefs, structs, and constants used throughout this documentation</h1>

<h2 id="typedefs">Typedefs</h2>
<pre><code class="lang-cpp">typedef uint64_t FrozenWorld_AnchorId;
typedef uint64_t FrozenWorld_FragmentId;
</code></pre>
<h2 id="structs">Structs</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Vector
{
    float x;
    float y;
    float z;
};

struct FrozenWorld_Quaternion
{
    float x;
    float y;
    float z;
    float w;
};

struct FrozenWorld_Transform
{
    FrozenWorld_Vector position;
    FrozenWorld_Quaternion rotation;
};

struct FrozenWorld_AttachmentPoint
{
    FrozenWorld_AnchorId anchorId;
    FrozenWorld_Vector locationFromAnchor;
};
</code></pre>
<h2 id="constants">Constants</h2>
<pre><code class="lang-cpp">// Special values for FrozenWorld_AnchorId
static const FrozenWorld_AnchorId FrozenWorld_AnchorId_INVALID = 0;
static const FrozenWorld_AnchorId FrozenWorld_AnchorId_UNKNOWN = 0xFFFFFFFFFFFFFFFF;

// Special values for FrozenWorld_FragmentId
static const FrozenWorld_FragmentId FrozenWorld_FragmentId_INVALID = 0;
static const FrozenWorld_FragmentId FrozenWorld_FragmentId_UNKNOWN = 0xFFFFFFFFFFFFFFFF;
</code></pre>
<p>The most significant practical distinction between the INVALID and UNKNOWN anchor or fragment identifiers is that INVALID identifiers can never be stored in a snapshot (and attempting to do so anyway will lead to an error being reported) but UNKNOWN identifiers can. Semantically, use INVALID to express 'the anchor or fragment does not exist' and UNKNOWN to express 'the anchor or fragment exists, but it is ambiguous, not known, or not relevant at this point'.</p>
<p>You can use <code>FrozenWorld_FragmentId_UNKNOWN</code> as the fragment association of all anchors you add to a SPONGY snapshot, for example, as Frozen World ignores them anyway and automatically assigns unique fragment identifiers to all anchors when they are added to the FROZEN snapshot during alignment.</p>
<h1 id="general-considerations-and-conventions">General considerations and conventions</h1>
<h2 id="parameter-naming-conventions">Parameter naming conventions</h2>
<p>Parameters may have an implied contract based on their name if it matches any of the following patterns (with foo in the following description being a generic placeholder that's substituted by any valid symbol name):</p>
<table>
<thead>
<tr>
<th>Naming pattern</th>
<th>Implied contract</th>
</tr>
</thead>
<tbody>
<tr>
<td>fooBufferSize, fooOut</td>
<td><ul><li>The fooOut pointer points to a writable memory buffer that has room for (at least) fooBufferSize elements of fooOut's pointed-to data type.</li><li>fooBufferSize must be zero or positive.</li><li>fooBufferSize is counted in elements of fooOut's pointed-to data type (not e.g. bytes).</li><li>fooOut must not be null. It must always point to a valid address, even if fooBufferSize is zero.</li><li>The called function will write no more than fooBufferSize elements to the memory pointed to by fooOut even if more data would be available.</li></ul></td>
</tr>
<tr>
<td>fooOut</td>
<td><ul><li>The memory pointed to by fooOut must be safe to be written to.</li><li>Existing data in the pointed-to memory location is ignored.</li><li>The function will not change the pointed-to memory except by writing a valid update to it; if fooOut points to a buffer intended to receive multiple elements of the same type, only some of the elements may have been written if an error occurs, but each of the written elements will have been written completely.</li></ul></td>
</tr>
<tr>
<td>fooInOut</td>
<td><ul><li>The memory pointed to by fooInOut may be read and must be safe to be written to.</li><li>The information at the memory location pointed to by fooInOut must be valid (per the function's description).</li><li>The function will not change the pointed-to memory except by writing a valid update to it; if fooInOut points to a buffer containing multiple elements of the same type, only some of the elements may have been updated if an error occurs, but each of the actually updated elements will have been updated completely.</li></ul></td>
</tr>
</tbody>
</table>
<h2 id="thread-safety">Thread safety</h2>
<p>This library is thread-aware, but functions in this library that change its state are not generally re-entrant or safe for being called concurrently unless explicitly noted otherwise. Read or query operations can be called safely from different threads in parallel as long as there are no concurrent calls to any functions that change the internal state of the library.</p>
<ul>
<li><strong>Version information</strong> can be queried at any time in any thread.</li>
<li><strong>Error information</strong> can be queried at any time in any thread and always return error information for the last function called in the same thread.</li>
<li><strong>Startup and teardown</strong> are internally synchronized. It is acceptable to call <code>FrozenWorld_Destroy()</code> from a different thread than the one <code>FrozenWorld_Init()</code> was called on.</li>
<li><strong>Snapshot access</strong> of different snapshots is thread-safe – but reads and modifications of the same snapshot are not. However, it is safe to query the same snapshot's data from multiple threads in parallel as long as there are no concurrent modifications to it.</li>
<li><strong>Refit operations</strong> can be safely prepared in a background thread – though <code>Init()</code> and <code>Apply()</code> must be externally synchronized with all other accesses to the snapshots they read and modify.</li>
<li><strong>Persistence</strong> allows reading or writing to streams in a background thread – though <code>Gather()</code> and <code>Apply()</code> must be externally synchronized with all other accesses to the snapshots they read and modify.</li>
</ul>
<h1 id="diagnostics-and-errors">Diagnostics and errors</h1>
<h2 id="version-information">Version information</h2>
<pre><code class="lang-cpp">// -&gt; number of chars (excluding trailing null) copied to the buffer
int FrozenWorld_GetVersion(  
    bool detail,
    int versionBufferSize,
    char* versionOut);
</code></pre>
<p>Returns a representation of the DLL's version. This is useful to know when investigating suspected bugs and weird phenomena because it allows us to relate what you're seeing with a specific version of the Frozen World source code.</p>
<p>If the detail flag is false, the returned version information is a short, single-line string contains a number – this representation is suitable for being displayed on screen or in an info dialog box. If the detail flag is true, the version information is a multi-line string that specifies exactly which source files were compiled to build the DLL.</p>
<p>Under extraordinary circumstances, e.g. if you received a bleeding-edge test build of the DLL directly from a Frozen World developer, both the compact and the detailed version information may describe several distinct version numbers or contain a more detailed listing of different source files and their respective revisions.</p>
<p>This function can be called safely regardless of the library's state (i.e. even before startup and after teardown) and the thread they're called from.</p>
<h2 id="error-flag-and-diagnostic-error-messages">Error flag and diagnostic error messages</h2>
<pre><code class="lang-cpp">bool FrozenWorld_GetError();

// -&gt; number of chars (excluding trailing null) copied to the buffer
int FrozenWorld_GetErrorMessage(  
    int messageBufferSize,
    char* messageOut);
</code></pre>
<p>Every function validates parameters and preconditions. If anything is amiss, the function returns immediately (with 0, false, or a similar non-result) and sets the error flag that can be queried with <code>FrozenWorld_GetError()</code>. If the function completes without errors, the error flag is reset.</p>
<p>Call <code>FrozenWorld_GetErrorMessage()</code> to get further detailed diagnostic information about the cause of the error to help you debug the problem. If the error flag isn't set, the returned error message is empty.</p>
<p>These functions can be called safely regardless of the library's state (i.e. even before startup and after teardown). The error information returned by these functions always relates to the most recent (other) function call executed on the same thread.</p>
<h2 id="diagnostic-data-recordings">Diagnostic data recordings</h2>
<p>Frozen World's serialization facility can be used to create a continuous recording of all state necessary to investigate Frozen World's runtime behavior after the fact. Diagnostic recordings can be invaluable assets for offline debugging and testing and are designed to be sufficiently compact and unobtrusive to allow them to be created by default.</p>
<p>See <a href="#persistence">Persistence</a> below.</p>
<h1 id="startup-and-teardown">Startup and teardown</h1>
<pre><code class="lang-cpp">void FrozenWorld_Init();
void FrozenWorld_Destroy();
</code></pre>
<p>The <code>FrozenWorld_Init()</code> function initializes memory management and allocates some internal data structures in the Frozen World library. It must be called at least once at the start of the session before any of the other Frozen World functions are called.</p>
<p>At the end of the session, <code>FrozenWorld_Destroy()</code> must be called once for every prior call to <code>FrozenWorld_Init()</code> to clean up.</p>
<p>Both functions can be called multiple times, but must be called in pairs: The first invocation of <code>FrozenWorld_Init()</code> performs the actual initialization, and the corresponding (last) invocation of <code>FrozenWorld_Destroy()</code> performs the actual cleanup. All other invocations do nothing. This is useful if there are several user libraries that want to access the Frozen World library without requiring them to coordinate startup and teardown among themselves.</p>
<p>These functions are internally synchronized. It is acceptable to call <code>FrozenWorld_Destroy()</code> from a different thread than <code>FrozenWorld_Init()</code>.</p>
<h1 id="alignment-frame-to-frame">Alignment (frame-to-frame)</h1>
<h2 id="initializing-the-spongy-snapshot-and-aligning-the-frozen-frame-of-reference">Initializing the spongy snapshot and aligning the frozen frame of reference</h2>
<h3 id="1-initialize-the-spongy-snapshot">1. Initialize the spongy snapshot</h3>
<pre><code class="lang-cpp">// Step 1 of 3:
void FrozenWorld_Step_Init();
</code></pre>
<p>This clears the SPONGY snapshot. After you've called <code>FrozenWorld_Step_Init()</code>, just must fill the SPONGY snapshot manually with…</p>
<ul>
<li><p>The head's current position and orientation.</p>
</li>
<li><p>All anchors you know the current transform (in relation to the head) of. The fragment association of anchors in the SPONGY snapshot is ignored (fragments are created during the alignment step automatically based on whether Frozen World can automatically deduce a spatial relationship between them), so you can use <code>FrozenWorld_FragmentId_UNKNOWN</code> for them.</p>
</li>
<li><p>Edges between those anchors to signify which pairs of anchors are directly spatially related to each other. For example, two anchors next to each other in the same room should be connected by an edge; but two anchors separated by a wall shouldn't be.</p>
</li>
<li><p>The current most significant anchor among those you've added to the SPONGY snapshot. This is the anchor whose relation to the head is presumably (or likely) most accurately represented in the SPONGY snapshot. This information is used in various ways, e.g. as a starting point when walking though the anchor graph to gather supports (see next step) or when placing scene objects (see <a href="#creating-and-tracking-scene-object-attachment-points">Creating and tracking scene object attachment points</a> below).</p>
</li>
</ul>
<p>See <a href="#accessing-snapshots">Accessing snapshots</a> below (also for an introduction on the different kinds of snapshots).</p>
<h3 id="2-gather-alignment-supports-from-the-spongy-snapshot">2. Gather alignment supports from the spongy snapshot</h3>
<pre><code class="lang-cpp">// Step 2 of 3:
int FrozenWorld_Step_GatherSupports();  // -&gt; number of gathered supports
</code></pre>
<p>After this function has run, alignment supports can be inspected or tweaked (e.g. to extend or filter the set gathered by default, change the specific location used for alignment, change the relevance and tightness metrics used to weigh supports against each other, or just to visualize the gathered supports).</p>
<p>This function uses the Frozen World alignment configuration to select which anchors from the SPONGY snapshot to gather for supports and how their relevance and tightness metrics are calculated.</p>
<p>Calling this function is optional: You can just as well implement this step manually by creating a set of alignment supports yourself.</p>
<p>See <a href="#configuring-frozen-world-alignment">Configuring Frozen World alignment</a> and <a href="#accessing-alignment-supports">Accessing alignment supports</a> below.</p>
<h3 id="3-align-the-frozen-world-to-the-alignment-supports">3. Align the Frozen World to the alignment supports</h3>
<pre><code class="lang-cpp">// Step 3 of 3:
void FrozenWorld_Step_AlignSupports();
</code></pre>
<p>Alignment is based on the previously initialized SPONGY snapshot and the previously gathered supports.</p>
<p>After this function has run, the FROZEN snapshot can be inspected to find the updated head (i.e. camera) transform (or the alignment transform of the most recently used spongy coordinate frame relative to the frozen coordinate frame) or to visualize frozen anchors and edges.</p>
<p>In addition, after running this function all alignment metrics are also updated and can be queried to find out if a fragment merge or refreeze is indicated (based on configurable thresholds).</p>
<p>See <a href="#accessing-snapshots">Accessing snapshots</a> and <a href="#querying-metrics">Querying metrics</a> below.</p>
<h2 id="configuring-frozen-world-alignment">Configuring Frozen World alignment</h2>
<p>Modify the Frozen World alignment configuration to tweak the results of <code>FrozenWorld_Step_GatherSupports()</code>, which affect alignment quality, to the requirements of the implemented scenario. There is a default Frozen World alignment configuration, so doing this is optional.</p>
<pre><code class="lang-cpp">struct FrozenWorld_AlignConfig
{
    // Max edge deviation (0.0..1.0, default 0.05) to cut off 
    // significantly deviating anchors from alignment
    float edgeDeviationThreshold;

    // Relevance gradient away from head
    float relevanceSaturationRadius;  // 1.0 at this distance from head
    float relevanceDropoffRadius;     // 0.0 at this distance (must be 
                                      // greater than saturation radius)

    // Tightness gradient away from head
    float tightnessSaturationRadius;  // 1.0 at this distance from head
    float tightnessDropoffRadius;     // 0.0 at this distance (must be greater 
                                      // than saturation radius)
};

void FrozenWorld_GetAlignConfig(
    FrozenWorld_AlignConfig* configOut);

void FrozenWorld_SetAlignConfig(
    FrozenWorld_AlignConfig* config);
</code></pre>
<h2 id="accessing-alignment-supports">Accessing alignment supports</h2>
<p>Access alignment supports after the <code>FrozenWorld_Step_Gather()</code> function has run to extend, filter, change, or just inspect the alignment supports gathered from the SPONGY snapshot. Doing this is optional.</p>
<pre><code class="lang-cpp">struct FrozenWorld_Support
{
    FrozenWorld_AttachmentPoint attachmentPoint;

    float relevance;   // 1.0 (max) .. 0.0 (min, excluded)
    float tightness;   // 1.0 (max) .. 0.0 (min, only lateral alignment)
};

int FrozenWorld_GetNumSupports();

int FrozenWorld_GetSupports(
    int supportsBufferSize,
    FrozenWorld_Support* supportsOut);  // -&gt; number of elements copied to the buffer

void FrozenWorld_SetSupports(
    int numSupports,
    FrozenWorld_Support* supports);
</code></pre>
<h2 id="accessing-snapshots">Accessing snapshots</h2>
<p>Anchor and edge data is organized in different snapshots. Each snapshot contains (at least) any number of anchors along with their poses, fragment associations, and connecting edges. In addition, the SPONGY and FROZEN snapshots contain information about the current head pose and most significant anchor.</p>
<ul>
<li>The SPONGY snapshot must be populated (by you) frame-to-frame with input data to be used for <a href="#alignment-frame-to-frame">alignment</a>.</li>
<li>The FROZEN snapshot is maintained and kept up to date as a matter of course during alignment and will also be updated when the results of a <a href="#understanding-refit-operations-fragment-merge-and-refreeze">refit operation</a> are applied.</li>
</ul>
<p>Use these enum constants to indicate which snapshot's information you want to access:</p>
<pre><code class="lang-cpp">enum FrozenWorld_Snapshot
{
    FrozenWorld_Snapshot_SPONGY = 0,
    FrozenWorld_Snapshot_FROZEN = 1,
};
</code></pre>
<p>It is safe to read and modify different snapshots concurrently from different threads. It is unsafe to access the same snapshot (read or modify) concurrently from different threads, including through the use of functions that are documented to require access to these snapshots (e.g. all alignment functions, which require access to the SPONGY and FROZEN snapshots).</p>
<h2 id="accessing-the-head-pose-and-alignment">Accessing the head pose and alignment</h2>
<p>Get or set the head (i.e. camera) location and directions (only SPONGY and FROZEN snapshots):</p>
<pre><code class="lang-cpp">void FrozenWorld_GetHead(
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_Vector* headPositionOut,
    FrozenWorld_Vector* headDirectionForwardOut,
    FrozenWorld_Vector* headDirectionUpOut);

void FrozenWorld_SetHead(
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_Vector* headPosition,
    FrozenWorld_Vector* headDirectionForward,
    FrozenWorld_Vector* headDirectionUp);
</code></pre>
<p>Get or set the alignment transform, which maps coordinates in the Frozen World frame of reference into the most recently used spongy frame of reference:</p>
<pre><code class="lang-cpp">void FrozenWorld_GetAlignment(
    FrozenWorld_Transform* spongyFromFrozenTransformOut);

void FrozenWorld_SetAlignment(
    FrozenWorld_Transform* spongyFromFrozenTransform);
</code></pre>
<p>The alignment transform together with the most recent spongy head transform is wholly redundant with the frozen head transform. Use whichever is more convenient for you.</p>
<h2 id="accessing-the-most-significant-anchor">Accessing the most significant anchor</h2>
<p>Get or set the most significant anchor, i.e. the anchor whose pose relative to the head is currently known best (only SPONGY and FROZEN snapshots):</p>
<pre><code class="lang-cpp">void FrozenWorld_GetMostSignificantAnchorId(
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId* anchorIdOut);

void FrozenWorld_SetMostSignificantAnchorId(
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId anchorId);
</code></pre>
<p>Get the fragment identifier (as defined by the FROZEN snapshot) of the current most significant anchor:</p>
<pre><code class="lang-cpp">void FrozenWorld_GetMostSignificantFragmentId(
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_FragmentId* fragmentIdOut);
</code></pre>
<p>If the queried snapshot's most significant anchor is <code>FrozenWorld_AnchorId_INVALID</code>, this function returns <code>FrozenWorld_FragmentId_INVALID</code>.</p>
<p>If you query the fragment identifier of the most significant anchor in the SPONGY snapshot, this will still look up this anchor's fragment stored in the FROZEN snapshot (because fragment associations in the SPONGY snapshot are ignored). If the spongy most significant anchor doesn't exist in the FROZEN snapshot yet, querying its fragment identifier returns <code>FrozenWorld_FragmentId_UNKNOWN</code>.</p>
<h2 id="accessing-anchors">Accessing anchors</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Anchor
{
    FrozenWorld_AnchorId anchorId;
    FrozenWorld_FragmentId fragmentId;
    FrozenWorld_Transform transform;
};
</code></pre>
<p>Read all anchors in the snapshot:</p>
<pre><code class="lang-cpp">int FrozenWorld_GetNumAnchors(
    FrozenWorld_Snapshot snapshot);

int FrozenWorld_GetAnchors(  // -&gt; number of elements copied to the buffer
    FrozenWorld_Snapshot snapshot,
    int anchorsBufferSize,
    FrozenWorld_Anchor* anchorsOut);
</code></pre>
<p>Add anchors to the snapshot or update an individual anchor's transform or fragment association (use with care!):</p>
<pre><code class="lang-cpp">void FrozenWorld_AddAnchors(
    FrozenWorld_Snapshot snapshot,
    int numAnchors,
    FrozenWorld_Anchor* anchors);

bool FrozenWorld_SetAnchorTransform(  // -&gt; true if the anchor exists
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId anchorId,
    FrozenWorld_Transform* transform);

bool FrozenWorld_SetAnchorFragment(  // -&gt; true if the anchor exists
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId anchorId,
    FrozenWorld_FragmentId fragmentId);
</code></pre>
<p>Remove an individual anchor (and all edges attached to it), or all anchors (along with all edges) at once:</p>
<pre><code class="lang-cpp">bool FrozenWorld_RemoveAnchor(  // -&gt; true if the anchor existed before being removed
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId anchorId);

void FrozenWorld_ClearAnchors(
    FrozenWorld_Snapshot snapshot);
</code></pre>
<h2 id="accessing-graph-edges">Accessing graph edges</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Edge
{
    FrozenWorld_AnchorId anchorId1;
    FrozenWorld_AnchorId anchorId2;
};
</code></pre>
<p>Read all edges between anchors in the snapshot:</p>
<pre><code class="lang-cpp">int FrozenWorld_GetNumEdges(
    FrozenWorld_Snapshot snapshot);

int FrozenWorld_GetEdges(  // -&gt; number of elements copied to the buffer
    FrozenWorld_Snapshot snapshot,
    int edgesBufferSize,
    FrozenWorld_Edge* edgesOut);
</code></pre>
<p>Note that querying the number of edges is not a constant-time operation because edges are stored in a sparse array, so all edges must be enumerated in order to find out how many edges there are. If this is a performance concern, consider saving the number of edges from frame to frame and change your edge buffer size based on the number of edges stored indicated by the return value of <code>FrozenWorld_GetEdges()</code>.</p>
<p>Add edges between anchors to the snapshot:</p>
<pre><code class="lang-cpp">void FrozenWorld_AddEdges(
    FrozenWorld_Snapshot snapshot,
    int numEdges,
    FrozenWorld_Edge* edges);
</code></pre>
<p>Remove an individual edge, or all edges at once:</p>
<pre><code class="lang-cpp">bool FrozenWorld_RemoveEdge(  // -&gt; true if the edge existed before being removed
    FrozenWorld_Snapshot snapshot,
    FrozenWorld_AnchorId anchorId1,
    FrozenWorld_AnchorId anchorId2);

void FrozenWorld_ClearEdges(
    FrozenWorld_Snapshot snapshot);
</code></pre>
<h1 id="utility-functions">Utility functions</h1>
<h2 id="merging-anchors-and-edges">Merging anchors and edges</h2>
<pre><code class="lang-cpp">int FrozenWorld_MergeAnchorsAndEdges(  // -&gt; number of anchors added to the target snapshot
    FrozenWorld_Snapshot sourceSnapshot,
    FrozenWorld_Snapshot targetSnapshot);
</code></pre>
<p>Copies all anchors and edges that exist in sourceSnapshot but don't exist in targetSnapshot into targetSnapshot, effectively merging all anchors and edges from both snapshots into targetSnapshot.</p>
<p>While doing that, this function adapts fragment associations and anchor poses of the source anchors that are copied over:</p>
<ul>
<li><p>If there is an overlap of anchors between a source and a target fragment, all non-overlapping anchors in that source fragment are added to the corresponding target fragment (i.e. have their fragmentId reassigned to match the target fragment) and have their poses adapted to become consistent with the poses of previously existing target anchors in the target fragment.</p>
</li>
<li><p>If one source fragment <strong>overlaps several target fragments</strong>, the source fragment is split and all non-overlapping source anchors are added to the single target fragment that has the greatest overlap with the source fragment (in number of overlapping anchors).</p>
</li>
<li><p>If a source fragment <strong>overlaps no target fragment</strong> at all, its anchors are copied into targetSnapshot into a new target fragment with a uniquely chosen fragmentId that doesn't exist yet in targetSnapshot. The poses of these anchors remain the same as in sourceSnapshot.</p>
</li>
</ul>
<p>You can use this function to bulk-integrate an entire SPONGY snapshot into the FROZEN snapshot instead of relying on auto-discovery of not-yet-seen support anchors during alignment. This is not usually needed, but it can be useful if you require a guarantee that all anchors you have in your SPONGY snapshot have meaningful corresponding FROZEN poses.</p>
<h2 id="identifying-missing-edges-that-would-guarantee-full-graph-connectivity">Identifying missing edges that would guarantee full graph connectivity</h2>
<pre><code class="lang-cpp">int FrozenWorld_GuessMissingEdges(  // -&gt; number of elements copied to the buffer
    FrozenWorld_Snapshot snapshot,
    int guessedEdgesBufferSize,
    FrozenWorld_Edge* guessedEdgesOut);
</code></pre>
<p>Identifies edges that are missing in the given snapshot to guarantee that all anchors in every fragment are fully connected through edges.</p>
<p>The 'guessing' aspect of this function that's suggested by the function name is that while an edge between two anchors should signify that there's traversable free space between these two anchors, this function (obviously) can't know that and therefore makes a guess based on the geometric proximity of anchors. The result of this is a graph that more or less represents the path a user might have taken while creating these anchors.</p>
<p>This function attempts (on a best-effort basis) to avoid very short edges between anchors that are very close to each other. Since the 'edge deviation' metric used internally to identify fractures in the graph (which are caused by SPONGY anchor relations deviating too much from FROZEN anchor relations) is relative to edge length, a very short edge will exhibit a huge 'edge deviation' metric (and cause undesired fracturing or refreeze) if its two anchors change their relation even just a little bit. For this reason, this function will suggest a detour over a slightly more distant anchor to avoid a very short edge as long as full graph connectivity can still be guaranteed.</p>
<p>If the return value of this function indicates that the entire <code>guessedEdgesOut</code> buffer was filled with data, there may be more missing edges than can be returned given the buffer size specified by <code>guessedEdgesBufferSize</code>. In this case, you can add the guessed edges to the snapshot using the <code>FrozenWorld_AddEdges()</code> function and call <code>FrozenWorld_GuessMissingEdges()</code> again to identify more missing edges.</p>
<h2 id="inspecting-metrics-and-indicators">Inspecting metrics and indicators</h2>
<p>Query Frozen World alignment metrics to get a standardized high-level view on the current alignment quality. Metrics include indicator flags you can use to determine if a fragment merge is currently possible or if a refreeze is indicated (based on thresholds you configured in your Frozen World alignment and metric configuration settings).</p>
<p>Visual deviation, which is caused by trade-offs made while aligning the Frozen World to the SPONGY snapshot, is measured by these metrics:</p>
<ul>
<li><p><strong>Linear deviation</strong> is simply the distance between a support point in the most recent SPONGY snapshot and its aligned counterpart in the Frozen World. If alignment is perfect, linear deviation is zero.</p>
</li>
<li><p><strong>Lateral deviation</strong> shoots two imaginary rays, a 'spongy ray' and a 'frozen ray', from the head (i.e. camera) position to a support point in the most recent SPONGY snapshot and to its aligned counterpart in the Frozen World. The spongy ray is then intersected with the frozen support point's view plane (i.e. a plane that is orthogonal to the frozen ray and goes through the frozen support point). The lateral deviation metric is the distance between this intersection point of the spongy ray and the frozen support point. If alignment is perfect, lateral deviation is zero.</p>
</li>
<li><p><strong>Angular deviation</strong> is the angle (expressed in radians) between the spongy ray and the frozen ray described for lateral deviation above. If alignment is perfect, angular deviation is zero; the maximum possible angular deviation is pi (i.e. 180°). Angular deviation is capped to a configurable minimum distance between the head and the spongy and frozen support point, i.e. limited to the angle as if the head was moved to the center of a circle whose radius is the configured 'near distance' and that goes through the spongy and frozen support point.</p>
</li>
</ul>
<p>Other than being convenient, using these functions is optional: All metrics calculated by the built-in function could just as well be calculated in user code.</p>
<h2 id="querying-metrics">Querying metrics</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Metrics
{
    // Merge and refreeze indicators
    bool refitMergeIndicated;
    bool refitRefreezeIndicated;          // configurable

    // Currently trackable fragments
    int numTrackableFragments;

    // Alignment supports
    int numVisualSupports;
    int numVisualSupportAnchors;
    int numIgnoredSupports;
    int numIgnoredSupportAnchors;

    // Visual deviation metrics
    float maxLinearDeviation;
    float maxLateralDeviation;
    float maxAngularDeviation;            // configurable
    float maxLinearDeviationInFrustum;    // configurable
    float maxLateralDeviationInFrustum;   // configurable
    float maxAngularDeviationInFrustum;   // configurable
};

void FrozenWorld_GetMetrics(
    FrozenWorld_Metrics* metricsOut);
</code></pre>
<p>Metrics are calculated for the support points in the SPONGY snapshot, so if you use <code>FrozenWorld_Step_GatherSupports()</code> instead of your own code to gather supports, metrics are affected by these alignment configuration settings (see <a href="#configuring-frozen-world-alignment">Configuring Frozen World alignment</a> above):</p>
<ul>
<li>The relevanceDropoffRadius setting controls the maximum distance of a support point from the head.</li>
<li>The edgeDeviationThreshold setting may cause some supports to be ignored for visual alignment, which is a refreeze indicator in and of itself and also excludes the ignored supports from all visual deviation metrics.</li>
</ul>
<p>Some metrics are also affected by metrics configuration settings (see <a href="#configuring-metrics">Configuring metrics</a> below):</p>
<ul>
<li>The refitRefreezeIndicated flag is controlled by the refreeze… thresholds.</li>
<li>The angular deviation metrics (maxAngularDeviation and …InFrustum) are limited by the angularDeviationNearDistance setting.</li>
<li>The max…DeviationInFrustum metrics are controlled by the frustum… settings.</li>
</ul>
<p>Metrics apply to the most recent result of calling <code>FrozenWorld_Step_Align()</code> and are calculated lazily when    <code>FrozenWorld_GetMetrics()</code> is called either for the first time during a step or after <code>FrozenWorld_SetMetricsConfig()</code> was called.</p>
<h2 id="configuring-metrics">Configuring metrics</h2>
<p>Modify the metrics configuration to tweak indicators and frustum-dependent metrics to the requirements of the implemented scenario. There is a default metrics configuration, so doing this is optional.</p>
<pre><code class="lang-cpp">struct FrozenWorld_MetricsConfig
{
    // Angular deviation capped to this distance
    float angularDeviationNearDistance;

    // View frustum
    float frustumHorzAngle;
    float frustumVertAngle;

    // Thresholds for refreeze indicator
    float refreezeLinearDeviationThreshold;
    float refreezeLateralDeviationThreshold;
    float refreezeAngularDeviationThreshold;
};

void FrozenWorld_GetMetricsConfig(
    FrozenWorld_MetricsConfig* configOut);

void FrozenWorld_SetMetricsConfig(
    FrozenWorld_MetricsConfig* config);
</code></pre>
<h1 id="understanding-refit-operations-fragment-merge-and-refreeze">Understanding refit operations (fragment merge and refreeze)</h1>
<p>In general, you can simply work with locations, distances, and scene object transforms in your scene graph as in any big, rigid coordinate system. Allowing you to do this is at the core of what Frozen World wants to provide to you.</p>
<p>However, as the device's tracking doesn't supply an absolute position in the real world, sometimes two parts of the coordinate system that were originally thought to be separate are discovered to be actually connected to each other, necessitating a fragment merge; or tracking errors accumulate to a degree that makes it necessary to rearrange things in the scene graph to improve alignment quality from there on out, necessitating a refreeze.</p>
<p>These refit operations (i.e. fragment merge and refreeze) occur relatively rarely. Usually, they happen somewhat more frequently as long as the device is still exploring unknown spaces, and they become more infrequent (or even stop happening at all) as the device continues learning about its environment. (In fact, if your device has sufficiently learned about the environment you are using it in, you may never have to deal with refit operations at all.)</p>
<p>Refit operations do not happen automatically: You must actively initiate them when they are indicated. This gives you the opportunity to postpone them until your scene is in a state that makes it easier for you to deal with the refit. You can even rate-limit refit operations yourself.</p>
<p>A refit operation becomes indicated (see <a href="#inspecting-metrics-and-indicators">Inspecting metrics and indicators</a> above) as deviations between the generally immutable Frozen World and the always-changing, always-evolving SPONGY snapshots supplied during alignment become too great. Whatever counts as 'too great' is a subjective and application-dependent quality trade-off you must make based on your particular scenario. (You can use the default configuration and indicators as a starting point.)</p>
<p>As the last step of doing a refit operation, some or all of your scene objects must change their actual transform in the scene coordinate system so they stay visually aligned with the real world. Since you are yourself in control of initiating refit operations, there is no need for this 'scene refit' to be done in realtime on a per-frame budget: Your code can take however much time it needs to get it right.</p>
<h2 id="creating-and-tracking-scene-object-attachment-points">Creating and tracking scene object attachment points</h2>
<p>Unfortunately, as device tracking errors accumulate, the result can be that things are close to each other (or even overlap) in Frozen World coordinate space that are nowhere near each other in the real world. For that reason, Frozen World coordinates alone aren't sufficient to fullly describe which ways two nearby scene objects should move, respectively, as the result of a refit operation.</p>
<p><strong>Attachment points</strong> are small data structures (see <a href="#typedefs-structs-and-constants-used-throughout-this-documentation">Typedefs, structs, and constants used throughout this page</a> above) that describe the logical attachment of something to a certain part of the Frozen World.</p>
<p>In essence, an attachment point captures which anchor is that scene object's own 'most significant' one (like the most significant anchor supplied for the device itself in a SPONGY snapshot). In addition to the anchor identifier, an attachment point also contains a location in that anchor's own frame of reference. This location normally coincides with the scene object's location if the scene object is sufficiently close to its anchor, but this is not a general rule you should rely on.</p>
<p>You should create and maintain an attachment point for every top-level scene object that can move independently.</p>
<p><strong>Attachment points aren't anchors</strong>. Even though they technically refer to <em>one</em> anchor in the frozen graph and encode a point in that anchor's coordinate system, they are not interpreted by Frozen World in a way that relates them to just <em>that one</em> anchor. Instead, an attachment point logically encodes 'a point in the graph between its anchors' for future reference when applying a refit operation, and to a significant degree any given attachment point could be referencing any of the anchors close to it without affecting its behavior at all.</p>
<p>This seems not so different from attaching a scene object directly to an anchor (e.g. an individual SpatialAnchor or Unity WorldAnchor) without Frozen World. However, there are two significant differences: Firstly, Frozen World attachment points never change position on their own; and secondly, unlike anchors, attachment points can (and should) be purposely transitioned through the scene to tag along with the scene object they're attaching to the Frozen World.</p>
<p><strong>Attachment points are lightweight</strong>. Creating or using an attachment point leaves no footprint inside the Frozen World library. None of the library functions that accept FrozenWorld_AttachmentPoint parameters alter the state of the Frozen World in any way (though they <em>do</em> inspect it). There is no library-side overhead involved in creating or maintaining a great number of attachment points (aside from, obviously, the compute involved in calling library functions with them).</p>
<h3 id="create-an-attachment-point-for-a-newly-placed-scene-object">Create an attachment point for a newly placed scene object</h3>
<pre><code class="lang-cpp">void FrozenWorld_Tracking_CreateFromHead(
    FrozenWorld_Vector* frozenLocation,
    FrozenWorld_AttachmentPoint* attachmentPointOut);

void FrozenWorld_Tracking_CreateFromSpawner(
    FrozenWorld_AttachmentPoint* spawnerAttachmentPoint,
    FrozenWorld_Vector* frozenLocation,
    FrozenWorld_AttachmentPoint* attachmentPointOut);
</code></pre>
<p>Which one of these functions you should call to create an attachment point for a newly placed scene object depends on whether the newly placed scene object was, from the logic and intent of your particular scenario, spawned off some already-existing scene object (like a rocket launched from a rocket launcher, or an egg laid by a duck, or a child window slate detached from its parent window slate) or not.</p>
<p>If you are placing a scene object without an initial relation to any existing scene objects, use <code>FrozenWorld_Tracking_CreateFromHead()</code>, which creates the initial attachment point for the scene object as if the device had spawned it. Otherwise, use <code>FrozenWorld_Tracking_CreateFromSpawner()</code> and pass the existing scene object's attachment point as the spawnerAttachmentPoint.</p>
<h3 id="track-an-attachment-point-when-its-scene-object-moves">Track an attachment point when its scene object moves</h3>
<p>When your scene object continuously moves through the scene (because it is animated or simulated; this does not apply to scene objects being relocated because of a refit operation!), you should move its attachment point along with it.</p>
<pre><code class="lang-cpp">void FrozenWorld_Tracking_Move(
    FrozenWorld_Vector* targetFrozenLocation,
    FrozenWorld_AttachmentPoint* attachmentPointInOut);
</code></pre>
<p>It is not necessary to move a scene object's attachment point every frame during continuous movement: You can wait until it has moved into a distance of at least a half-unit away from where you updated its attachment point before until you need to move the attachment point along with it. However, if you do so, you should, after preparing a refreeze, make sure to do one final update of the attachment point just prior to invoking <code>FrozenWorld_RefitRefreeze_CalcAdjustment()</code> to ensure that the calculated adjustment is based on the scene object's latest position.</p>
<p>Note that if you teleport a scene object through the scene (instead of continuously moving it through the scene), you should forget its prior attachment point data and initialize a new one from scratch based on the same considerations as for a newly placed scene object.</p>
<h2 id="initiating-and-executing-a-fragment-merge">Initiating and executing a fragment merge</h2>
<p>Fragment merge is due when there are multiple simultaneously trackable fragments represented in the SPONGY snapshot. (Built-in Frozen World metrics take only the support anchors used for alignment into consideration for the <code>refitMergeIndicated</code> flag.)</p>
<h3 id="1-initialize-the-fragment-merge">1. Initialize the fragment merge</h3>
<pre><code class="lang-cpp">// Step 1 of 4:
bool FrozenWorld_RefitMerge_Init();
</code></pre>
<p>The fragment merge operation is initialized with the current version of the SPONGY snapshot set up after <code>FrozenWorld_Step_Init()</code>. After the fragment merge has been initialized, it is safe to change the SPONGY and FROZEN snapshots without affecting the results of the fragment merge.</p>
<p><code>FrozenWorld_RefitMerge_Init()</code> returns true if the necessary preconditions for performing a fragment merge are given (i.e. there's more than one simultaneously trackable fragment represented in the SPONGY snapshot). If this is not the case, the function returns false, and the fragment merge operation is not initialized.</p>
<p>Successfully initializing a fragment merge operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the fragment merge operation is not successful, the other refit operation (if any) remains unaffected.</p>
<h3 id="2-prepare-the-fragment-merge">2. Prepare the fragment merge</h3>
<pre><code class="lang-cpp">// Step 2 of 4:
// Can be executed in a background thread.
void FrozenWorld_RefitMerge_Prepare();
</code></pre>
<p>Preparing the fragment merge is done based on information gathered by <code>FrozenWorld_RefitMerge_Init()</code> and is independent from ongoing changes to the state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration).</p>
<p>Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute <code>FrozenWorld_RefitMerge_Prepare()</code> asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background.</p>
<h3 id="3-inspect-fragment-merge-results-and-refit-the-scene">3. Inspect fragment merge results and refit the scene</h3>
<p>When <code>FrozenWorld_RefitMerge_Prepare()</code> has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending fragment merge. The scene objects affected by this are identified by the <code>anchorId</code> (or more precisely: the <code>fragmentId</code> of that anchor) stored in the attachment point you created and maintained for that scene object (see <a href="#creating-and-tracking-scene-object-attachment-points">Creating and tracking scene object attachment points</a> above).</p>
<pre><code class="lang-cpp">struct FrozenWorld_RefitMerge_AdjustedFragment
{
    FrozenWorld_FragmentId fragmentId;
    int numAdjustedAnchors;
    FrozenWorld_Transform adjustment;   // post-merged from pre-merged
};

// Step 3.1 of 4:
int FrozenWorld_RefitMerge_GetNumAdjustedFragments();

// Step 3.2 of 4:
// -&gt; number of elements copied to the buffer
int FrozenWorld_RefitMerge_GetAdjustedFragments(  
    int adjustedFragmentsBufferSize,
    FrozenWorld_RefitMerge_Adjustment* adjustedFragmentsOut);

// Step 3.3 of 4, for each adjusted fragment:
// -&gt; number of elements copied to the buffer
int FrozenWorld_RefitMerge_GetAdjustedAnchorIds(  
    FrozenWorld_FragmentId fragmentId,
    int adjustedAnchorIdsBufferSize,
    FrozenWorld_AnchorId* adjustedAnchorIdsOut);

// Step 3.4 of 4:
void FrozenWorld_RefitMerge_GetMergedFragmentId(
    FrozenWorld_FragmentId* mergedFragmentIdOut);
</code></pre>
<p>All scene objects that are in the same Frozen World fragment (i.e. attached to anchors that have the same fragmentId) must have their transforms adjusted by a single common adjustment transform, so you can rely on scene objects in the same fragment keeping relative position and orientation to each other. Keep in mind that orientations may change, too, so don't forget to adjust any directional vectors (e.g. velocities and accelerations) as well.</p>
<p>Note that the fragment itself that everything else is merged into is kept stationary. (Among all fragments that need to be merged, the one whose axis-aligned bounding box has the greatest volume in the Frozen World is chosen to remain stationary and be merged into.) Scene objects in the stationary fragment don't require adjustment, so this fragment isn't reported as an adjusted fragment.</p>
<h3 id="4-apply-the-fragment-merge-results-to-the-frozen-world-itself">4. Apply the fragment merge results to the Frozen World itself</h3>
<p>Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the fragment merge operation.</p>
<pre><code class="lang-cpp">// Step 4 of 4:
void FrozenWorld_RefitMerge_Apply();
</code></pre>
<p>You can only call <code>FrozenWorld_RefitMerge_Apply()</code> only once for a fragment merge operation. After <code>FrozenWorld_RefitMerge_Apply()</code> has been called, the function calls required to refit your scene's objects (see <a href="#3-inspect-fragment-merge-results-and-refit-the-scene">3. Inspect fragment merge results and refit the scene</a> above) cannot be called any longer until the next fragment merge has been prepared.</p>
<h2 id="initiating-and-executing-a-refreeze">Initiating and executing a refreeze</h2>
<p>Refreeze is due when anchor relations in the SPONGY snapshot have become so different from their Frozen World counterparts that the visual trade-offs made to align the Frozen World to the SPONGY snapshot are too significant to simply ignore. There is no clear-cut, objective threshold for this: Whether a refreeze is advisable depends on the quality trade-offs you are willing to make in your particular scenario. (Built-in Frozen World metrics use configurable thresholds and take only support anchors into consideration for the refitRefreezeIndicated flag.)</p>
<p>If a refreeze is executed when there are multiple simultaneously trackable fragments in the SPONGY snapshot, it will implicitly merge all anchors in those fragments into a single fragment during the refreeze.</p>
<h3 id="1-initialize-the-refreeze">1. Initialize the refreeze</h3>
<pre><code class="lang-cpp">// Step 1 of 4:
bool FrozenWorld_RefitRefreeze_Init();
</code></pre>
<p>The refreeze operation is initialized with the current version of the SPONGY snapshot set up after <code>FrozenWorld_Step_Init()</code>. After the refreeze has been initialized, it is safe to change the SPONGY and FROZEN snapshot without affecting the results of the refreeze.</p>
<p><code>FrozenWorld_RefitRefreeze_Init()</code> returns true if the necessary preconditions for performing a refreeze are given (i.e. there's more than one trackable anchor represented in the SPONGY snapshot within relevance distance from the head that's graph-connected to the current most significant anchor). If this is not the case, the function returns false, and the refreeze operation is not initialized.</p>
<p>Initializing a refreeze operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the refreeze operation is not successful, the other refit operation (if any) remains unaffected.</p>
<h3 id="2-prepare-the-refreeze">2. Prepare the refreeze</h3>
<pre><code class="lang-cpp">// Step 2 of 4:
// Can be executed in a background thread.
void FrozenWorld_RefitRefreeze_Prepare();
</code></pre>
<p>Preparing the refreeze is done based on information gathered by <code>FrozenWorld_RefitRefreeze_Init()</code> and is independent from changes to the ongoing state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration).</p>
<p>Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute <code>FrozenWorld_RefitRefreeze_Prepare()</code> asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background.</p>
<h3 id="3-inspect-refreeze-results-and-refit-the-scene">3. Inspect refreeze results and refit the scene</h3>
<p>When <code>FrozenWorld_RefitRefreeze_Prepare()</code> has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending refreeze. The scene objects affected by this are identified by the anchorId stored in the attachment point you created and maintained for that scene object (see Creating and tracking scene object attachment points above).</p>
<pre><code class="lang-cpp">// Step 3.1 of 4:
int FrozenWorld_RefitRefreeze_GetNumAdjustedAnchors();
int FrozenWorld_RefitRefreeze_GetNumAdjustedFragments();

// Step 3.2 of 4:
// -&gt; number of elements copied to the buffer
int FrozenWorld_RefitRefreeze_GetAdjustedFragmentIds(  
    int adjustedFragmentIdsBufferSize,
    FrozenWorld_FragmentId* adjustedFragmentIdsOut);
// -&gt; number of elements copied to the buffer
int FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds(  
    int adjustedAnchorIdsBufferSize,
    FrozenWorld_AnchorId* adjustedAnchorIdsOut);

// Step 3.3 of 4, for each attached scene object:
// -&gt; true if actually adjusted
bool FrozenWorld_RefitRefreeze_CalcAdjustment(  
    FrozenWorld_AttachmentPoint* attachmentPointInOut,
    FrozenWorld_Transform* objectAdjustmentOut);   // post-refrozen from pre-refrozen

// Step 3.4 of 4:
void FrozenWorld_RefitRefreeze_GetMergedFragmentId(
    FrozenWorld_FragmentId* mergedFragmentIdOut);
</code></pre>
<p>All scene objects that are attached to one of the anchors reported by <code>FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds()</code> must have their transforms adjusted by the attachment-point-specific adjustment transform supplied by <code>FrozenWorld_RefitRefreeze_CalcAdjustment()</code>. The scene object's attachment point itself must also adjusted, which happens automatically to the attachment point passed to this function.</p>
<p>It's possible for an anchor (or fragment) to be reported by <code>FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds()</code> or <code>…_GetAdjustedFragmentIds()</code> but for <code>FrozenWorld_RefitRefreeze_CalcAdjustment()</code> still to return false when it is called with an attachment point attached to that anchor. This can happen when the more in-depth calculations performed by <code>FrozenWorld_RefitRefreeze_CalcAdjustment()</code> come to the conclusion that, despite this anchor being within the refrozen area, it doesn't actually require any adjustment. In this case you're free to simply skip any follow-on processing you might otherwise want to do on your side after an adjustment.</p>
<h3 id="4-apply-the-refreeze-results-to-the-frozen-world-itself">4. Apply the refreeze results to the Frozen World itself</h3>
<p>Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the refreeze operation.</p>
<pre><code class="lang-cpp">// Step 4 of 4:
void FrozenWorld_RefitRefreeze_Apply();
</code></pre>
<p>You can only call <code>FrozenWorld_RefitRefreeze_Apply()</code> only once for a refreeze operation. After <code>FrozenWorld_RefitRefreeze_Apply()</code> has been called, the function calls required to refit your scene's objects (see <a href="#3-inspect-refreeze-results-and-refit-the-scene">3. Inspect refreeze results and refit the scene</a> above) cannot be called any longer until the next refreeze has been prepared.</p>
<h1 id="persistence">Persistence</h1>
<p>The Frozen World library's persistence support is mainly there for your convenience – there's no inaccessible essential internal state in the library and the binary recording/persistence format is simple and well-documented (see <a href="#frozen-world-binary-recording-format">Frozen World binary recording format</a> for details).</p>
<p>Instead of using the functions described in this section, you can also implement your own writing and reading facilities for Frozen World without any loss of fidelity. The functions described here just give you a simple, portable way to do the same with less effort, and they give you the no-effort guarantee that they will always be up to date with the latest version of both Frozen World itself (which might perhaps change or extend its data representation in a future update) and the Frozen World binary recording format (which might perhaps be extended to represent some data more efficiently in a future update).</p>
<p>The canonical Frozen World binary format is organized as a series (or: stream) of records and can be used for…</p>
<ul>
<li><p><strong>Persistence</strong> – i.e. saving essential Frozen World data with the intention of restoring its state later to continue a session.</p>
</li>
<li><p><strong>Diagnostics</strong> – i.e. saving all Frozen World data, including transient data like the SPONGY snapshot, with the intention of using it later to investigate why Frozen World behaved in a certain way in a certain situation (e.g. to debug your scene, or Frozen World's integration into your scene, or Frozen World itself) or to implement automated offline testing based on real recordings and interactions.</p>
</li>
</ul>
<p>Each stream of records is self-contained, i.e. can be usefully stored, transmitted, and read on its own.</p>
<p>However, the records in a given stream are not necessarily all self-contained: The recording format includes the possibility of encoding some data as updates relative to the previous record in the same stream in order to save space, so you need all records from the very start of that stream to guarantee that you can fully restore the recorded Frozen World state up to that point.</p>
<p>For any given stream you create using these functions, you can select what data is going to be saved to or restored from it:</p>
<ul>
<li><p>The <code>includePersistent</code> flag controls inclusion of the most essential Frozen World data required to fully restore a session. This includes all data that can be accessed through the following functions:</p>
<ul>
<li><code>FrozenWorld_GetAnchors(FROZEN, …)</code></li>
<li><code>FrozenWorld_GetEdges(FROZEN, …)</code></li>
</ul>
</li>
<li><p>The includeTransient flag controls inclusion of all other Frozen World state required to diagnose or replay a session. This includes all data that can be accessed through the following functions:</p>
<ul>
<li><code>FrozenWorld_GetAlignConfig()</code></li>
<li><code>FrozenWorld_GetHead(SPONGY, …)</code> and <code>(FROZEN, …)</code></li>
<li><code>FrozenWorld_GetAlignment()</code></li>
<li><code>FrozenWorld_GetMostSignificantAnchor(SPONGY, …)</code> and <code>(FROZEN, …)</code></li>
<li><code>FrozenWorld_GetAnchors(SPONGY, …)</code></li>
<li><code>FrozenWorld_GetEdges(SPONGY, …)</code></li>
<li><code>FrozenWorld_GetSupports()</code></li>
</ul>
</li>
</ul>
<p>Note that you should enable both flags to get useful diagnostic recordings. Enabling just the includeTransient flag by itself only really makes sense if your only intention is to replay SPONGY snapshot data for offline scene testing.</p>
<h2 id="serializing-saving-frozen-world-state">Serializing (saving) Frozen World state</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Serialize_Stream
{
    // Internal handle to this serialization stream
    int handle;

    // Number of bytes that at least remain to be serialized for a complete record
    int numBytesBuffered;

    // Real time in seconds serialized into this stream so far
    // (can be modified to control relative timestamps serialized into the stream)
    float time;

    // Selection of data to include in the stream
    // (can be modified to control what is serialized into the stream)
    bool includePersistent;     // frozen anchors and edges
    bool includeTransient;      // alignment config, all other snapshot data, supports
};
</code></pre>
<p>Frozen World recordings are an unbounded sequence of records. Each record encodes a single update's worth of Frozen World data including a relative time stamp that indicates how much real time passed since the last record in the stream was created.</p>
<p>The granularity of updates is entirely up to you:</p>
<ul>
<li><p>For recordings intended for persistence, you might write just a single record and then close the stream again – or keep a stream open and infrequently (e.g. once every few seconds) append regular updates as a good trade-off between storage space consumption and the timeliness and completeness of the saved data in case your scene quits unexpectedly (e.g. because it crashed).</p>
</li>
<li><p>For recordings intended for diagnostics and replay, keep the stream open and frequently (i.e. once every step, just after doing Frozen World alignment) append updates to your recording file. The recording format is designed to be space-efficient and doesn't write a lot of data if nothing much changed since the last record.</p>
</li>
</ul>
<h3 id="1-opening-the-stream">1. Opening the stream</h3>
<pre><code class="lang-cpp">// Step 1 of 3:
void FrozenWorld_Serialize_Open(
    FrozenWorld_Serialize_Stream* streamInOut);
</code></pre>
<p>Allocate one instance of the <code>FrozenWorld_Serialize_Stream</code> data structure per stream you want to keep open at the same time.</p>
<p>The stream's time property passed to <code>FrozenWorld_Serialize_Open()</code> defines the absolute starting time of the stream, which is used later to calculate the relative time encoded in the first record when <code>FrozenWorld_Serialize_Gather()</code> is called for the first time for this stream.</p>
<p>It's best to set the stream's initial time property to your scene's current absolute runtime when you call  <code>FrozenWorld_Serialize_Open()</code>.</p>
<h3 id="2-preparing-a-data-record-and-getting-its-binary-data-to-save">2. Preparing a data record and getting its binary data to save</h3>
<p>After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like, even across an entire session:</p>
<pre><code class="lang-cpp">// Step 2.1 of 3:
void FrozenWorld_Serialize_Gather(
    FrozenWorld_Serialize_Stream* streamInOut);

// Step 2.2 of 3, repeated until no more data is available:
// Can be executed in a background thread.
int FrozenWorld_Serialize_Read(  // -&gt; number of bytes copied to the buffer
    FrozenWorld_Serialize_Stream* streamInOut,
    int bytesBufferSize,
    char* bytesOut);
</code></pre>
<p>Calling <code>FrozenWorld_Serialize_Gather()</code> quickly gathers all information needed for a full record.</p>
<p>The stream's time property when <code>FrozenWorld_Serialize_Gather()</code> is called directly controls what relative time (since last record) is encoded in the new record – it's best to keep the stream's time property always set to your scene's absolute runtime.</p>
<p>After gathering data, repeatedly call <code>FrozenWorld_Serialize_Read()</code> to copy the serialized binary data of the record into a buffer provided by you, which you can then in turn output/write to wherever you want the recording stream to be physically stored (e.g. a file on disk or a network stream). While you're reading data you can check the stream's numBytesBuffered property to get an indication of how much more data there is at least left to be serialized for this record, which may be useful if you want to e.g. implement rotating size-limited recording files on your side.</p>
<p>Reading serialized binary data by calling <code>FrozenWorld_Serialize_Read()</code> can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies that are hard to completely avoid when writing data to disk or over network.</p>
<p>You mustn't call <code>FrozenWorld_Serialize_Gather()</code> again before all data from the previous record has been read (it will signal an error if you do), but it is safe to simply skip a call to <code>FrozenWorld_Serialize_Gather()</code> if writing the previous record's data is still in progress in your background thread. This won't cause your saved recording to become inconsistent or lose data – it will only reduce the granularity of the recording in that instance.</p>
<h3 id="3-closing-the-stream-to-release-internal-resources">3. Closing the stream to release internal resources</h3>
<pre><code class="lang-cpp">// Step 3 of 3:
void FrozenWorld_Serialize_Close(
    FrozenWorld_Serialize_Stream* streamInOut);
</code></pre>
<p>Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when <code>FrozenWorld_Destroy()</code> is called.</p>
<p><code>FrozenWorld_Serialize_Close()</code> will signal an error if the previous record wasn't fully read because that means you have received (and may have output/written) incomplete data that can't be fully deserialized later. You can set the stream's numBytesBuffered property to zero prior to calling <code>FrozenWorld_Serialize_Close()</code> to suppress this error.</p>
<p>After calling <code>FrozenWorld_Serialize_Close()</code>, the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the <code>FrozenWorld_Serialize_Stream</code> data structure to open a new stream later.</p>
<h2 id="deserializing-loading-and-restoring-frozen-world-state">Deserializing (loading and restoring) Frozen World state</h2>
<pre><code class="lang-cpp">struct FrozenWorld_Deserialize_Stream
{
    // Internal handle to this deserialization stream
    int handle;

    // Number of bytes that at least remain to be deserialized for a complete record
    int numBytesRequired;

    // Real time in seconds deserialized from this stream so far
    // (can be modified to change its base value for subsequent deserialized records)
    float time;

    // Selection of data applied from the stream
    // (can be modified to control what is deserialized from the stream)
    bool includePersistent;     // frozen anchors and edges
    bool includeTransient;      // alignment config, all other snapshot data, supports
};
</code></pre>
<p>When reading a Frozen World recording, you must read and apply all updates beginning at the start of the stream.</p>
<p>However, there is no requirement to do this in real time, and you can read and apply even large streams (in the order of hundreds of megabytes and tens of thousands of records) fairly quickly from start to end in order to arrive at a certain recorded point in time.</p>
<p>You can choose to read just a subset of the data contained in the stream by setting the stream's <code>includePersistent</code> and <code>includeTransient</code> flags. Of course, enabling <code>includePersistent</code> won't do anything if the stream doesn't contain such data (i.e. wasn't created with the <code>includePersistent</code> flag set during serialization), and the same goes for <code>includeTransient</code>.</p>
<h3 id="1-opening-the-stream-1">1. Opening the stream</h3>
<pre><code class="lang-cpp">// Step 1 of 3:
void FrozenWorld_Deserialize_Open(
    FrozenWorld_Deserialize_Stream* streamInOut);
</code></pre>
<p>Allocate one instance of the <code>FrozenWorld_Deserialize_Stream</code> structure per stream you want to keep open at the same time.</p>
<p>The stream's time property is ignored by <code>FrozenWorld_Deserialize_Open()</code>, but it's later updated by <code>FrozenWorld_Deserialize_Apply()</code> by successively aggregating the relative time stamps included in the records that are read. You can change the time property at any time.</p>
<p>It's best to set the stream's initial time property either to zero (in order to track this stream's progress in time) or to your scene's current absolute runtime (in order to track the stream's progress in terms of your scene's absolute runtime).</p>
<h3 id="2-loading-binary-data-into-the-stream-and-applying-the-results">2. Loading binary data into the stream and applying the results</h3>
<p>After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like and as long as you have data to feed into the stream:</p>
<pre><code class="lang-cpp">// Step 2a of 3, repeatedly until no more data is consumed:
// Can be executed in a background thread.
int FrozenWorld_Deserialize_Write(  // -&gt; number of bytes consumed from the buffer
    FrozenWorld_Deserialize_Stream* streamInOut,
    int numBytes,
    char* bytes);

// Step 2b of 3:
void FrozenWorld_Deserialize_Apply(
    FrozenWorld_Deserialize_Stream* streamInOut);
</code></pre>
<p>Repeatedly call <code>FrozenWorld_Deserialize_Write()</code> with more data read from your data source (e.g. a file on disk or a network stream you've opened) until it returns zero, indicating that the record is complete and no more data needs to be consumed for this record. While you're doing this, you can check the stream's <code>numBytesRequired</code> to get an indication of how much more data must be read at least for this record, which is useful if you want to make sure you read no more than the exact required amount of data from your data source.</p>
<p>Feeding serialized binary data by calling <code>FrozenWorld_Deserialize_Write()</code> can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies (or blocking I/O calls while a network stream is waiting for more data to arrive) that are hard to avoid when reading data from disk or from a network.</p>
<p>Even if input data is invalid, <code>FrozenWorld_Deserialize_Write()</code> will never report this as an error (as it's near-impossible to recognize binary recording data as malformed until it is parsed in detail and applied to Frozen World state). However, sufficiently malformed input may mislead <code>FrozenWorld_Deserialize_Write()</code> into requesting and consuming (if not necessarily buffering or meaningfully processing) any amount of input data while waiting for a valid record footer to appear in the data stream. If you're out of data to feed into <code>FrozenWorld_Deserialize_Write()</code> and it's still requesting more data, that in and of itself indicates that something may be wrong with the data you've fed it so far.</p>
<p>After feeding a record's worth of data to <code>FrozenWorld_Deserialize_Write()</code>, call <code>FrozenWorld_Deserialize_Apply()</code> to apply the information contained in the record to Frozen World's state. Any invalid data previously fed to <code>FrozenWorld_Deserialize_Write()</code> will be reported as an error by <code>Frozenworld_Deserialize_Apply()</code>.</p>
<p>You mustn't call <code>FrozenWorld_Deserialize_Apply()</code> until and unless a full record's worth of data has been fed into the library (it will signal an error if you do). This includes calling <code>FrozenWorld_Deserialize_Apply()</code> more than once without feeding more data in between the two calls. This behavior cannot be suppressed, so it is impossible to apply truncated records.</p>
<p>You can change the <code>includePersistent</code> and <code>includeTransient</code> flags in between calls to <code>FrozenWorld_Deserialize_Apply()</code>. However, after the first call to <code>FrozenWorld_Deserialize_Apply()</code> for a given stream, you can only switch those flags off – you cannot start out with one or both of the flags disabled and switch them on mid-stream. The reason for this is that individual records might only encode an update instead of being fully self-contained, so skipping some records in the middle of the stream may leave the affected Frozen World data structures in an incomplete state.</p>
<h3 id="3-closing-the-stream-to-release-internal-resources-1">3. Closing the stream to release internal resources</h3>
<pre><code class="lang-cpp">// Step 3 of 3:
void FrozenWorld_Deserialize_Close(
    FrozenWorld_Deserialize_Stream* streamInOut);
</code></pre>
<p>Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when <code>FrozenWorld_Destroy()</code> is called.</p>
<p>After calling <code>FrozenWorld_Deserialize_Close()</code>, the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the <code>FrozenWorld_Deserialize_Stream</code> data structure to open a new stream later.</p>
<p>Frozen World configuration and snapshots (both spongy and frozen) can be recorded in a platform-independent, compact, binary, streaming format to help with debugging and diagnostics and to create (or record) test scenarios.</p>
<h1 id="frozen-world-binary-recording-format">Frozen World binary recording format</h1>
<h2 id="general-structure">General structure</h2>
<p>A recording stream is an unbounded sequence of records. Each record is a sequence of tagged chunks. Each chunk is a sequence of fields.</p>
<h3 id="field-types">Field types</h3>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Storage</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>2 bytes, little-endian</td>
<td>Unsigned 16-bit integer</td>
</tr>
<tr>
<td>uint32</td>
<td>4 bytes, little-endian</td>
<td>Unsigned 32-bit integer</td>
</tr>
<tr>
<td>uint64</td>
<td>8 bytes, little-endian</td>
<td>Unsigned 64-bit integer</td>
</tr>
<tr>
<td>float</td>
<td>4 bytes, little-endian</td>
<td>IEEE single-precision floating point</td>
</tr>
<tr>
<td><em>type</em>[N]</td>
<td>N times the size of <em>type</em></td>
<td>Sequence of N instances of <em>type</em></td>
</tr>
</tbody>
</table>
<h3 id="field-padding-and-alignment">Field padding and alignment</h3>
<p>No padding is inserted between fields. Fields therefore have no particular guaranteed alignment (with respect to the start of the stream).</p>
<h3 id="general-record-structure">General record structure</h3>
<p>Each record starts with a record header chunk, followed by any number of data chunks (including potentially no data chunks at all), and completed with a record footer chunk. The required presence of a record footer is designed to allow readers to read a recording data stream without having to look ahead into the next record's data.</p>
<p>While records may contain any number of chunks, each chunk tag (see <a href="#general-chunk-structure">General chunk structure</a> below) can appear at most once per record. Readers are not required to support records that contain several instances (or several versions) of the same kind of chunk.</p>
<h3 id="general-chunk-structure">General chunk structure</h3>
<p>Each chunk has the following structure:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>Defines the kind of the chunk.</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>Defines the specific format of the chunk payload (together with the tag). <br>Version numbers start with 1. Version number 0 is reserved and not used.</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>Number of chunk payload bytes (not including the general chunk header bytes).</td>
</tr>
<tr>
<td>(…)</td>
<td>(…)</td>
<td>Chunk payload.</td>
</tr>
</tbody>
</table>
<p>The presence of the payload size in the chunk header is designed to allow readers to load entire chunks without having to parse them to find the end of the chunk or to skip chunks they cannot read.</p>
<h2 id="record-header-and-footer-chunks">Record header and footer chunks</h2>
<h3 id="record-header-chunk">Record header chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0000</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>relative time since last record</td>
<td>Number of (usually fractional) seconds that have passed since the last record in the stream. The value in the first record of the stream is ignored by readers.</td>
</tr>
</tbody>
</table>
<h3 id="record-footer-chunk">Record footer chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0xFFFF</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>0</td>
</tr>
</tbody>
</table>
<h2 id="data-chunks">Data chunks</h2>
<h3 id="alignment-configuration-chunk">Alignment configuration chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0101</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>20</td>
</tr>
<tr>
<td>float</td>
<td>edge deviation threshold</td>
<td>&gt; 0.0</td>
</tr>
<tr>
<td>float</td>
<td>relevance saturation radius</td>
<td>&gt; 0.0</td>
</tr>
<tr>
<td>float</td>
<td>relevance drop-off radius</td>
<td>Greater than relevance saturation radius.</td>
</tr>
<tr>
<td>float</td>
<td>tightness saturation radius</td>
<td>&gt; 0.0</td>
</tr>
<tr>
<td>float</td>
<td>tightness drop-off radius</td>
<td>Greater than tightness saturation radius.</td>
</tr>
</tbody>
</table>
<h3 id="alignment-supports-chunk">Alignment supports chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0401</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>4 + 28 * number of supports</td>
</tr>
<tr>
<td>uint32</td>
<td>number of supports</td>
<td></td>
</tr>
<tr>
<td>[…]</td>
<td><a href="#support-definition">Support definitions</a></td>
<td>One definition per support, in no particular order.</td>
</tr>
</tbody>
</table>
<h3 id="support-definition">Support definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint64</td>
<td>support anchor identifier</td>
<td></td>
</tr>
<tr>
<td>float[3]</td>
<td>support position from anchor</td>
<td>X, Y, Z (meters)</td>
</tr>
<tr>
<td>float</td>
<td>support relevance</td>
<td>0.0 … 1.0</td>
</tr>
<tr>
<td>float</td>
<td>support tightness</td>
<td>0.0 … 1.0</td>
</tr>
</tbody>
</table>
<h2 id="spongy-snapshot-chunks">Spongy snapshot chunks</h2>
<p>Spongy snapshots are stored as multiple chunks: the spongy snapshot header and, if required, the spongy graph.</p>
<p>The spongy snapshot header chunk can appear before or after the spongy graph chunk in the record, and there may be other chunks in between the header and the graph chunks.</p>
<p>In order to improve the stream's compactness (and potentially reader performance), the spongy graph can be stored in several alternative ways, individually chosen for each record:</p>
<ul>
<li>as a complete graph definition (that replaces the last known spongy graph),</li>
<li>as a graph update (applied to the last known state of the spongy graph read from this stream),</li>
<li>or not at all (to indicate that the spongy graph is unchanged from its last known state read from this stream).</li>
</ul>
<p>Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to).</p>
<h3 id="spongy-snapshot-header-chunk">Spongy snapshot header chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0201</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>36</td>
</tr>
<tr>
<td>float[3]</td>
<td>head position</td>
<td>X,Y,Z (meters)</td>
</tr>
<tr>
<td>float[4]</td>
<td>head orientation</td>
<td>X,Y,Z,W (quaternion)</td>
</tr>
<tr>
<td>uint64</td>
<td>most significant anchor identifier</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="spongy-graph-chunk">Spongy graph chunk</h3>
<p>See <a href="#graph-chunk-alternatives">Graph chunk alternatives</a> below for version, payload size, and payload.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0202 – Complete graph definition<br>0x0203 – Graph update</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td></td>
</tr>
<tr>
<td>(…)</td>
<td>(…)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="frozen-snapshot-chunks">Frozen snapshot chunks</h2>
<p>Frozen snapshots are stored as multiple chunks: the frozen snapshot header and, if required, the frozen graph.</p>
<p>The frozen snapshot header chunk can appear before or after the frozen graph chunk in the record, and there may be other chunks in between the header and the graph chunks.</p>
<p>In order to improve the stream's compactness (and potentially reader performance), the frozen graph can be stored in several alternative ways, individually chosen for each record:</p>
<ul>
<li>as a complete graph definition (that replaces the last known frozen graph),</li>
<li>as a graph update (applied to the last known state of the frozen graph read from this stream),</li>
<li>or not at all (to indicate that the frozen graph is unchanged from its last known state read from this stream).</li>
</ul>
<p>Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to).</p>
<h3 id="frozen-snapshot-header-chunk">Frozen snapshot header chunk</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0301</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>64</td>
</tr>
<tr>
<td>float[3]</td>
<td>alignment translation</td>
<td>X,Y,Z (meters)</td>
</tr>
<tr>
<td>float[4]</td>
<td>alignment rotation</td>
<td>X,Y,Z,W (quaternion)</td>
</tr>
<tr>
<td>float[3]</td>
<td>head position</td>
<td>X,Y,Z (meters)</td>
</tr>
<tr>
<td>float[4]</td>
<td>head orientation</td>
<td>X,Y,Z,W (quaternion)</td>
</tr>
<tr>
<td>uint64</td>
<td>most significant anchor identifier</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="frozen-graph-chunk">Frozen graph chunk</h3>
<p>See <a href="#graph-chunk-alternatives">Graph chunk alternatives</a> below for version, payload size, and payload.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>0x0302 – <a href="#complete-graph-definition">Complete graph definition</a><br>0x0303 – <a href="#graph-update">Graph update</a></td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td></td>
</tr>
<tr>
<td>(…)</td>
<td>(…)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="graph-chunk-alternatives">Graph chunk alternatives</h2>
<p>Writers should choose the most compact representation for a given graph. If the graph is unchanged compared to its last version written to this stream, no graph chunk should be written at all.</p>
<p>Readers are required to support any graph chunk representation at any time.</p>
<h3 id="complete-graph-definition">Complete graph definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>See specific uses above</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>8<br>+ 44 * number of anchors<br>+ 20 * number of edges</td>
</tr>
<tr>
<td>uint32</td>
<td>number of anchors</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>number of edges</td>
<td></td>
</tr>
<tr>
<td>[…]</td>
<td><a href="#anchor-definition">Anchor definitions</a></td>
<td>One definition per anchor, in no particular order.<br>Each anchor identifier can appear only once in this chunk.</td>
</tr>
<tr>
<td>[…]</td>
<td><a href="#edge-definition">Edge definitions</a></td>
<td>One definition per edge, in no particular order.<br>Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk.</td>
</tr>
</tbody>
</table>
<h3 id="graph-update">Graph update</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint16</td>
<td>tag</td>
<td>See specific uses above.</td>
</tr>
<tr>
<td>uint16</td>
<td>version</td>
<td>1</td>
</tr>
<tr>
<td>uint32</td>
<td>payload size</td>
<td>8<br>+ 44 * number of added or changed anchors<br>+ 20 * number of added or changed edges<br>+ 8 * number of removed anchors<br>+ 16 * number of removed edges</td>
</tr>
<tr>
<td>uint32</td>
<td>number of added or changed anchors</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>number of added or changed edges</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>number of removed anchors</td>
<td></td>
</tr>
<tr>
<td>uint32</td>
<td>number of removed edges</td>
<td></td>
</tr>
<tr>
<td>[…]</td>
<td>Added or changed <a href="#anchor-definition">anchor definitions</a></td>
<td>One definition per added or changed anchor, in no particular order.</td>
</tr>
<tr>
<td>[…]</td>
<td>Added or changed <a href="#edge-definition">edge definitions</a></td>
<td>One definition per added or changed edge, in no particular order.</td>
</tr>
<tr>
<td>[…]</td>
<td>Removed <a href="#anchor-identifier-definition">anchor identifiers</a></td>
<td>One identifier per removed anchor, in no particular order.<br>Each anchor identifier can appear only once in this chunk.</td>
</tr>
<tr>
<td>[…]</td>
<td>Removed <a href="#edge-anchor-identifier-definition">edge anchor identifiers</a></td>
<td>One definition per removed edge, in no particular order.<br>Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk.</td>
</tr>
</tbody>
</table>
<h3 id="anchor-definition">Anchor definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint64</td>
<td>anchor identifier</td>
<td></td>
</tr>
<tr>
<td>uint64</td>
<td>anchor fragment identifier</td>
<td></td>
</tr>
<tr>
<td>float[3]</td>
<td>anchor position</td>
<td>X,Y,Z (meters)</td>
</tr>
<tr>
<td>float[4]</td>
<td>anchor orientation</td>
<td>X,Y,Z,W (quaternion)</td>
</tr>
</tbody>
</table>
<h3 id="edge-definition">Edge definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint64</td>
<td>edge anchor identifier 1</td>
<td>Edge anchor identifiers are stored in slots 1/2 in no particular order.</td>
</tr>
<tr>
<td>uint64</td>
<td>edge anchor identifier 2</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>edge confidence</td>
<td>0.0 … 1.0</td>
</tr>
</tbody>
</table>
<h3 id="anchor-identifier-definition">Anchor identifier definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint64</td>
<td>anchor identifier</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="edge-anchor-identifier-definition">Edge anchor identifier definition</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Content</th>
<th>Additional information</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint64</td>
<td>edge anchor identifier 1</td>
<td>Edge anchor identifiers are stored in slots 1/2 in no particular order.</td>
</tr>
<tr>
<td>uint64</td>
<td>edge anchor identifier 2</td>
<td></td>
</tr>
</tbody>
</table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Microsoft/MixedReality-WorldLockingTools-Unity/blob/master/DocGen/api_doc/FrozenWorldDLL.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
