{
  "DocGen/api_doc/Architecture.html": {
    "href": "DocGen/api_doc/Architecture.html",
    "title": "Architecture | World Locking Tools for Unity Documentation",
    "keywords": "Architecture The World Locking Tools for Unity architecture may be summarized by the following diagram. In general, the client application will make its intent known declaratively through settings on the World Locking Manager. The managers, in turn, imperatively drive the processing by lower layers. While all World Locking Tools capabilities are available through asset creation in the Unity Editor, every effort has been made to provide equal access to construction and configuration from script. Any capability missing available in Unity's Inspector but not from the scripting API should be considered a code defect. Reporting is as a bug is appreciated! See contributing for more info. An exception to this flow is in the attachment point mechanism, which is discussed in detail in several articles within this documentation. In short, the client requests attachment points from the World Locking Attachment Point Manager. These attachment points then serve as conduits through which the application may be informed about refit operations. See also Attachment points WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager"
  },
  "DocGen/api_doc/FrozenWorldDLL.html": {
    "href": "DocGen/api_doc/FrozenWorldDLL.html",
    "title": "Typedefs, structs, and constants used throughout this documentation | World Locking Tools for Unity Documentation",
    "keywords": "Typedefs, structs, and constants used throughout this documentation Typedefs typedef uint64_t FrozenWorld_AnchorId; typedef uint64_t FrozenWorld_FragmentId; Structs struct FrozenWorld_Vector { float x; float y; float z; }; struct FrozenWorld_Quaternion { float x; float y; float z; float w; }; struct FrozenWorld_Transform { FrozenWorld_Vector position; FrozenWorld_Quaternion rotation; }; struct FrozenWorld_AttachmentPoint { FrozenWorld_AnchorId anchorId; FrozenWorld_Vector locationFromAnchor; }; Constants // Special values for FrozenWorld_AnchorId static const FrozenWorld_AnchorId FrozenWorld_AnchorId_INVALID = 0; static const FrozenWorld_AnchorId FrozenWorld_AnchorId_UNKNOWN = 0xFFFFFFFFFFFFFFFF; // Special values for FrozenWorld_FragmentId static const FrozenWorld_FragmentId FrozenWorld_FragmentId_INVALID = 0; static const FrozenWorld_FragmentId FrozenWorld_FragmentId_UNKNOWN = 0xFFFFFFFFFFFFFFFF; The most significant practical distinction between the INVALID and UNKNOWN anchor or fragment identifiers is that INVALID identifiers can never be stored in a snapshot (and attempting to do so anyway will lead to an error being reported) but UNKNOWN identifiers can. Semantically, use INVALID to express 'the anchor or fragment does not exist' and UNKNOWN to express 'the anchor or fragment exists, but it is ambiguous, not known, or not relevant at this point'. You can use FrozenWorld_FragmentId_UNKNOWN as the fragment association of all anchors you add to a SPONGY snapshot, for example, as Frozen World ignores them anyway and automatically assigns unique fragment identifiers to all anchors when they are added to the FROZEN snapshot during alignment. General considerations and conventions Parameter naming conventions Parameters may have an implied contract based on their name if it matches any of the following patterns (with foo in the following description being a generic placeholder that's substituted by any valid symbol name): Naming pattern Implied contract fooBufferSize, fooOut The fooOut pointer points to a writable memory buffer that has room for (at least) fooBufferSize elements of fooOut's pointed-to data type. fooBufferSize must be zero or positive. fooBufferSize is counted in elements of fooOut's pointed-to data type (not e.g. bytes). fooOut must not be null. It must always point to a valid address, even if fooBufferSize is zero. The called function will write no more than fooBufferSize elements to the memory pointed to by fooOut even if more data would be available. fooOut The memory pointed to by fooOut must be safe to be written to. Existing data in the pointed-to memory location is ignored. The function will not change the pointed-to memory except by writing a valid update to it; if fooOut points to a buffer intended to receive multiple elements of the same type, only some of the elements may have been written if an error occurs, but each of the written elements will have been written completely. fooInOut The memory pointed to by fooInOut may be read and must be safe to be written to. The information at the memory location pointed to by fooInOut must be valid (per the function's description). The function will not change the pointed-to memory except by writing a valid update to it; if fooInOut points to a buffer containing multiple elements of the same type, only some of the elements may have been updated if an error occurs, but each of the actually updated elements will have been updated completely. Thread safety This library is thread-aware, but functions in this library that change its state are not generally re-entrant or safe for being called concurrently unless explicitly noted otherwise. Read or query operations can be called safely from different threads in parallel as long as there are no concurrent calls to any functions that change the internal state of the library. Version information can be queried at any time in any thread. Error information can be queried at any time in any thread and always return error information for the last function called in the same thread. Startup and teardown are internally synchronized. It is acceptable to call FrozenWorld_Destroy() from a different thread than the one FrozenWorld_Init() was called on. Snapshot access of different snapshots is thread-safe – but reads and modifications of the same snapshot are not. However, it is safe to query the same snapshot's data from multiple threads in parallel as long as there are no concurrent modifications to it. Refit operations can be safely prepared in a background thread – though Init() and Apply() must be externally synchronized with all other accesses to the snapshots they read and modify. Persistence allows reading or writing to streams in a background thread – though Gather() and Apply() must be externally synchronized with all other accesses to the snapshots they read and modify. Diagnostics and errors Version information // -> number of chars (excluding trailing null) copied to the buffer int FrozenWorld_GetVersion( bool detail, int versionBufferSize, char* versionOut); Returns a representation of the DLL's version. This is useful to know when investigating suspected bugs and weird phenomena because it allows us to relate what you're seeing with a specific version of the Frozen World source code. If the detail flag is false, the returned version information is a short, single-line string contains a number – this representation is suitable for being displayed on screen or in an info dialog box. If the detail flag is true, the version information is a multi-line string that specifies exactly which source files were compiled to build the DLL. Under extraordinary circumstances, e.g. if you received a bleeding-edge test build of the DLL directly from a Frozen World developer, both the compact and the detailed version information may describe several distinct version numbers or contain a more detailed listing of different source files and their respective revisions. This function can be called safely regardless of the library's state (i.e. even before startup and after teardown) and the thread they're called from. Error flag and diagnostic error messages bool FrozenWorld_GetError(); // -> number of chars (excluding trailing null) copied to the buffer int FrozenWorld_GetErrorMessage( int messageBufferSize, char* messageOut); Every function validates parameters and preconditions. If anything is amiss, the function returns immediately (with 0, false, or a similar non-result) and sets the error flag that can be queried with FrozenWorld_GetError() . If the function completes without errors, the error flag is reset. Call FrozenWorld_GetErrorMessage() to get further detailed diagnostic information about the cause of the error to help you debug the problem. If the error flag isn't set, the returned error message is empty. These functions can be called safely regardless of the library's state (i.e. even before startup and after teardown). The error information returned by these functions always relates to the most recent (other) function call executed on the same thread. Diagnostic data recordings Frozen World's serialization facility can be used to create a continuous recording of all state necessary to investigate Frozen World's runtime behavior after the fact. Diagnostic recordings can be invaluable assets for offline debugging and testing and are designed to be sufficiently compact and unobtrusive to allow them to be created by default. See Persistence below. Startup and teardown void FrozenWorld_Init(); void FrozenWorld_Destroy(); The FrozenWorld_Init() function initializes memory management and allocates some internal data structures in the Frozen World library. It must be called at least once at the start of the session before any of the other Frozen World functions are called. At the end of the session, FrozenWorld_Destroy() must be called once for every prior call to FrozenWorld_Init() to clean up. Both functions can be called multiple times, but must be called in pairs: The first invocation of FrozenWorld_Init() performs the actual initialization, and the corresponding (last) invocation of FrozenWorld_Destroy() performs the actual cleanup. All other invocations do nothing. This is useful if there are several user libraries that want to access the Frozen World library without requiring them to coordinate startup and teardown among themselves. These functions are internally synchronized. It is acceptable to call FrozenWorld_Destroy() from a different thread than FrozenWorld_Init() . Alignment (frame-to-frame) Initializing the spongy snapshot and aligning the frozen frame of reference 1. Initialize the spongy snapshot // Step 1 of 3: void FrozenWorld_Step_Init(); This clears the SPONGY snapshot. After you've called FrozenWorld_Step_Init() , just must fill the SPONGY snapshot manually with… The head's current position and orientation. All anchors you know the current transform (in relation to the head) of. The fragment association of anchors in the SPONGY snapshot is ignored (fragments are created during the alignment step automatically based on whether Frozen World can automatically deduce a spatial relationship between them), so you can use FrozenWorld_FragmentId_UNKNOWN for them. Edges between those anchors to signify which pairs of anchors are directly spatially related to each other. For example, two anchors next to each other in the same room should be connected by an edge; but two anchors separated by a wall shouldn't be. The current most significant anchor among those you've added to the SPONGY snapshot. This is the anchor whose relation to the head is presumably (or likely) most accurately represented in the SPONGY snapshot. This information is used in various ways, e.g. as a starting point when walking though the anchor graph to gather supports (see next step) or when placing scene objects (see Creating and tracking scene object attachment points below). See Accessing snapshots below (also for an introduction on the different kinds of snapshots). 2. Gather alignment supports from the spongy snapshot // Step 2 of 3: int FrozenWorld_Step_GatherSupports(); // -> number of gathered supports After this function has run, alignment supports can be inspected or tweaked (e.g. to extend or filter the set gathered by default, change the specific location used for alignment, change the relevance and tightness metrics used to weigh supports against each other, or just to visualize the gathered supports). This function uses the Frozen World alignment configuration to select which anchors from the SPONGY snapshot to gather for supports and how their relevance and tightness metrics are calculated. Calling this function is optional: You can just as well implement this step manually by creating a set of alignment supports yourself. See Configuring Frozen World alignment and Accessing alignment supports below. 3. Align the Frozen World to the alignment supports // Step 3 of 3: void FrozenWorld_Step_AlignSupports(); Alignment is based on the previously initialized SPONGY snapshot and the previously gathered supports. After this function has run, the FROZEN snapshot can be inspected to find the updated head (i.e. camera) transform (or the alignment transform of the most recently used spongy coordinate frame relative to the frozen coordinate frame) or to visualize frozen anchors and edges. In addition, after running this function all alignment metrics are also updated and can be queried to find out if a fragment merge or refreeze is indicated (based on configurable thresholds). See Accessing snapshots and Querying metrics below. Configuring Frozen World alignment Modify the Frozen World alignment configuration to tweak the results of FrozenWorld_Step_GatherSupports() , which affect alignment quality, to the requirements of the implemented scenario. There is a default Frozen World alignment configuration, so doing this is optional. struct FrozenWorld_AlignConfig { // Max edge deviation (0.0..1.0, default 0.05) to cut off // significantly deviating anchors from alignment float edgeDeviationThreshold; // Relevance gradient away from head float relevanceSaturationRadius; // 1.0 at this distance from head float relevanceDropoffRadius; // 0.0 at this distance (must be // greater than saturation radius) // Tightness gradient away from head float tightnessSaturationRadius; // 1.0 at this distance from head float tightnessDropoffRadius; // 0.0 at this distance (must be greater // than saturation radius) }; void FrozenWorld_GetAlignConfig( FrozenWorld_AlignConfig* configOut); void FrozenWorld_SetAlignConfig( FrozenWorld_AlignConfig* config); Accessing alignment supports Access alignment supports after the FrozenWorld_Step_Gather() function has run to extend, filter, change, or just inspect the alignment supports gathered from the SPONGY snapshot. Doing this is optional. struct FrozenWorld_Support { FrozenWorld_AttachmentPoint attachmentPoint; float relevance; // 1.0 (max) .. 0.0 (min, excluded) float tightness; // 1.0 (max) .. 0.0 (min, only lateral alignment) }; int FrozenWorld_GetNumSupports(); int FrozenWorld_GetSupports( int supportsBufferSize, FrozenWorld_Support* supportsOut); // -> number of elements copied to the buffer void FrozenWorld_SetSupports( int numSupports, FrozenWorld_Support* supports); Accessing snapshots Anchor and edge data is organized in different snapshots. Each snapshot contains (at least) any number of anchors along with their poses, fragment associations, and connecting edges. In addition, the SPONGY and FROZEN snapshots contain information about the current head pose and most significant anchor. The SPONGY snapshot must be populated (by you) frame-to-frame with input data to be used for alignment . The FROZEN snapshot is maintained and kept up to date as a matter of course during alignment and will also be updated when the results of a refit operation are applied. Use these enum constants to indicate which snapshot's information you want to access: enum FrozenWorld_Snapshot { FrozenWorld_Snapshot_SPONGY = 0, FrozenWorld_Snapshot_FROZEN = 1, }; It is safe to read and modify different snapshots concurrently from different threads. It is unsafe to access the same snapshot (read or modify) concurrently from different threads, including through the use of functions that are documented to require access to these snapshots (e.g. all alignment functions, which require access to the SPONGY and FROZEN snapshots). Accessing the head pose and alignment Get or set the head (i.e. camera) location and directions (only SPONGY and FROZEN snapshots): void FrozenWorld_GetHead( FrozenWorld_Snapshot snapshot, FrozenWorld_Vector* headPositionOut, FrozenWorld_Vector* headDirectionForwardOut, FrozenWorld_Vector* headDirectionUpOut); void FrozenWorld_SetHead( FrozenWorld_Snapshot snapshot, FrozenWorld_Vector* headPosition, FrozenWorld_Vector* headDirectionForward, FrozenWorld_Vector* headDirectionUp); Get or set the alignment transform, which maps coordinates in the Frozen World frame of reference into the most recently used spongy frame of reference: void FrozenWorld_GetAlignment( FrozenWorld_Transform* spongyFromFrozenTransformOut); void FrozenWorld_SetAlignment( FrozenWorld_Transform* spongyFromFrozenTransform); The alignment transform together with the most recent spongy head transform is wholly redundant with the frozen head transform. Use whichever is more convenient for you. Accessing the most significant anchor Get or set the most significant anchor, i.e. the anchor whose pose relative to the head is currently known best (only SPONGY and FROZEN snapshots): void FrozenWorld_GetMostSignificantAnchorId( FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId* anchorIdOut); void FrozenWorld_SetMostSignificantAnchorId( FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId); Get the fragment identifier (as defined by the FROZEN snapshot) of the current most significant anchor: void FrozenWorld_GetMostSignificantFragmentId( FrozenWorld_Snapshot snapshot, FrozenWorld_FragmentId* fragmentIdOut); If the queried snapshot's most significant anchor is FrozenWorld_AnchorId_INVALID , this function returns FrozenWorld_FragmentId_INVALID . If you query the fragment identifier of the most significant anchor in the SPONGY snapshot, this will still look up this anchor's fragment stored in the FROZEN snapshot (because fragment associations in the SPONGY snapshot are ignored). If the spongy most significant anchor doesn't exist in the FROZEN snapshot yet, querying its fragment identifier returns FrozenWorld_FragmentId_UNKNOWN . Accessing anchors struct FrozenWorld_Anchor { FrozenWorld_AnchorId anchorId; FrozenWorld_FragmentId fragmentId; FrozenWorld_Transform transform; }; Read all anchors in the snapshot: int FrozenWorld_GetNumAnchors( FrozenWorld_Snapshot snapshot); int FrozenWorld_GetAnchors( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int anchorsBufferSize, FrozenWorld_Anchor* anchorsOut); Add anchors to the snapshot or update an individual anchor's transform or fragment association (use with care!): void FrozenWorld_AddAnchors( FrozenWorld_Snapshot snapshot, int numAnchors, FrozenWorld_Anchor* anchors); bool FrozenWorld_SetAnchorTransform( // -> true if the anchor exists FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId, FrozenWorld_Transform* transform); bool FrozenWorld_SetAnchorFragment( // -> true if the anchor exists FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId, FrozenWorld_FragmentId fragmentId); Remove an individual anchor (and all edges attached to it), or all anchors (along with all edges) at once: bool FrozenWorld_RemoveAnchor( // -> true if the anchor existed before being removed FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId); void FrozenWorld_ClearAnchors( FrozenWorld_Snapshot snapshot); Accessing graph edges struct FrozenWorld_Edge { FrozenWorld_AnchorId anchorId1; FrozenWorld_AnchorId anchorId2; }; Read all edges between anchors in the snapshot: int FrozenWorld_GetNumEdges( FrozenWorld_Snapshot snapshot); int FrozenWorld_GetEdges( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int edgesBufferSize, FrozenWorld_Edge* edgesOut); Note that querying the number of edges is not a constant-time operation because edges are stored in a sparse array, so all edges must be enumerated in order to find out how many edges there are. If this is a performance concern, consider saving the number of edges from frame to frame and change your edge buffer size based on the number of edges stored indicated by the return value of FrozenWorld_GetEdges() . Add edges between anchors to the snapshot: void FrozenWorld_AddEdges( FrozenWorld_Snapshot snapshot, int numEdges, FrozenWorld_Edge* edges); Remove an individual edge, or all edges at once: bool FrozenWorld_RemoveEdge( // -> true if the edge existed before being removed FrozenWorld_Snapshot snapshot, FrozenWorld_AnchorId anchorId1, FrozenWorld_AnchorId anchorId2); void FrozenWorld_ClearEdges( FrozenWorld_Snapshot snapshot); Utility functions Merging anchors and edges int FrozenWorld_MergeAnchorsAndEdges( // -> number of anchors added to the target snapshot FrozenWorld_Snapshot sourceSnapshot, FrozenWorld_Snapshot targetSnapshot); Copies all anchors and edges that exist in sourceSnapshot but don't exist in targetSnapshot into targetSnapshot, effectively merging all anchors and edges from both snapshots into targetSnapshot. While doing that, this function adapts fragment associations and anchor poses of the source anchors that are copied over: If there is an overlap of anchors between a source and a target fragment, all non-overlapping anchors in that source fragment are added to the corresponding target fragment (i.e. have their fragmentId reassigned to match the target fragment) and have their poses adapted to become consistent with the poses of previously existing target anchors in the target fragment. If one source fragment overlaps several target fragments , the source fragment is split and all non-overlapping source anchors are added to the single target fragment that has the greatest overlap with the source fragment (in number of overlapping anchors). If a source fragment overlaps no target fragment at all, its anchors are copied into targetSnapshot into a new target fragment with a uniquely chosen fragmentId that doesn't exist yet in targetSnapshot. The poses of these anchors remain the same as in sourceSnapshot. You can use this function to bulk-integrate an entire SPONGY snapshot into the FROZEN snapshot instead of relying on auto-discovery of not-yet-seen support anchors during alignment. This is not usually needed, but it can be useful if you require a guarantee that all anchors you have in your SPONGY snapshot have meaningful corresponding FROZEN poses. Identifying missing edges that would guarantee full graph connectivity int FrozenWorld_GuessMissingEdges( // -> number of elements copied to the buffer FrozenWorld_Snapshot snapshot, int guessedEdgesBufferSize, FrozenWorld_Edge* guessedEdgesOut); Identifies edges that are missing in the given snapshot to guarantee that all anchors in every fragment are fully connected through edges. The 'guessing' aspect of this function that's suggested by the function name is that while an edge between two anchors should signify that there's traversable free space between these two anchors, this function (obviously) can't know that and therefore makes a guess based on the geometric proximity of anchors. The result of this is a graph that more or less represents the path a user might have taken while creating these anchors. This function attempts (on a best-effort basis) to avoid very short edges between anchors that are very close to each other. Since the 'edge deviation' metric used internally to identify fractures in the graph (which are caused by SPONGY anchor relations deviating too much from FROZEN anchor relations) is relative to edge length, a very short edge will exhibit a huge 'edge deviation' metric (and cause undesired fracturing or refreeze) if its two anchors change their relation even just a little bit. For this reason, this function will suggest a detour over a slightly more distant anchor to avoid a very short edge as long as full graph connectivity can still be guaranteed. If the return value of this function indicates that the entire guessedEdgesOut buffer was filled with data, there may be more missing edges than can be returned given the buffer size specified by guessedEdgesBufferSize . In this case, you can add the guessed edges to the snapshot using the FrozenWorld_AddEdges() function and call FrozenWorld_GuessMissingEdges() again to identify more missing edges. Inspecting metrics and indicators Query Frozen World alignment metrics to get a standardized high-level view on the current alignment quality. Metrics include indicator flags you can use to determine if a fragment merge is currently possible or if a refreeze is indicated (based on thresholds you configured in your Frozen World alignment and metric configuration settings). Visual deviation, which is caused by trade-offs made while aligning the Frozen World to the SPONGY snapshot, is measured by these metrics: Linear deviation is simply the distance between a support point in the most recent SPONGY snapshot and its aligned counterpart in the Frozen World. If alignment is perfect, linear deviation is zero. Lateral deviation shoots two imaginary rays, a 'spongy ray' and a 'frozen ray', from the head (i.e. camera) position to a support point in the most recent SPONGY snapshot and to its aligned counterpart in the Frozen World. The spongy ray is then intersected with the frozen support point's view plane (i.e. a plane that is orthogonal to the frozen ray and goes through the frozen support point). The lateral deviation metric is the distance between this intersection point of the spongy ray and the frozen support point. If alignment is perfect, lateral deviation is zero. Angular deviation is the angle (expressed in radians) between the spongy ray and the frozen ray described for lateral deviation above. If alignment is perfect, angular deviation is zero; the maximum possible angular deviation is pi (i.e. 180°). Angular deviation is capped to a configurable minimum distance between the head and the spongy and frozen support point, i.e. limited to the angle as if the head was moved to the center of a circle whose radius is the configured 'near distance' and that goes through the spongy and frozen support point. Other than being convenient, using these functions is optional: All metrics calculated by the built-in function could just as well be calculated in user code. Querying metrics struct FrozenWorld_Metrics { // Merge and refreeze indicators bool refitMergeIndicated; bool refitRefreezeIndicated; // configurable // Currently trackable fragments int numTrackableFragments; // Alignment supports int numVisualSupports; int numVisualSupportAnchors; int numIgnoredSupports; int numIgnoredSupportAnchors; // Visual deviation metrics float maxLinearDeviation; float maxLateralDeviation; float maxAngularDeviation; // configurable float maxLinearDeviationInFrustum; // configurable float maxLateralDeviationInFrustum; // configurable float maxAngularDeviationInFrustum; // configurable }; void FrozenWorld_GetMetrics( FrozenWorld_Metrics* metricsOut); Metrics are calculated for the support points in the SPONGY snapshot, so if you use FrozenWorld_Step_GatherSupports() instead of your own code to gather supports, metrics are affected by these alignment configuration settings (see Configuring Frozen World alignment above): The relevanceDropoffRadius setting controls the maximum distance of a support point from the head. The edgeDeviationThreshold setting may cause some supports to be ignored for visual alignment, which is a refreeze indicator in and of itself and also excludes the ignored supports from all visual deviation metrics. Some metrics are also affected by metrics configuration settings (see Configuring metrics below): The refitRefreezeIndicated flag is controlled by the refreeze… thresholds. The angular deviation metrics (maxAngularDeviation and …InFrustum) are limited by the angularDeviationNearDistance setting. The max…DeviationInFrustum metrics are controlled by the frustum… settings. Metrics apply to the most recent result of calling FrozenWorld_Step_Align() and are calculated lazily when FrozenWorld_GetMetrics() is called either for the first time during a step or after FrozenWorld_SetMetricsConfig() was called. Configuring metrics Modify the metrics configuration to tweak indicators and frustum-dependent metrics to the requirements of the implemented scenario. There is a default metrics configuration, so doing this is optional. struct FrozenWorld_MetricsConfig { // Angular deviation capped to this distance float angularDeviationNearDistance; // View frustum float frustumHorzAngle; float frustumVertAngle; // Thresholds for refreeze indicator float refreezeLinearDeviationThreshold; float refreezeLateralDeviationThreshold; float refreezeAngularDeviationThreshold; }; void FrozenWorld_GetMetricsConfig( FrozenWorld_MetricsConfig* configOut); void FrozenWorld_SetMetricsConfig( FrozenWorld_MetricsConfig* config); Understanding refit operations (fragment merge and refreeze) In general, you can simply work with locations, distances, and scene object transforms in your scene graph as in any big, rigid coordinate system. Allowing you to do this is at the core of what Frozen World wants to provide to you. However, as the device's tracking doesn't supply an absolute position in the real world, sometimes two parts of the coordinate system that were originally thought to be separate are discovered to be actually connected to each other, necessitating a fragment merge; or tracking errors accumulate to a degree that makes it necessary to rearrange things in the scene graph to improve alignment quality from there on out, necessitating a refreeze. These refit operations (i.e. fragment merge and refreeze) occur relatively rarely. Usually, they happen somewhat more frequently as long as the device is still exploring unknown spaces, and they become more infrequent (or even stop happening at all) as the device continues learning about its environment. (In fact, if your device has sufficiently learned about the environment you are using it in, you may never have to deal with refit operations at all.) Refit operations do not happen automatically: You must actively initiate them when they are indicated. This gives you the opportunity to postpone them until your scene is in a state that makes it easier for you to deal with the refit. You can even rate-limit refit operations yourself. A refit operation becomes indicated (see Inspecting metrics and indicators above) as deviations between the generally immutable Frozen World and the always-changing, always-evolving SPONGY snapshots supplied during alignment become too great. Whatever counts as 'too great' is a subjective and application-dependent quality trade-off you must make based on your particular scenario. (You can use the default configuration and indicators as a starting point.) As the last step of doing a refit operation, some or all of your scene objects must change their actual transform in the scene coordinate system so they stay visually aligned with the real world. Since you are yourself in control of initiating refit operations, there is no need for this 'scene refit' to be done in realtime on a per-frame budget: Your code can take however much time it needs to get it right. Creating and tracking scene object attachment points Unfortunately, as device tracking errors accumulate, the result can be that things are close to each other (or even overlap) in Frozen World coordinate space that are nowhere near each other in the real world. For that reason, Frozen World coordinates alone aren't sufficient to fullly describe which ways two nearby scene objects should move, respectively, as the result of a refit operation. Attachment points are small data structures (see Typedefs, structs, and constants used throughout this page above) that describe the logical attachment of something to a certain part of the Frozen World. In essence, an attachment point captures which anchor is that scene object's own 'most significant' one (like the most significant anchor supplied for the device itself in a SPONGY snapshot). In addition to the anchor identifier, an attachment point also contains a location in that anchor's own frame of reference. This location normally coincides with the scene object's location if the scene object is sufficiently close to its anchor, but this is not a general rule you should rely on. You should create and maintain an attachment point for every top-level scene object that can move independently. Attachment points aren't anchors . Even though they technically refer to one anchor in the frozen graph and encode a point in that anchor's coordinate system, they are not interpreted by Frozen World in a way that relates them to just that one anchor. Instead, an attachment point logically encodes 'a point in the graph between its anchors' for future reference when applying a refit operation, and to a significant degree any given attachment point could be referencing any of the anchors close to it without affecting its behavior at all. This seems not so different from attaching a scene object directly to an anchor (e.g. an individual SpatialAnchor or Unity WorldAnchor) without Frozen World. However, there are two significant differences: Firstly, Frozen World attachment points never change position on their own; and secondly, unlike anchors, attachment points can (and should) be purposely transitioned through the scene to tag along with the scene object they're attaching to the Frozen World. Attachment points are lightweight . Creating or using an attachment point leaves no footprint inside the Frozen World library. None of the library functions that accept FrozenWorld_AttachmentPoint parameters alter the state of the Frozen World in any way (though they do inspect it). There is no library-side overhead involved in creating or maintaining a great number of attachment points (aside from, obviously, the compute involved in calling library functions with them). Create an attachment point for a newly placed scene object void FrozenWorld_Tracking_CreateFromHead( FrozenWorld_Vector* frozenLocation, FrozenWorld_AttachmentPoint* attachmentPointOut); void FrozenWorld_Tracking_CreateFromSpawner( FrozenWorld_AttachmentPoint* spawnerAttachmentPoint, FrozenWorld_Vector* frozenLocation, FrozenWorld_AttachmentPoint* attachmentPointOut); Which one of these functions you should call to create an attachment point for a newly placed scene object depends on whether the newly placed scene object was, from the logic and intent of your particular scenario, spawned off some already-existing scene object (like a rocket launched from a rocket launcher, or an egg laid by a duck, or a child window slate detached from its parent window slate) or not. If you are placing a scene object without an initial relation to any existing scene objects, use FrozenWorld_Tracking_CreateFromHead() , which creates the initial attachment point for the scene object as if the device had spawned it. Otherwise, use FrozenWorld_Tracking_CreateFromSpawner() and pass the existing scene object's attachment point as the spawnerAttachmentPoint. Track an attachment point when its scene object moves When your scene object continuously moves through the scene (because it is animated or simulated; this does not apply to scene objects being relocated because of a refit operation!), you should move its attachment point along with it. void FrozenWorld_Tracking_Move( FrozenWorld_Vector* targetFrozenLocation, FrozenWorld_AttachmentPoint* attachmentPointInOut); It is not necessary to move a scene object's attachment point every frame during continuous movement: You can wait until it has moved into a distance of at least a half-unit away from where you updated its attachment point before until you need to move the attachment point along with it. However, if you do so, you should, after preparing a refreeze, make sure to do one final update of the attachment point just prior to invoking FrozenWorld_RefitRefreeze_CalcAdjustment() to ensure that the calculated adjustment is based on the scene object's latest position. Note that if you teleport a scene object through the scene (instead of continuously moving it through the scene), you should forget its prior attachment point data and initialize a new one from scratch based on the same considerations as for a newly placed scene object. Initiating and executing a fragment merge Fragment merge is due when there are multiple simultaneously trackable fragments represented in the SPONGY snapshot. (Built-in Frozen World metrics take only the support anchors used for alignment into consideration for the refitMergeIndicated flag.) 1. Initialize the fragment merge // Step 1 of 4: bool FrozenWorld_RefitMerge_Init(); The fragment merge operation is initialized with the current version of the SPONGY snapshot set up after FrozenWorld_Step_Init() . After the fragment merge has been initialized, it is safe to change the SPONGY and FROZEN snapshots without affecting the results of the fragment merge. FrozenWorld_RefitMerge_Init() returns true if the necessary preconditions for performing a fragment merge are given (i.e. there's more than one simultaneously trackable fragment represented in the SPONGY snapshot). If this is not the case, the function returns false, and the fragment merge operation is not initialized. Successfully initializing a fragment merge operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the fragment merge operation is not successful, the other refit operation (if any) remains unaffected. 2. Prepare the fragment merge // Step 2 of 4: // Can be executed in a background thread. void FrozenWorld_RefitMerge_Prepare(); Preparing the fragment merge is done based on information gathered by FrozenWorld_RefitMerge_Init() and is independent from ongoing changes to the state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration). Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute FrozenWorld_RefitMerge_Prepare() asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background. 3. Inspect fragment merge results and refit the scene When FrozenWorld_RefitMerge_Prepare() has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending fragment merge. The scene objects affected by this are identified by the anchorId (or more precisely: the fragmentId of that anchor) stored in the attachment point you created and maintained for that scene object (see Creating and tracking scene object attachment points above). struct FrozenWorld_RefitMerge_AdjustedFragment { FrozenWorld_FragmentId fragmentId; int numAdjustedAnchors; FrozenWorld_Transform adjustment; // post-merged from pre-merged }; // Step 3.1 of 4: int FrozenWorld_RefitMerge_GetNumAdjustedFragments(); // Step 3.2 of 4: // -> number of elements copied to the buffer int FrozenWorld_RefitMerge_GetAdjustedFragments( int adjustedFragmentsBufferSize, FrozenWorld_RefitMerge_Adjustment* adjustedFragmentsOut); // Step 3.3 of 4, for each adjusted fragment: // -> number of elements copied to the buffer int FrozenWorld_RefitMerge_GetAdjustedAnchorIds( FrozenWorld_FragmentId fragmentId, int adjustedAnchorIdsBufferSize, FrozenWorld_AnchorId* adjustedAnchorIdsOut); // Step 3.4 of 4: void FrozenWorld_RefitMerge_GetMergedFragmentId( FrozenWorld_FragmentId* mergedFragmentIdOut); All scene objects that are in the same Frozen World fragment (i.e. attached to anchors that have the same fragmentId) must have their transforms adjusted by a single common adjustment transform, so you can rely on scene objects in the same fragment keeping relative position and orientation to each other. Keep in mind that orientations may change, too, so don't forget to adjust any directional vectors (e.g. velocities and accelerations) as well. Note that the fragment itself that everything else is merged into is kept stationary. (Among all fragments that need to be merged, the one whose axis-aligned bounding box has the greatest volume in the Frozen World is chosen to remain stationary and be merged into.) Scene objects in the stationary fragment don't require adjustment, so this fragment isn't reported as an adjusted fragment. 4. Apply the fragment merge results to the Frozen World itself Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the fragment merge operation. // Step 4 of 4: void FrozenWorld_RefitMerge_Apply(); You can only call FrozenWorld_RefitMerge_Apply() only once for a fragment merge operation. After FrozenWorld_RefitMerge_Apply() has been called, the function calls required to refit your scene's objects (see 3. Inspect fragment merge results and refit the scene above) cannot be called any longer until the next fragment merge has been prepared. Initiating and executing a refreeze Refreeze is due when anchor relations in the SPONGY snapshot have become so different from their Frozen World counterparts that the visual trade-offs made to align the Frozen World to the SPONGY snapshot are too significant to simply ignore. There is no clear-cut, objective threshold for this: Whether a refreeze is advisable depends on the quality trade-offs you are willing to make in your particular scenario. (Built-in Frozen World metrics use configurable thresholds and take only support anchors into consideration for the refitRefreezeIndicated flag.) If a refreeze is executed when there are multiple simultaneously trackable fragments in the SPONGY snapshot, it will implicitly merge all anchors in those fragments into a single fragment during the refreeze. 1. Initialize the refreeze // Step 1 of 4: bool FrozenWorld_RefitRefreeze_Init(); The refreeze operation is initialized with the current version of the SPONGY snapshot set up after FrozenWorld_Step_Init() . After the refreeze has been initialized, it is safe to change the SPONGY and FROZEN snapshot without affecting the results of the refreeze. FrozenWorld_RefitRefreeze_Init() returns true if the necessary preconditions for performing a refreeze are given (i.e. there's more than one trackable anchor represented in the SPONGY snapshot within relevance distance from the head that's graph-connected to the current most significant anchor). If this is not the case, the function returns false, and the refreeze operation is not initialized. Initializing a refreeze operation while any other refit operation is running silently cancels the previous refit operation and discards its results. If initializing the refreeze operation is not successful, the other refit operation (if any) remains unaffected. 2. Prepare the refreeze // Step 2 of 4: // Can be executed in a background thread. void FrozenWorld_RefitRefreeze_Prepare(); Preparing the refreeze is done based on information gathered by FrozenWorld_RefitRefreeze_Init() and is independent from changes to the ongoing state of the SPONGY snapshot or the overall Frozen World (including the FROZEN snapshot and Frozen World configuration). Normally, this step executes quickly, but if guaranteed realtime performance is a concern, it is safe to execute FrozenWorld_RefitRefreeze_Prepare() asynchronously in a background worker thread even across several frames while the SPONGY snapshot continues to evolve and the Frozen World alignment continues to be done. However, you must take care to not initialize another refit operation while this one is being prepared in the background. 3. Inspect refreeze results and refit the scene When FrozenWorld_RefitRefreeze_Prepare() has finished executing, you must change the transforms of some or all of your scene objects to accommodate the pending refreeze. The scene objects affected by this are identified by the anchorId stored in the attachment point you created and maintained for that scene object (see Creating and tracking scene object attachment points above). // Step 3.1 of 4: int FrozenWorld_RefitRefreeze_GetNumAdjustedAnchors(); int FrozenWorld_RefitRefreeze_GetNumAdjustedFragments(); // Step 3.2 of 4: // -> number of elements copied to the buffer int FrozenWorld_RefitRefreeze_GetAdjustedFragmentIds( int adjustedFragmentIdsBufferSize, FrozenWorld_FragmentId* adjustedFragmentIdsOut); // -> number of elements copied to the buffer int FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds( int adjustedAnchorIdsBufferSize, FrozenWorld_AnchorId* adjustedAnchorIdsOut); // Step 3.3 of 4, for each attached scene object: // -> true if actually adjusted bool FrozenWorld_RefitRefreeze_CalcAdjustment( FrozenWorld_AttachmentPoint* attachmentPointInOut, FrozenWorld_Transform* objectAdjustmentOut); // post-refrozen from pre-refrozen // Step 3.4 of 4: void FrozenWorld_RefitRefreeze_GetMergedFragmentId( FrozenWorld_FragmentId* mergedFragmentIdOut); All scene objects that are attached to one of the anchors reported by FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds() must have their transforms adjusted by the attachment-point-specific adjustment transform supplied by FrozenWorld_RefitRefreeze_CalcAdjustment() . The scene object's attachment point itself must also adjusted, which happens automatically to the attachment point passed to this function. It's possible for an anchor (or fragment) to be reported by FrozenWorld_RefitRefreeze_GetAdjustedAnchorIds() or …_GetAdjustedFragmentIds() but for FrozenWorld_RefitRefreeze_CalcAdjustment() still to return false when it is called with an attachment point attached to that anchor. This can happen when the more in-depth calculations performed by FrozenWorld_RefitRefreeze_CalcAdjustment() come to the conclusion that, despite this anchor being within the refrozen area, it doesn't actually require any adjustment. In this case you're free to simply skip any follow-on processing you might otherwise want to do on your side after an adjustment. 4. Apply the refreeze results to the Frozen World itself Finally, after you have taken care of adjusting your own scene objects, corresponding adjustments must be applied to the Frozen World itself to finalize the refreeze operation. // Step 4 of 4: void FrozenWorld_RefitRefreeze_Apply(); You can only call FrozenWorld_RefitRefreeze_Apply() only once for a refreeze operation. After FrozenWorld_RefitRefreeze_Apply() has been called, the function calls required to refit your scene's objects (see 3. Inspect refreeze results and refit the scene above) cannot be called any longer until the next refreeze has been prepared. Persistence The Frozen World library's persistence support is mainly there for your convenience – there's no inaccessible essential internal state in the library and the binary recording/persistence format is simple and well-documented (see Frozen World binary recording format for details). Instead of using the functions described in this section, you can also implement your own writing and reading facilities for Frozen World without any loss of fidelity. The functions described here just give you a simple, portable way to do the same with less effort, and they give you the no-effort guarantee that they will always be up to date with the latest version of both Frozen World itself (which might perhaps change or extend its data representation in a future update) and the Frozen World binary recording format (which might perhaps be extended to represent some data more efficiently in a future update). The canonical Frozen World binary format is organized as a series (or: stream) of records and can be used for… Persistence – i.e. saving essential Frozen World data with the intention of restoring its state later to continue a session. Diagnostics – i.e. saving all Frozen World data, including transient data like the SPONGY snapshot, with the intention of using it later to investigate why Frozen World behaved in a certain way in a certain situation (e.g. to debug your scene, or Frozen World's integration into your scene, or Frozen World itself) or to implement automated offline testing based on real recordings and interactions. Each stream of records is self-contained, i.e. can be usefully stored, transmitted, and read on its own. However, the records in a given stream are not necessarily all self-contained: The recording format includes the possibility of encoding some data as updates relative to the previous record in the same stream in order to save space, so you need all records from the very start of that stream to guarantee that you can fully restore the recorded Frozen World state up to that point. For any given stream you create using these functions, you can select what data is going to be saved to or restored from it: The includePersistent flag controls inclusion of the most essential Frozen World data required to fully restore a session. This includes all data that can be accessed through the following functions: FrozenWorld_GetAnchors(FROZEN, …) FrozenWorld_GetEdges(FROZEN, …) The includeTransient flag controls inclusion of all other Frozen World state required to diagnose or replay a session. This includes all data that can be accessed through the following functions: FrozenWorld_GetAlignConfig() FrozenWorld_GetHead(SPONGY, …) and (FROZEN, …) FrozenWorld_GetAlignment() FrozenWorld_GetMostSignificantAnchor(SPONGY, …) and (FROZEN, …) FrozenWorld_GetAnchors(SPONGY, …) FrozenWorld_GetEdges(SPONGY, …) FrozenWorld_GetSupports() Note that you should enable both flags to get useful diagnostic recordings. Enabling just the includeTransient flag by itself only really makes sense if your only intention is to replay SPONGY snapshot data for offline scene testing. Serializing (saving) Frozen World state struct FrozenWorld_Serialize_Stream { // Internal handle to this serialization stream int handle; // Number of bytes that at least remain to be serialized for a complete record int numBytesBuffered; // Real time in seconds serialized into this stream so far // (can be modified to control relative timestamps serialized into the stream) float time; // Selection of data to include in the stream // (can be modified to control what is serialized into the stream) bool includePersistent; // frozen anchors and edges bool includeTransient; // alignment config, all other snapshot data, supports }; Frozen World recordings are an unbounded sequence of records. Each record encodes a single update's worth of Frozen World data including a relative time stamp that indicates how much real time passed since the last record in the stream was created. The granularity of updates is entirely up to you: For recordings intended for persistence, you might write just a single record and then close the stream again – or keep a stream open and infrequently (e.g. once every few seconds) append regular updates as a good trade-off between storage space consumption and the timeliness and completeness of the saved data in case your scene quits unexpectedly (e.g. because it crashed). For recordings intended for diagnostics and replay, keep the stream open and frequently (i.e. once every step, just after doing Frozen World alignment) append updates to your recording file. The recording format is designed to be space-efficient and doesn't write a lot of data if nothing much changed since the last record. 1. Opening the stream // Step 1 of 3: void FrozenWorld_Serialize_Open( FrozenWorld_Serialize_Stream* streamInOut); Allocate one instance of the FrozenWorld_Serialize_Stream data structure per stream you want to keep open at the same time. The stream's time property passed to FrozenWorld_Serialize_Open() defines the absolute starting time of the stream, which is used later to calculate the relative time encoded in the first record when FrozenWorld_Serialize_Gather() is called for the first time for this stream. It's best to set the stream's initial time property to your scene's current absolute runtime when you call FrozenWorld_Serialize_Open() . 2. Preparing a data record and getting its binary data to save After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like, even across an entire session: // Step 2.1 of 3: void FrozenWorld_Serialize_Gather( FrozenWorld_Serialize_Stream* streamInOut); // Step 2.2 of 3, repeated until no more data is available: // Can be executed in a background thread. int FrozenWorld_Serialize_Read( // -> number of bytes copied to the buffer FrozenWorld_Serialize_Stream* streamInOut, int bytesBufferSize, char* bytesOut); Calling FrozenWorld_Serialize_Gather() quickly gathers all information needed for a full record. The stream's time property when FrozenWorld_Serialize_Gather() is called directly controls what relative time (since last record) is encoded in the new record – it's best to keep the stream's time property always set to your scene's absolute runtime. After gathering data, repeatedly call FrozenWorld_Serialize_Read() to copy the serialized binary data of the record into a buffer provided by you, which you can then in turn output/write to wherever you want the recording stream to be physically stored (e.g. a file on disk or a network stream). While you're reading data you can check the stream's numBytesBuffered property to get an indication of how much more data there is at least left to be serialized for this record, which may be useful if you want to e.g. implement rotating size-limited recording files on your side. Reading serialized binary data by calling FrozenWorld_Serialize_Read() can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies that are hard to completely avoid when writing data to disk or over network. You mustn't call FrozenWorld_Serialize_Gather() again before all data from the previous record has been read (it will signal an error if you do), but it is safe to simply skip a call to FrozenWorld_Serialize_Gather() if writing the previous record's data is still in progress in your background thread. This won't cause your saved recording to become inconsistent or lose data – it will only reduce the granularity of the recording in that instance. 3. Closing the stream to release internal resources // Step 3 of 3: void FrozenWorld_Serialize_Close( FrozenWorld_Serialize_Stream* streamInOut); Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when FrozenWorld_Destroy() is called. FrozenWorld_Serialize_Close() will signal an error if the previous record wasn't fully read because that means you have received (and may have output/written) incomplete data that can't be fully deserialized later. You can set the stream's numBytesBuffered property to zero prior to calling FrozenWorld_Serialize_Close() to suppress this error. After calling FrozenWorld_Serialize_Close() , the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the FrozenWorld_Serialize_Stream data structure to open a new stream later. Deserializing (loading and restoring) Frozen World state struct FrozenWorld_Deserialize_Stream { // Internal handle to this deserialization stream int handle; // Number of bytes that at least remain to be deserialized for a complete record int numBytesRequired; // Real time in seconds deserialized from this stream so far // (can be modified to change its base value for subsequent deserialized records) float time; // Selection of data applied from the stream // (can be modified to control what is deserialized from the stream) bool includePersistent; // frozen anchors and edges bool includeTransient; // alignment config, all other snapshot data, supports }; When reading a Frozen World recording, you must read and apply all updates beginning at the start of the stream. However, there is no requirement to do this in real time, and you can read and apply even large streams (in the order of hundreds of megabytes and tens of thousands of records) fairly quickly from start to end in order to arrive at a certain recorded point in time. You can choose to read just a subset of the data contained in the stream by setting the stream's includePersistent and includeTransient flags. Of course, enabling includePersistent won't do anything if the stream doesn't contain such data (i.e. wasn't created with the includePersistent flag set during serialization), and the same goes for includeTransient . 1. Opening the stream // Step 1 of 3: void FrozenWorld_Deserialize_Open( FrozenWorld_Deserialize_Stream* streamInOut); Allocate one instance of the FrozenWorld_Deserialize_Stream structure per stream you want to keep open at the same time. The stream's time property is ignored by FrozenWorld_Deserialize_Open() , but it's later updated by FrozenWorld_Deserialize_Apply() by successively aggregating the relative time stamps included in the records that are read. You can change the time property at any time. It's best to set the stream's initial time property either to zero (in order to track this stream's progress in time) or to your scene's current absolute runtime (in order to track the stream's progress in terms of your scene's absolute runtime). 2. Loading binary data into the stream and applying the results After opening the stream (which allocates and prepares some resources in the library) you can then repeat the following steps as often as you like and as long as you have data to feed into the stream: // Step 2a of 3, repeatedly until no more data is consumed: // Can be executed in a background thread. int FrozenWorld_Deserialize_Write( // -> number of bytes consumed from the buffer FrozenWorld_Deserialize_Stream* streamInOut, int numBytes, char* bytes); // Step 2b of 3: void FrozenWorld_Deserialize_Apply( FrozenWorld_Deserialize_Stream* streamInOut); Repeatedly call FrozenWorld_Deserialize_Write() with more data read from your data source (e.g. a file on disk or a network stream you've opened) until it returns zero, indicating that the record is complete and no more data needs to be consumed for this record. While you're doing this, you can check the stream's numBytesRequired to get an indication of how much more data must be read at least for this record, which is useful if you want to make sure you read no more than the exact required amount of data from your data source. Feeding serialized binary data by calling FrozenWorld_Deserialize_Write() can be safely done in a background thread. Doing this can be very useful because it decouples your main thread that runs your scene from unpredictable I/O latencies (or blocking I/O calls while a network stream is waiting for more data to arrive) that are hard to avoid when reading data from disk or from a network. Even if input data is invalid, FrozenWorld_Deserialize_Write() will never report this as an error (as it's near-impossible to recognize binary recording data as malformed until it is parsed in detail and applied to Frozen World state). However, sufficiently malformed input may mislead FrozenWorld_Deserialize_Write() into requesting and consuming (if not necessarily buffering or meaningfully processing) any amount of input data while waiting for a valid record footer to appear in the data stream. If you're out of data to feed into FrozenWorld_Deserialize_Write() and it's still requesting more data, that in and of itself indicates that something may be wrong with the data you've fed it so far. After feeding a record's worth of data to FrozenWorld_Deserialize_Write() , call FrozenWorld_Deserialize_Apply() to apply the information contained in the record to Frozen World's state. Any invalid data previously fed to FrozenWorld_Deserialize_Write() will be reported as an error by Frozenworld_Deserialize_Apply() . You mustn't call FrozenWorld_Deserialize_Apply() until and unless a full record's worth of data has been fed into the library (it will signal an error if you do). This includes calling FrozenWorld_Deserialize_Apply() more than once without feeding more data in between the two calls. This behavior cannot be suppressed, so it is impossible to apply truncated records. You can change the includePersistent and includeTransient flags in between calls to FrozenWorld_Deserialize_Apply() . However, after the first call to FrozenWorld_Deserialize_Apply() for a given stream, you can only switch those flags off – you cannot start out with one or both of the flags disabled and switch them on mid-stream. The reason for this is that individual records might only encode an update instead of being fully self-contained, so skipping some records in the middle of the stream may leave the affected Frozen World data structures in an incomplete state. 3. Closing the stream to release internal resources // Step 3 of 3: void FrozenWorld_Deserialize_Close( FrozenWorld_Deserialize_Stream* streamInOut); Close the stream after you're finished using it to release some memory used internally in the library to keep track of it. All open streams are implicitly closed when FrozenWorld_Destroy() is called. After calling FrozenWorld_Deserialize_Close() , the stream's internal handle is deallocated (and set to zero) and cannot be used anymore. You can, however, reuse the FrozenWorld_Deserialize_Stream data structure to open a new stream later. Frozen World configuration and snapshots (both spongy and frozen) can be recorded in a platform-independent, compact, binary, streaming format to help with debugging and diagnostics and to create (or record) test scenarios. Frozen World binary recording format General structure A recording stream is an unbounded sequence of records. Each record is a sequence of tagged chunks. Each chunk is a sequence of fields. Field types Symbol Storage Description uint16 2 bytes, little-endian Unsigned 16-bit integer uint32 4 bytes, little-endian Unsigned 32-bit integer uint64 8 bytes, little-endian Unsigned 64-bit integer float 4 bytes, little-endian IEEE single-precision floating point type [N] N times the size of type Sequence of N instances of type Field padding and alignment No padding is inserted between fields. Fields therefore have no particular guaranteed alignment (with respect to the start of the stream). General record structure Each record starts with a record header chunk, followed by any number of data chunks (including potentially no data chunks at all), and completed with a record footer chunk. The required presence of a record footer is designed to allow readers to read a recording data stream without having to look ahead into the next record's data. While records may contain any number of chunks, each chunk tag (see General chunk structure below) can appear at most once per record. Readers are not required to support records that contain several instances (or several versions) of the same kind of chunk. General chunk structure Each chunk has the following structure: Type Content Additional information uint16 tag Defines the kind of the chunk. uint16 version Defines the specific format of the chunk payload (together with the tag). Version numbers start with 1. Version number 0 is reserved and not used. uint32 payload size Number of chunk payload bytes (not including the general chunk header bytes). (…) (…) Chunk payload. The presence of the payload size in the chunk header is designed to allow readers to load entire chunks without having to parse them to find the end of the chunk or to skip chunks they cannot read. Record header and footer chunks Record header chunk Type Content Additional information uint16 tag 0x0000 uint16 version 1 uint32 payload size 4 float relative time since last record Number of (usually fractional) seconds that have passed since the last record in the stream. The value in the first record of the stream is ignored by readers. Record footer chunk Type Content Additional information uint16 tag 0xFFFF uint16 version 1 uint32 payload size 0 Data chunks Alignment configuration chunk Type Content Additional information uint16 tag 0x0101 uint16 version 1 uint32 payload size 20 float edge deviation threshold > 0.0 float relevance saturation radius > 0.0 float relevance drop-off radius Greater than relevance saturation radius. float tightness saturation radius > 0.0 float tightness drop-off radius Greater than tightness saturation radius. Alignment supports chunk Type Content Additional information uint16 tag 0x0401 uint16 version 1 uint32 payload size 4 + 28 * number of supports uint32 number of supports […] Support definitions One definition per support, in no particular order. Support definition Type Content Additional information uint64 support anchor identifier float[3] support position from anchor X, Y, Z (meters) float support relevance 0.0 … 1.0 float support tightness 0.0 … 1.0 Spongy snapshot chunks Spongy snapshots are stored as multiple chunks: the spongy snapshot header and, if required, the spongy graph. The spongy snapshot header chunk can appear before or after the spongy graph chunk in the record, and there may be other chunks in between the header and the graph chunks. In order to improve the stream's compactness (and potentially reader performance), the spongy graph can be stored in several alternative ways, individually chosen for each record: as a complete graph definition (that replaces the last known spongy graph), as a graph update (applied to the last known state of the spongy graph read from this stream), or not at all (to indicate that the spongy graph is unchanged from its last known state read from this stream). Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to). Spongy snapshot header chunk Type Content Additional information uint16 tag 0x0201 uint16 version 1 uint32 payload size 36 float[3] head position X,Y,Z (meters) float[4] head orientation X,Y,Z,W (quaternion) uint64 most significant anchor identifier Spongy graph chunk See Graph chunk alternatives below for version, payload size, and payload. Type Content Additional information uint16 tag 0x0202 – Complete graph definition 0x0203 – Graph update uint16 version uint32 payload size (…) (…) Frozen snapshot chunks Frozen snapshots are stored as multiple chunks: the frozen snapshot header and, if required, the frozen graph. The frozen snapshot header chunk can appear before or after the frozen graph chunk in the record, and there may be other chunks in between the header and the graph chunks. In order to improve the stream's compactness (and potentially reader performance), the frozen graph can be stored in several alternative ways, individually chosen for each record: as a complete graph definition (that replaces the last known frozen graph), as a graph update (applied to the last known state of the frozen graph read from this stream), or not at all (to indicate that the frozen graph is unchanged from its last known state read from this stream). Readers assume that the spongy graph is initially empty when a recording stream starts. The first spongy snapshot stored in a recording stream usually includes a complete graph definition (but is not required to). Frozen snapshot header chunk Type Content Additional information uint16 tag 0x0301 uint16 version 1 uint32 payload size 64 float[3] alignment translation X,Y,Z (meters) float[4] alignment rotation X,Y,Z,W (quaternion) float[3] head position X,Y,Z (meters) float[4] head orientation X,Y,Z,W (quaternion) uint64 most significant anchor identifier Frozen graph chunk See Graph chunk alternatives below for version, payload size, and payload. Type Content Additional information uint16 tag 0x0302 – Complete graph definition 0x0303 – Graph update uint16 version uint32 payload size (…) (…) Graph chunk alternatives Writers should choose the most compact representation for a given graph. If the graph is unchanged compared to its last version written to this stream, no graph chunk should be written at all. Readers are required to support any graph chunk representation at any time. Complete graph definition Type Content Additional information uint16 tag See specific uses above uint16 version 1 uint32 payload size 8 + 44 * number of anchors + 20 * number of edges uint32 number of anchors uint32 number of edges […] Anchor definitions One definition per anchor, in no particular order. Each anchor identifier can appear only once in this chunk. […] Edge definitions One definition per edge, in no particular order. Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk. Graph update Type Content Additional information uint16 tag See specific uses above. uint16 version 1 uint32 payload size 8 + 44 * number of added or changed anchors + 20 * number of added or changed edges + 8 * number of removed anchors + 16 * number of removed edges uint32 number of added or changed anchors uint32 number of added or changed edges uint32 number of removed anchors uint32 number of removed edges […] Added or changed anchor definitions One definition per added or changed anchor, in no particular order. […] Added or changed edge definitions One definition per added or changed edge, in no particular order. […] Removed anchor identifiers One identifier per removed anchor, in no particular order. Each anchor identifier can appear only once in this chunk. […] Removed edge anchor identifiers One definition per removed edge, in no particular order. Each pair of edge anchor identifiers (1/2 or 2/1) can appear only once in this chunk. Anchor definition Type Content Additional information uint64 anchor identifier uint64 anchor fragment identifier float[3] anchor position X,Y,Z (meters) float[4] anchor orientation X,Y,Z,W (quaternion) Edge definition Type Content Additional information uint64 edge anchor identifier 1 Edge anchor identifiers are stored in slots 1/2 in no particular order. uint64 edge anchor identifier 2 float edge confidence 0.0 … 1.0 Anchor identifier definition Type Content Additional information uint64 anchor identifier Edge anchor identifier definition Type Content Additional information uint64 edge anchor identifier 1 Edge anchor identifiers are stored in slots 1/2 in no particular order. uint64 edge anchor identifier 2"
  },
  "DocGen/api_doc/Managers/IAlignmentManager.html": {
    "href": "DocGen/api_doc/Managers/IAlignmentManager.html",
    "title": "IAlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "IAlignmentManager The IAlignmentManager interface abstracts the service of translating and rotating the world-locked space to align with the physical world at a discrete set of Space Pins. The alignment concepts are described in detail in an article dedicated to Space Pins . Application interactions with the IAlignmentManager are not generally required. Rather, the helper component class Space Pin , and components derived from it, is provided to handle the minimal bookkeeping involved. Persistence considerations The IAlignmentManager provides a callback notification on post load. Any object registering for load notifications should un-register at the latest before its destruction. For Unity objects, that can be done in OnDestroy. In addition to explicit Save() and Load() member functions, the IAlignmentManager interface provides a persistence hook in the form of RestoreAlignmentAnchor . RestoreAlignmentAnchor searches its database for enough information to recreate the named Alignment Anchor, which has presumably been created and saved in an earlier session. If successful, an AnchorId valid for this session is returned, and the caller can claim ownership for the session. If for any reason the Alignment Anchor cannot be restored, an invalid AnchorId will be returned, and the caller should assume that the named anchor has not been created (nor saved) yet. The post load callback is useful for suggesting an appropriate time to check with the database whether a named Alignment Anchor is now available. See also IAlignmentManager SpacePin SpacePinManipulation SpacePinOrientable SpacePinOrientableManipulation PinManipulator"
  },
  "DocGen/api_doc/Managers/IAnchorManager.html": {
    "href": "DocGen/api_doc/Managers/IAnchorManager.html",
    "title": "IAnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "IAnchorManager The Frozen World engine relies on a network of spatial anchors surrounding the user, from which to calculate the ideal world locked space. The IAnchorManager maintains that network, and supplies it to the engine for processing each frame. The current implementation of IAnchorManager is in Assets/WorldLocking.Core/Scripts/AnchorManager.cs. AnchorManager is built on Unity's WorldAnchor spatial anchors. The Frozen World engine itself is agnostic to the type of anchors used. As the user moves around the environment, AnchorManager grows the graph of anchors according to the following simple but effective algorithm: If the nearest existing anchor is more than X meters from the user then: Add a new anchor. Add edges from the new anchor to all existing anchors less than Y meters from the new anchor. The values of 'X' and 'Y' above are constants in the AnchorManager, as MinAnchorDistance and MaxAnchorDistance respectively. These could be converted to properties, giving more flexibility at the cost of complexity in the WorldLockingContext API surface. However, the current values of 1 meter and 1.2 meters, respectively, have been satisfactory to date. The above algorithm grows the graph of anchors in the space traversed by the user during the initial exploration, eventually settling into a static network. The anchor manager may also persist the anchor graph across multiple sessions. AnchorManager has options to automatically save its anchor graph during the session, load the previously saved graph at startup, or save and load on demand. See also WorldLockingManager IFragmentManager IAttachmentPointManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/api_doc/Managers/IAttachmentPointManager.html": {
    "href": "DocGen/api_doc/Managers/IAttachmentPointManager.html",
    "title": "IAttachmentPointManager | World Locking Tools for Unity Documentation",
    "keywords": "IAttachmentPointManager The IAttachmentPointManager is the most common World Locking Tools interface for a client application to access. But the attachment point interface is extremely small. It gives opportunity for the client application to perform the four operations available on attachment points. Create Release Move Teleport CreateAttachmentPoint The interesting thing to note here is the delegates passed in as arguments to the create function. Either or both of these arguments may be null, in which case the created attachment point will not receive any notifications corresponding to that delegate. These delegates may not be changed after creation. This should not be a burden, as the delegate itself may fork behavior based on current state. If even that is not possible, then the attachment point must be released and a new attachment point with the desired new delegates created. ReleaseAttachmentPoint When the attachment point is no longer needed, the client application should notify the system via the release API. MoveAttachmentPoint Unlike most spatial anchors, and Unity's WorldAnchor's in particular, attachment points may move freely through the world, automatically binding to the most relevant anchors at their new positions. As an attachment point moves, its owner should notify the system of its new position. This movement might be from physics simulation, or any other animation technique. TeleportAttachmentPoint Confusingly, teleporting is more closely related to creation than movement. Rather than thinking of teleport as moving to a new location, it is helpful to think of it as ceasing to exist, then beginning existence again in a (possibly) new location. The rule of thumb is, if the object moved continuously from old location to new location, use MoveAttachmentPoint. If it popped into existence in the new location, use TeleportAttachmentPoint. Contexts for creation and teleporting Creation and the conceptually similar teleport take an optional (may be null) parameter of a creation context. The context is an already existing attachment point that gives the system several hints about where in the anchor graph (which may not be fully connected in the case of multiple fragments) to find the best anchor to base this attachment point on. The current implementation of IAttachmentPointManager is in Assets/WorldLocking.Core/Scripts/FragmentManager.cs, which also implements the IFragmentManager interface. Move and teleport via manager or attachment point APIs It may be noticed that, in addition to the move and teleport interfaces described here, there are corresponding methods on the IAttachmentPoint interface. These are equivalent, and whichever is more convenient to the caller may be used. See also WorldLockingManager IFragmentManager IAnchorManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/api_doc/Managers/IFragmentManager.html": {
    "href": "DocGen/api_doc/Managers/IFragmentManager.html",
    "title": "IFragmentManager | World Locking Tools for Unity Documentation",
    "keywords": "IFragmentManager The fragment manager maintains the mapping of which attachment points are associated with which fragments. While the concept of fragments is important in understanding the World Locking Tools, fragments themselves are generally not interesting outside of the World Locking library. A client application might want to know whether the fragment an object belongs to is currently being tracked, but that information is supplied directly to the attachment point through its AdjustStateDelegate. Likewise, a fragment merge operation will affect the position of an attachment point, but the attachment point will be notified directly of the location modification irrespective of the containing fragment. The fragment manager handles the book-keeping of which fragment an attachment point is created into, and which fragment it might move into because of refit operations. It also implements the refit operation notifications. However, all these operations are behind the scenes. The client application will generally not interact directly with the IFragmentManager. The current implementation of IFragmentManager is in Assets/WorldLocking.Core/Scripts/FragmentManager.cs, which also implements the IAttachmentPointManager interface. See also WorldLockingManager IAnchorManager IAttachmentPointManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager"
  },
  "DocGen/api_doc/Managers/WorldLockingManager.html": {
    "href": "DocGen/api_doc/Managers/WorldLockingManager.html",
    "title": "WorldLockingManager | World Locking Tools for Unity Documentation",
    "keywords": "WorldLockingManager The World Locking Tools for Unity is managed by the WorldLockingManager . There is only one WorldLockingManager in an application. The manager may be configured by setting of properties in the Unity editor's inspector, or at runtime. See WorldLockingContext . In addition to managing user options, the WorldLockingManager provides access to three interfaces: IAnchorManager - Build and maintain the network of spatial anchors used as input to the Frozen World engine, feeding them into the engine every frame. IFragmentManager - Maintain grouping of attachment points into fragments, effecting refit operations. IAttachmentPointManager - Creating, releasing, and moving attachment points. IAlignmentManager - Specifying alignment of World Locked Space with physical space. These are described in detail in subsequent sections. See also IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager And in API reference: WorldLockingManager IAnchorManager IFragmentManager IAttachmentPointManager IAlignmentManager"
  },
  "DocGen/Documentation/Concepts.html": {
    "href": "DocGen/Documentation/Concepts.html",
    "title": "World Locking Tools Concepts | World Locking Tools for Unity Documentation",
    "keywords": "World Locking Tools Concepts The problem In the day to day physical world, space is well described by a stationary coordinate system. A motionless object in a stationary coordinate system will continue having the same coordinates forever. A group of objects laid out in a specific configuration will maintain that configuration. Two objects moving with identical velocities will remain at a fixed offset from each other. These and similar laws are such an basic part of existence that when they no longer hold, intuition about the world becomes unreliable. Previous solutions Unity's global coordinate space and spatial anchors each address different aspects of the problems caused by sensor inaccuracies and drift. Unity's global coordinate space provides a stable frame of reference, in which holographic objects remain fixed relative to one another. While objects in this space will behave consistently relative to each other, consistency with the physical world is not guaranteed nor generally provided. Especially when the user is moving around, inconsistencies will develop. Unity's spatial anchors can maintain a hologram's position in the physical world when the user is mobile, but at the sacrifice of self consistency within the virtual world. Different anchors are constantly moving relative to one another. They are also moving through the global coordinate space, making simple tasks like layout difficult, and physics simulation problematic. The source of the problem Discussion here will center around HoloLens technology, but these concepts apply generally to inside out markerless tracking techniques, especially as augmented by inertial systems. The HoloLens is amazing at determining where it is relative to visible features in the surroundings. By extension, it is also amazing at positioning other virtual objects by those same visible features. So when the user is sitting or standing in a roughly constant position, the device is great at keeping virtual objects registered with visible physical reference points. A virtual cup placed on a physical table, will mostly stay in the same spot on the surface of the table. That's when the HoloLens is confined to the same small volume, with a constant set of visible features in view for reference. But there are other interesting scenarios. When the user gets up and moves about the room, or possibly even between rooms, the HoloLens must switch between old features leaving view and new features coming into view. Without getting into implementation details, it's clear to see that while in transit, tracking accuracy is going to be very much degraded. Here's a simplistic scenario for context. Illustration The user is at point A. Looking around, there are a number of good visible reference features, so the head tracking quality is excellent, and any holograms placed will stay put. The user then walks 10 meters (real, in physical space) to point B. But on reaching point B, because of the lower fidelity tracking in transit, the device registers that it has traveled exactly 9 meters. This is a large even amount for illustration, but is consistent with the device specifications, that allow a +-10% distance error in such a case. Now looking around at point B, good visible features are recorded. Tracking and stability of holograms at point B is excellent too. When at point A, things around point A look great, and when around point B, things at point B look great. But there's an inconsistency. The 10 meters between points A and B in physical space are only 9 meters in virtual space. That's often referred to as \"the scale problem\", although \"the distance problem\" might be more accurate. Regardless, we'll get back to when that's a problem soon. But first, the user walks back to point A. This time the tracking errors make the 10 meters walk from B to A in physical space add up to 10.5 meters in virtual space. And that means that the full walk from A to B to A adds up to a net move of 1.5 meters, when it should obviously be 0.0 meters. This is an obvious problem. A hologram placed at point A before the walk will now appear 1.5 meters away from point A. This is where WorldAnchors can help. After walking to B and back, the system recognizes that it is back at point A, yet the head's Unity coordinates have changed by 1.5 meters. But if the hologram at point A has a WorldAnchor attached, the WorldAnchor can think \"I'm at point A, the head is at point A, but my coordinates differ from the head's by 1.5 meters. I'll just change my coordinates by 1.5 meters so that we're in agreement again.\" And a WorldAnchor at point C, a meter to the left of the user, is going through the same process. In essence, the WorldAnchor constantly redefines where point A is in Unity space so that the head's coordinates are always right. And each WorldAnchor does this independently for its place in the physical world. World Locking Tools for Unity World Locking Tools keeps a (not-very-)secret supply of WorldAnchors it spreads as the user moves around. It analyses the coordinates of the camera and those WorldAnchors every frame. It detects when all of those WorldAnchors are moving over 1.5 meters to match the coordinates of the head, and says \"Hmm, instead of changing the coordinates of everything in the world to compensate for the head having different coordinates than the last time it was here, I'll just fix the head's coordinates instead.\" That means that, rather than having to have a WorldAnchor drag a hologram through Unity space so that it will remain fixed in physical space, the entire Unity world space is locked to physical space. If a hologram is motionless in Unity space, it will remain motionless relative to the physical world features around it. And just as importantly, it will remain fixed relative to the virtual features around it. Obviously it's more complicated under the hood than that. For example, remember that a problem with the WorldAnchors is that they move independently, so don't always agree with each other. The underlying FrozenWorld engine arbitrates those disagreements to come up with the most perceptually correct camera correction, and does that every frame. The scale problem again If the user walks from point A to point B and back to point A, the system has enough information to fix the drift that occurred in transit. It may not know where point B is (and generally doesn't know exactly where any point B is relative to point A), but it knows whether it is at point A or not. When it gets back to point A, it expects things to be pretty much as it left them. If they aren't, it can make it so. But what about at point B? It thought the 10 meter walk was only 9 meters. And it has no way of knowing whether that 9 meters is correct, and if it isn't, how much it is off. WorldAnchors don't help here. WorldAnchors have the same problem the head tracker does, each knows where it is in the physical world (relative to visible features), but one WorldAnchor doesn't know anything about another WorldAnchor. Specifically, WorldAnchors don't know how far apart they are. This can be inconvenient in many forms, but it becomes a blocking issue when objects, or systems of objects, are larger in size than a meter or so. Consider a model of a room, or a building, or a set of desks, or even a car. While a WorldAnchor can keep one end of the model registered with a physical world feature, by the time the other end of the model is reached, significant error might have accumulated. The other end won't be lined up correctly. And the error will be different from device to device, and possibly even between runs on the same device. And so far in this discussion, the minimum information required to fix the problem has not been introduced. World Locking Tools addresses that problem with the Space Pins API, which allows the application to supply enough information relating the physical world and holographic world to correct for the errors in distance traveled. This allows large holograms to appear aligned with the physical world all over. Next These advanced mechanisms will be covered in later sections, but it is useful to first look in detail at World Locking Tools' baseline operation. Understanding what services the baseline operation does and doesn't supply will help in determining the proper use of advanced concepts later, and whether those advanced techniques are even required for a specific application. See also The basic system Advanced topics"
  },
  "DocGen/Documentation/Concepts/Advanced/AttachmentPoints.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/AttachmentPoints.html",
    "title": "Attachment points | World Locking Tools for Unity Documentation",
    "keywords": "Attachment points First and foremost, World Locking Tools provides a stable world-locked coordinate system, the world locked space. This space remains as fixed as possible relative to the physical world. And objects within world locked space enjoy capabilities requiring such a stable frame of reference, such as maintaining relative placement to other virtual objects, simulation of natural physics laws, kinematics, and other animation techniques. In fact, depending on the needs of the application, world locked space may be sufficient for some or all scene content. But while world locked space will remain optimally aligned with physical space, there are situations to be described later in which it is not possible for multiple points in world locked space to remain both fixed in their common coordinate space and fixed relative to reference points in the physical world. For a trivial but illuminating example, suppose that the sensor maps one anchor to the position (3,0,0) and another to the position (-3,0,0). Later, as sensor refinements are processed, it is established that the two coordinates should have been (3,0,0) and (-2,0,0). There is clearly no rotation and offset that can be applied to the camera which will transform a 6 meter distance between the two anchors into a 5 meter offset. Using Unity's WorldAnchor system, the two anchors would just silently move into their newly scanned positions. But World Locking Tools guarantees that in world locked space, non-moving objects will \"mostly\" never move. And in fact, any motion is up to the owning application. Attachment points are the codification of that contract between World Locking Tools and the application. An application creates and positions attachment points using World Locking Tools APIs. When a correction in the position of an attachment point is determined by a refit operation, the application is notified via callback of the new position in world locked space that will keep the attachment point at its old position in physical space. Some scenarios in which World Locking Tools attachment points might be the solution: It is more important to remain fixed relative to features in the physical world than relative to other virtual objects. Objects are placed in the world at runtime rather than in Unity at design time, and it may be important to reconcile relative positions separated by disruptions in tracking (see discussion of fragments ). It is important to manage an object's visibility based on the validity of its physical space positioning. Using attachment points Use of attachment points is fairly straightforward. Client responsibilities For each attachment point required, the client must: Request attachment points from the system. See CreateAttachmentPoint Dispose of attachment points that are no longer needed. See ReleaseAttachmentPoint Apprise the system of the attachment point's initial position and movement. See CreateAttachmentPoint , MoveAttachmentPoint , and TeleportAttachmentPoint Handle refit operation events. See below. World Locking Tools responsibilities World Locking Tools will notify the application, for each affected attachment point, when either of the following occurs: The validity of the attachment point's physical world tracking changes. Its coordinates in world locked space change due to a refit operation, which may be either a fragment merge or a refreeze . These notifications are broadcast through delegates which the application hands to the WorldLockingManager on creation of the attachment point. How to best handle these notifications is left to the application, as each will have its own considerations. Sample handlers, which are used internally and may be either used as is or used as a starting point for custom implementations, are provided. For an attachment point that is to remain fixed in the physical world, and which should hide its contents when its tracking is not valid, AdjusterFixed implements the AdjustStateDelegate with its HandleAdjustState member,and the AdjustLocationDelegate with its HandleAdjustLocation member. A similar component for moving objects is in AdjusterMoving . It is worth noting that supplying either or both these delegates is optional, and in fact reactions to state and location changes may be implemented based on polling rather than events. But unless their use is impossible due to specifics of the application, the event based system using delegates forms a much more efficient implementation. See also Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/Fragments.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Fragments.html",
    "title": "Fragments | World Locking Tools for Unity Documentation",
    "keywords": "Fragments As mentioned, in World Locking Tools terminology, a fragment is a collection of things which exist in known relation with each other in the same coordinate space. However, there is generally no meaningful spatial relationship between different fragments. A simple example might help clarify. Imagine two well lit rooms, connected by a long dark hallway. The head-tracked session begins in the first room. The room being well lit and with appropriate furnishings, the user quickly and easily scans and maps it. Objects in the room, as well as any anchors created, are all in known positions relative to the head and relative to each other. Since the second room hasn't even been visited yet, there is still no knowledge about its contents. Now the user proceeds into the dark hallway. There, tracking is lost immediately because of the poor lighting. The user passes through the hallway to the second room. In the second room, tracking is again restored and the user quickly scans the room, adding some anchors for good measure. At this time, both rooms have been scanned, and the contents of each room is known relative to the other contents of the same room, but there is no knowledge about one room relative to the other. The hallway could have been of any length, and it may have curved. These two rooms, then, are forming isolated islands of spatial relationship. The group of inter-related objects in each room are herein called \"fragments\". And in our hypothetical situation, our session now contains two fragments, one for each room. Because no tracking data was acquired in the hallway, there is no corresponding hallway fragment. All of the objects in both rooms have coordinates, but the two coordinate systems are unrelated. When the camera is in the second room, the head is placed in the same coordinate system as all the other objects in the second room. This allows those second room objects to be rendered appropriately relative to the user's perspective. However, the objects in the first room are in an unrelated coordinate system. Depending on the length of the unmapped hallway, they might be meters or tens of meters away, or off to the side if the hallway bends. Therefore, without further info connecting the two spaces, the system doesn't have enough information to meaningfully place the first room's objects in the users view. But the system does know it hasn't enough info to render those objects correctly, and through the attachment point mechanism can inform the application of that condition. See also Attachment points Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/Persistence.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/Persistence.html",
    "title": "Persistence | World Locking Tools for Unity Documentation",
    "keywords": "Persistence In general, the benefits of World Locking Tools' persistence capabilities are of more interest than the details of their implementation. This article will therefore begin with a discussion of the experiences that World Locking Tools persistence enables, and how World Locking Tools State persistence may be managed. It will then close with a brief sketch of what data is actually saved and loaded. World Locking Tools across sessions As defined elsewhere , the Frozen State is all data necessary to resume the current world-locked stable space. The primary utility of World Locking Tools' persistence is in allowing the benefits of a preliminary session's work, scanning an area and aligning virtual space to the real world, to be used in subsequent sessions. This allows subsequent sessions to forego tedious or time consuming setup and get straight to the focal experience. Saving World Locking Tools State Before it can be loaded, the Frozen State must be saved. The most straightforward way to save the Frozen State is to enable AutoSave on the World Locking Tools Manager, either in the Unity inspector on the World Locking Tools Context , or at runtime via script. Setting World Locking Tools Manager state via script is performed by first getting the state, changing it in any desired way, and then setting the state back as a block. For example, to toggle the AutoSave feature: var settings = WorldLockingManger.GetInstance().Settings; settings.AutoSave = !settings.AutoSave; WorldLockingManager.GetInstance().Settings = settings; If the AutoSave feature goes from enabled to disabled during a session, no further periodic saves will be attempted. If it goes from disabled to enabled, periodic saves will be begun or resumed. The AutoSave feature will keep an up-to-date saved state by periodically saving the current state asynchronously. If more control over the timing of the saving of state is required, then the AutoSave may be set to false, and manual saving done via script. The asynchronous save is easily triggered, as: WorldLockingManager.GetInstance().Save(); As the save is asynchronous, additional attempts to invoke a Save() while a previous is still under way will be ignored. Loading Frozen State Having saved off a Frozen State, it might be desired to reload World Locking Tools back into that state, either in a subsequent session or even later in the same session. As in saving Frozen State, there are two paths for loading state. If the AutoLoad flag on the World Locking Tools Manager is enabled, then any previous saved state will be loaded at startup time. If there is no saved state to load, no error is generated and startup proceeds as if the flag wasn't set. Note that setting the AutoLoad flag from false to true (e.g. via script) at runtime will have no effect. The AutoLoad either happens at initial load, or doesn't happen at all. However, a load may be initiated from script at any time through the World Locking Tools Manager's Load function: WorldLockingManager.GetInstance().Load(); As with the Save, the Load is performed asynchronously. Any subsequent calls to Load while one is still ongoing will be ignored. What is saved? The data required to reconstruct the World Locking Tools mapping, that is the alignment of the virtual world to the real world, can be broken into three groups. WorldAnchors - The underlying network of WorldAnchors created and maintained internally by World Locking Tools' Anchor Manager , supply the requisite binding to the real world. Those anchors are persisted via Unity's WorldAnchorStore. Engine State - Additional state is persisted in to allow the engine to resume its current mapping. This removes such indeterminacies as the initial pose of the head in the previous session(s). Space Pinning - If the application has applied any further Space Pins to force alignment of modeling coordinates to the real world at a discrete set of points, that additional mapping is also persisted. What is not saved? Note that only state is saved. In particular, settings are not saved. Any configuration changes by the application, for example changes made through the WorldLockingManager API, are reset each time the application starts up to their values as set in the Unity Inspector, or if they aren't set in the Inspector then to their default values in code. For example, say the application wants to present the user with the option to AutoSave World Locking state, and have the user's preference persist across sessions until changed. Then the application must: Present the user with UX for setting AutoSave preference (presumably with other application settings). Forward the user's preference to the WorldLockingManager Record the preference to file (presumably with other application settings). On application startup, load the saved preference (if any has been saved) and forward to WorldLockingManager. See notes in WorldLockingContext regarding timing issues when mixing state setting between assets and script. See also Space Pins Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/Advanced/RefitOperations.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/RefitOperations.html",
    "title": "Refit operations | World Locking Tools for Unity Documentation",
    "keywords": "Refit operations Refit operations in World Locking Tools are when the system determines that a repositioning of some of the objects in the scene would better register those objects with their physical world anchors. This section will attempt to give further insight into the situations leading up to refit operations, as well as the mechanics of the operations themselves. It is important to stress here that refit operations occur very infrequently. The default error tolerances triggering a refreeze operation are customizable by the application, but normally MR environments trigger refreeze operations only in extraordinary circumstances. Conditions that might contribute to the need for a refreeze include: Loss of tracking due to poor environment. Fast movement of the head influencing environment scanning. Dynamic environments. Loop closure (i.e. accumulating tracking errors on a roundabout path leading back to a preiously visited spot). As can be seen, the root cause of these is poor tracking, or tracking errors. With reasonable environments producing reasonably good tracking, and especially after an initial scan of the space, refit operations will become exceedingly rare. Fragment merge A number of conditions may lead to the existence of multiple fragments, the most common cause being temporary loss of tracking. Fragments are defined as collections of objects sharing a common coordinate space, but where the coordinate space of one fragment is indeterminately located relative to another fragment. When enough new sensor data is received and processed that the contents of two previously unrelated fragments may now be positioned correctly relative to each other in the same space, a fragment merge may be performed. The new coordinate space into which the contents of the two (or more) fragments will be merged is arbitrary. It is mentioned here that the final coordinate space will be that of one of the spaces, which is only relevant because it means that all of the fragments being merged except one, the destination fragment, will need their coordinates adjusted. The contents of the fragment chosen as the final target of the merge will be unaffected. An adjustment transform is computed by the system for each of the source fragments being merged. The AdjustLocationDelegate for each attachment point in those fragments will be called with the adjustment transform. Again, attachment points in the destination fragment will not be affected, nor have their AdjustLocationDelegates called. The two rooms connected by a dark hallway scenario in the description of fragments is an example of one such situation. During the initial phase, both fragments (rooms) have been scanned, but there is no information available regarding the relative positions of the two fragments. So the coordinate system the contents of each fragment is placed in is arbitrary, as long as it is constant across all objects in that room. For example, the contents of each room might be in a coordinate system with its origin at the southwest corner of that room. The coordinates of two objects in the same fragment indicate the positions of the two objects relative to each other, but the coordinates of two objects in two different fragments tells nothing about their relative positions. When more information is acquired, then there is an opportunity to adjust the coordinates of the contents of the second fragment so that the coordinates of its contents are meaningful relative to objects in the first fragment. For example, the hallway light might be turned on and the hallway traversed, bridging the gap between the two fragments. If the coordinates of all objects in both rooms are then adjusted to be in the same consistent coordinate space, there is no longer any real distinction between the two fragments, and so their contents may be considered to all belong to a single common fragment. This operation of collapsing multiple fragments into a single fragment is a merge operation . It's important to note here that for normal Unity objects placed in the scene in world locked space, the merge operation will have no effect. Movement of objects from refit operations only happens through attachment points. Refreeze operations Another situation that arises is when, as the positions of the anchors are refined over time, it becomes apparent that a rotation/offset transform is no longer adequate to compensate for the difference between the initial rough anchor positions and the more recent improved positions in the physical world. Keep in mind that the anchors themselves are constantly moving relative to each other in spongy space. But the attachment points derived from these anchors are fixed in world locked space. When the system recognizes that the attachment points it manages could be better registered with the physical world, because of updates to anchor positions, then it has another opportunity for a correction event. This adjustment of attachment point positions to reflect new sensor data is known as a refreeze operation . Whereas in a merge operation the contents of a fragment are all adjusted by a single transform to merge coordinate spaces of two fragments into a single unified space, a refreeze adjusts each attachment point individually based on the updated positions of the anchors influencing it. As in the merge operation, each attachment point is informed of its computed adjustment transform via its AdjustLocationDelegate. Note that if conditions are right, the refreeze might also perform a merge operation. That merge will be considered an implicit part of the refreeze: There will be no separate events generated for the merge, and the adjustment transform delivered as part of the refreeze will include both the individual adjustment due to anchor movement and the fragment adjust due to the merge. Reacting to refit events In either merge or refreeze, the reaction to refit events is up to the application. More precisely, it is up to each of the attachment point handlers, as different object types might react differently. Typically, the objects influenced by the attachment point will be moved by the adjustment transform via their GameObject.transform. Motion might instead be implemented by some other mechanism, such as manually moving vertices. It might even be advantageous for some applications to simply discard objects affected by a merge and begin a new cycle of creation. The point is that World Locking Tools has no dependence on how or whether the application reacts to refit operations. It is entirely up to the application developer's needs. See also Attachment points Fragments"
  },
  "DocGen/Documentation/Concepts/Advanced/SpacePins.html": {
    "href": "DocGen/Documentation/Concepts/Advanced/SpacePins.html",
    "title": "Space Pins | World Locking Tools for Unity Documentation",
    "keywords": "Space Pins The problems to solve The scale error While the traditional WorldAnchor approach to aligning Holograms with real world features works great on a small scale, it struggles as the scale grows to encompass more than a meter or so. Scale error in head tracking space means that even if a WorldAnchor keeps one end of a virtual object, sized only a few meters long, perfectly aligned with a real world feature, the other end is likely to be misaligned with a corresponding real world feature. This is because the distance traveled through head tracked space tends to differ from the distance traveled through physical space with an error bound of +-10%. The actual error is often less (it depends on a number of environment and device characteristics), but will generally be significant, and grow without bounds as the scale of the project grows. Put another way, if a user wearing a HoloLens walks ten meters in the real world, the distance travelled in virtual space, as reported by the head tracker, will be between 9 and 11 meters. If the user walks 50 meters, the error grows to +-5 meters. The farther the user walks, the greater the error grows. Thus, a 10 meter beam (in modeling space) with one end point perfectly aligned to the zero end of a tape measure in real space will have the other end registered to the tape measure at somewhere between 9 and 11 meters. For the same reasons, multiple objects, each world locked using WorldAnchors, will be different distances apart in virtual space than in real space. The arbitrary coordinate system There is an additional concern. The Unity coordinate system in HoloLens is indeterminate. It is based solely on the head pose at the start of the application. This is not an issue for many tasks. If the goal is to cast a ray into the spatial mapping of the room and place a Hologram at the hit position, then the numerical values of the hit position are irrelevant. Likewise, when popping up UX elements around the user, the absolute coordinates to place a UX element don't matter, only the coordinates relative to the user. However, more involved scenarios can be complicated by the unpredictable coordinate system. To load a large collection of objects, for example a user's desktop or an entire office room, into virtual space with a fixed relation to physical space, requires some compensating transform to align the modeling space objects with the head based coordinate frame. That compensation is often done by attaching all objects to a single Unity transform, and adjusting that single transform to position and orient the virtual objects in alignment with the real world. Equivalently, a single transform in the camera's hierarchy can be used to realign the camera so that when the user is seeing a real world reference point, a virtual object with the desired modeling coordinates will appear overlaid on that feature. The solution The Space Pinning feature addresses both of these issues at once. It does so by leveraging both the world-locked nature of the World Locking Tools global space, and the arbitrariness of that space. Aligning Unity space wth the real world World Locking Tools at its core provides a stable world locked coordinate system. This means that a virtual object placed into World Locked Space registered with a real world feature will remain registered with that real world feature over time. But there are an infinite number of spaces that satisfy that goal. In fact, given one world-locked space, transforming it by any arbitrary position and rotation produces another equally valid world-locked space. The Space Pin feature applies an additional constraint that removes the indeterminate nature of the world-locking transform. That constraint is that when \"near\" a Space Pin, the pose of that Space Pin in world-locked space will be the same as the pose of the Space Pin in modeling space. Consider a cube in a Unity scene modeled at global coordinates of (0, 0, 1). When the scene is loaded into HoloLens, the cube will appear 1 meter in front of the initial head pose. Depending on the initial head pose, that might be anywhere in the physical room. The Space Pin allows that cube to be locked to a real world feature in the room, e.g. the corner of a specific desk. Unlike locking the cube with a WorldAnchor, the Space Pin moves the entirety of Unity space such that the cube is aligned with the desk corner. So, for example, other desktop items modeled relative to the cube in Unity will be dispersed properly across the real desktop. Addressing the scale error While a single Space Pin removes the indeterminacy of the relation between virtual coordinate and the real world, it doesn't address scale error. That is, while it may have moved the origin to a physical world aligned position and orientation, walking 10 meters in the real world might still only move the user 9 meters in virtual space. For this, multiple Space Pins provide the complete solution. When near any specific Space Pin, the world will be aligned according to that Space Pin. The other Space Pins will be off, but being more distant, that generally proves to be acceptable, and often imperceptible. As the user moves between Space Pins, a smooth interpolation minimizes the scale error at any given point in space. With an adequate density of Space Pins as reference points, misalignment of real world and virtual features is reduced to the order of head tracker error. While the required density of Space Pins depends on both the tracking quality the environment supports and the precision requirements of the application, some numbers here might help set expectations. In an office environment, with adequate lighting and visible features to track, a spacing of 10 meters between Space Pins reduces error from an accumulation of 10-20 cm over 10 meters, down to millimeter errors (max error l.t. 0.5cm, 0.0 error at endpoints). Persistence The Space Pin feature works in tandem with the rest of World Locking Tools' persistence. There are both manual calls for invoking saving and loading from script, and flags for automated saving and loading per session. When enabled, the AutoSave/AutoLoad feature on the World Locking Tools Manager will allow the full spatial alignment of the virtual world to the real world to be restored on subsequent sessions. In practice, this means that a single or small number of preliminary sessions may be used to establish an adequate scan of the physical environment, and alignment of that physical environment with Unity's modeling coordinate space. Subsequent sessions will then load the virtual environment correctly aligned with the real world without further user action required. Interpolation and extrapolation Interpolation and extrapolation are both techniques for estimating data values where no direct measurement has been made. The space pins, as discussed so far, are locations where measurements have been made. The virtual coordinates are the desired coordinates, and the physical coordinates are measured coordinates we want those virtual coordinates to appear at. The system performs interpolation, but not extrapolation, as discussed below. In general, interpolation is safer and more stable than extrapolation. The piecewise linear interpolation provided will fulfill most applications' needs. Extrapolation is less safe, and its ideal implementation generally requires knowledge at the application level. It is therefore left for the application to handle extrapolation as described below. Without the application adding extrapolation pins, outside the bounds of the pins the space is pinned exclusively by the value at the nearest boundary. If there are only two pins, A and B, then as the user moves from A to B the pinning blends between that specified by A and that specified by B (interpolation). But when the user passes B then the pinning locks to exactly that specified by B (constant extension). Interpolation In the 2D region between pins, the spatial localization is linearly interpolated. This means that if the space pins are accurately placed, and the tracking error is evenly distributed over the region, then the correction applied in between the space pins will be exactly correct. It should be stressed here that the assumption of equal error distribution is exactly not correct. However, as an approximation, the linear model provides excellent correction results. Extrapolation The system provides no built-in extrapolation service, using constant value extension outside the convex hull of space pins. This is equivalent to assuming, incorrectly of course, that there is no scale error outside the application provided space pins. However, if the application has knowledge about the error distribution, or is satisfied with an estimate, it can create any extrapolation desired by adding more space pins in the periphery. Extrapolation example Consider a scene with four space pins, placed in a square with edges 4 meters long. Now, let's say that the actual space the user will be moving around in is twelve by twelve (12 x 12) meters, with the physical markers corresponding to the 4 pins surrounding the center of the space. If the application is satisfied with a constant error approximation, then it has all the information it needs to add 4 or more space pins to provide coverage over the entire 12x12m space. We'll label the pins at the corners of the 4x4 square by their cardinal directions, NE, NW, SW, and SE. We'll also label the virtual positions at each point virtualNE etc, and the physical positions at each point physicalNE etc. One strategy would be to add outer cardinal points creating a 12x12 meter square surrounding the inner square, by adding 4 more cardinal points, outerNE, outerNW, outerSW, and outerSE. The virtual and physical positions of each of these is simple to compute. Taking outerNE for example: virtualOuterNE = virtualNE + (virtualNE - virtualSW); physicalOuterNE = physicalNE + (physicalNE - virtualSW); Note that creating an extrapolation space of 20x20 meters only changes the scale of the delta applied: scale = (outerSize - innerSize) / innerSize / 2; virtualOuterNE = virtualNE + (virtualNE - virtualSW) * scale; physicalOuterNE = physicalNE + (physicalNE - virtualSW) * scale; With an outerSize of 20m, and an innerSize of 4m, the scale would be 2. An alternate strategy might be to add eight more points in addition to the corners as shown below. Computing the new pin locations from the existing ones is exactly as above. Be cautioned that, while it is true that adding additional pins generally improves stability, it does not necessarily improve accuracy. See also Space Pin Sample Ray Pins Sample Also see Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/AdvancedConcepts.html": {
    "href": "DocGen/Documentation/Concepts/AdvancedConcepts.html",
    "title": "Advanced capabilities of World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Advanced capabilities of World Locking Tools Some definition of terms might be helpful before diving deeper into World Locking Tools' more advanced usage. These concepts are discussed more thoroughly in subsequent sections of this documentation, including actions necessary for a developer wanting to manually leverage these capabilities. Persistence is the saving of World Locking Tools state from earlier sessions to enhance subsequent sessions, by leveraging the state collected and computed in the earlier sessions, rather than requiring it to be collected or computed again. Space Pins are a discrete and sparse set of points at which the World Locked Space may be mapped to modeling coordinates. In addition to allowing objects modeled in Unity's coordinate space to be aligned with the real world, they provide a solution to the tracker's \"scale problem\". Attachment points are special markers in the world which remain optimally registered to the physical world through infrequent adjustment events. A fragment is a collection of things which exist in known relation with each other in the same coordinate space. In contrast, there is generally no meaningful spatial relationship between different fragments. These are elsewhere referred to as \"tracker islands\". Refit operations are infrequent adjustment events, at times when additional sensor data enables an improved registration of virtual objects with the physical world, but only at the cost of moving them within world locked space. There are two types of refit operations. Merge operations are the repositioning of the entire contents of a fragment uniformly into a common coordinate space with another fragment. Refreeze operations are the repositioning of individual objects within a fragment to account for movement of the supporting anchors. See also Persistence Space Pins Attachment points Fragments Refit operations"
  },
  "DocGen/Documentation/Concepts/BasicConcepts.html": {
    "href": "DocGen/Documentation/Concepts/BasicConcepts.html",
    "title": "The basic idea | World Locking Tools for Unity Documentation",
    "keywords": "The basic idea Inside-out head tracking systems are an amazing new technology. At their strengths they are almost magical. But they have their weaknesses too. Inside-out head tracking systems, like those in the HoloLens, are very good at telling where the head is relative to nearby physical features. Equivalently, they are very good at telling where real-world features are relative to the head. But they are not as good at telling where the head is relative to where the head was. When the head moves from point A to point B, the tracking system will generally be slightly wrong about how far the head has traveled. That means the tracking system will be incorrect about the distance between points A and B. This is frequently and confusingly called \"the scale problem\". Then when the head travels from point B back to point A, it will again be wrong about the distance traveled. It will be impressively close to correct, but noticeably incorrect. This is also referred to as \"drift\". These problems are discussed more in this FAQ . What matters here is that the World Locking Tools can fix these problems. In the latter case, of drift, the World Locking Tools can recognize that the head is back near point A, from the physical features around point A, and correct the head's coordinates. In the former case, of the scale problem, the World Locking Tools can take additional input from the application to know where point B is relative to point A, and correct that distance travelled as well. To understand further how the World Locking Tools accomplish this, some additional terminology will be helpful. Spongy and world locked spaces Spongy space At the core of World Locking Tools is an optimization engine. It takes as inputs a graph of currently active spatial anchors in the world, along with the current head tracking information. This is commonly referred to, within this and related documentation and code, as the Spongy state . The spongy state is so named because it is constantly in flux. The spatial anchors are always in motion relative to each other, and within their native spongy coordinate space, as incoming sensor data refines their state. This spongy space is the only coordinate system previously available in which the mixed reality application developer could work. World locked space From the spongy state, the World Locking Tools engine computes a stable space which optimally aligns the spongy space with the physical world. This stable space is referred to as World locked space , and its full state as the frozen state . It is important to realize that both spongy space and world locked space are rigid cartesian coordinate systems, and in fact differ from each other by only a rotation and offset. However, the transform from spongy space to world locked space changes each frame, as new sensor data is processed. The difference between the two spaces is that, while incoming sensor data is free to refine (i.e. move) spatial anchors relative to each other and the head in spongy space, world locked space is chosen to minimize such movements. This allows scene objects placed in world locked space to appear fixed in the physical world without being attached to individual spatial anchors. Each frame the engine computes the world locked space in which the underlying anchors are most stable. That is, the world locked space in which virtual objects stay optimally aligned with real world features. This transform is applied to the scene each frame by adjusting the local transform of a parent of the camera in the scene graph. Since the camera defines the original spongy space, inserting this \"world-locked from spongy\" transform into the camera's hierarchy establishes the root space of the scene to be world locked space. Persistence The Frozen State can optionally be persisted across sessions. There are manual controls for both saving the current state and for loading from a saved state. Additionally, flags on the World Locking Tools Manager enable or disable automatic periodic saving of Frozen State, and automatic loading of the last saved state at startup. Using these features allows the scanning and stabilization of a real space to persist over multiple sessions. Additionally, if the Space Pin feature is used to align modeling space to the real space, that alignment can be persisted. In that case, after an initial alignment session to set up the Space Pins to align the modeled scene to a physical space, subsequent sessions can automatically load the modeled scene into the physical space with virtual and real features aligned. See Persistence and Space Pin feature for further details. Camera movement implications A subtle but important thing to note here is that, by applying the correction transform to the camera, the native Unity \"stationary frame of reference\" has been converted into the optimal world locked frame of reference. Since no objects in the scene were moved, this will not interfere with physics simulation or other dynamics calculations. However, the camera being moved within the stationary frame of reference does have implications. Specifically, any sub-systems which assume that the head transform is the only transform between the stationary frame of reference and the camera space will be incorrect. This is generally not a problem, as such capabilities as teleport already rely on the ability to place a transform between the camera and root space. Also, the MRTK already factors in the need for such transforms, so for users of MRTK services this will \"just work\". For users requiring direct access to lower level systems that are unable to take advantage of MRTK, samples are provided for building adapters. A few such examples are listed below: A world anchor adapter Tap event adapting Spatial mapping adapter See also Advanced topics How-to articles Samples"
  },
  "DocGen/Documentation/GettingStartedWithWorldLocking.html": {
    "href": "DocGen/Documentation/GettingStartedWithWorldLocking.html",
    "title": "Getting started in World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Getting started in World Locking Tools Getting started in World Locking Tools can be as simple as dragging a prefab into a Unity scene. However, understanding the work the Unity layer of World Locking Tools performs, as well as the underlying FrozenWorld engine, can be helpful as well as educational. Goals of this documentation The first goal is to establish an understanding of what World Locking Tools is trying to do. This can help in setting expectations for what problems World Locking Tools can solve, and what problems are out of its scope. The number-crunching optimization at the core of World Locking Tools is performed in an engine implemented as an efficient C-style DLL. While a C# shim is provided for directly interfacing to the World Locking Tools engine from Unity scripting, it is hoped that low level interaction with the engine will be rarely if ever needed. It is important to understand that World Locking Tools' Unity layer acts as a proxy application, performing the tasks that the vast majority of applications built on Unity would need to perform in managing the FrozenWorld engine. Sharing this engine harness makes sense, avoiding each application developer being responsible for implementing essentially the same control structure. But for an application which is in the minority having special requirements, World Locking Tools' Unity layer acts as a sample scaffolding for building a custom harness for the engine. Understanding what the provided scaffolding is doing is necessary to modify it, or to implement a variation of it. It will be shown that a good deal of customization is available, even without modifying code. Understanding what World Locking Tools is doing, as well as the customizable properties, is helpful for fine tuning World Locking Tools for a specific application. Finally, an understanding of World Locking Tools can be helpful when things go wrong, in narrowing which system is faulty, providing useful bug reports, and establishing workarounds. Guide structure These guides are arranged to both build an understanding of World Locking Tools at a conceptual level, and provide practical step-by-step instructions on putting World Locking Tools to use in real world MR applications. Initial setup Concepts The basic system Advanced topics How-to articles Samples Additionally, the API documenation provides a reference on programmatic interfaces into World Locking Tools. It should be stressed that in most cases, there will be no need to code directly to the World Locking Tools interfaces, and scene setup and property settings in the inspector are all that are required. The exception is with attachment points , which are covered later both conceptually and in the programming reference ."
  },
  "DocGen/Documentation/HowTos.html": {
    "href": "DocGen/Documentation/HowTos.html",
    "title": "How-To articles | World Locking Tools for Unity Documentation",
    "keywords": "How-To articles To complement the concept articles giving motivation and understanding of the design and use of World Locking Tools, and the API documentation detailing the implementation, these how-to articles provide a hands-on walk-through of common steps in developing applications with World Locking Tools. See also Initial Setup World Locking Tools Contexts Sample Applications"
  },
  "DocGen/Documentation/HowTos/CodingConventions.html": {
    "href": "DocGen/Documentation/HowTos/CodingConventions.html",
    "title": "Coding Guidelines | World Locking Tools for Unity Documentation",
    "keywords": "Coding Guidelines This document outlines the recommended coding guidelines for World Locking Tools for Unity. The majority of these suggestions follow the recommended standards from MSDN . Script license information headers All scripts posted to World Locking Tools for Unity should have the standard License header attached, exactly as shown below: // Copyright (c) Microsoft Corporation. All rights reserved. // Licensed under the MIT License. See LICENSE in the project root for license information. Any script files submitted without the license header will be rejected. Function / Method summary headers All public classes, structs, enums, functions, properties, fields posted should be described as to their purpose and use, exactly as shown below: /// <summary> /// The Controller definition defines the Controller as defined by the SDK / Unity. /// </summary> public struct Controller { /// <summary> /// The ID assigned to the Controller /// </summary> public string ID; } This ensures documentation is properly generated and disseminated for all all classes, methods, and properties. Any script files submitted without proper summary tags will be rejected. Namespace rules All classes and extensions should be scoped by namespace, chosen appropriately from the following namespaces. Microsoft.MixedReality.WorldLocking.Core - Foundation code fulfilling the basic service of World Locking Tools. Microsoft.MixedReality.WorldLocking.Tools - Optional features supplementing development on top of World Locking Tools. Examples are diagnostic visualizations, and baseline implementations of application event handlers. Microsoft.MixedReality.WorldLocking.Examples - Specific implementations demonstrating how to use World Locking Tools features, and the benefits gained. Related features within one of the above namespaces may be grouped by extending to a new sub-namespace. Do: namespace Microsoft.MixedReality.WorldLocking.Examples.Placement { // Interface, class or data type definition. } Omitting the namespace for an interface, class or data type will cause your change to be blocked. Spaces vs Tabs Please be sure to use 4 spaces instead of tabs when contributing to this project. Additionally, ensure that spaces are added for conditional / loop functions like if / while / for Don't: private Foo () // < - space between Foo and () { if(Bar==null) // <- no space between if and () { DoThing(); } while(true) // <- no space between while and () { Do(); } } Do: private Foo() { if (Bar==null) { DoThing(); } while (true) { Do(); } } Spacing Do not to add additional spaces between square brackets and parenthesis: Don't: private Foo() { int[ ] var = new int [ 9 ]; Vector2 vector = new Vector2 ( 0f, 10f ); } Do: private Foo() { int[] var = new int[9]; Vector2 vector = new Vector2(0f, 10f); } Naming Conventions Always use PascalCase for public / protected / virtual properties, and camelCase for private properties and fields. The only exception to this is for data structures that require the fields to be serialized by the JsonUtility . Don't: public string myProperty; // <- Starts with a lower case letter private string MyProperty; // <- Starts with an uppercase case letter Do: public string MyProperty; protected string MyProperty; private string myProperty; Access Modifiers Always declare an access modifier for all fields, properties and methods. All Unity API Methods should be private by default, unless you need to override them in a derived class. In this case protected should be used. Fields should always be private , with public or protected property accessors. Don't: // protected field should be private protected int myVariable = 0; // property should have protected setter public int MyVariable { get { return myVariable; } } // No public / private access modifiers void Foo() { } void Bar() { } Do: public int MyVariable { get; protected set; } = 0; private void Foo() { } public void Bar() { } protected virtual void FooBar() { } Use Braces Always use braces after each statement block, and place them on the next line. Don't: private Foo() { if (Bar==null) // <- missing braces surrounding if action DoThing(); else DoTheOtherThing(); } Don't: private Foo() { // <- Open bracket on same line if (Bar==null) DoThing(); <- if action on same line with no surrounding brackets else DoTheOtherThing(); } Do: private Foo() { if (Bar==true) { DoThing(); } else { DoTheOtherThing(); } } Public classes, structs, and enums should all go in their own files. If the class, struct, or enum can be made private then it's okay to be included in the same file. This avoids compilations issues with Unity and ensure that proper code abstraction occurs, it also reduces conflicts and breaking changes when code needs to change. Don't: public class MyClass { public struct MyStruct() { } public enum MyEnumType() { } public class MyNestedClass() { } } Do: // Private references for use inside the class only public class MyClass { private struct MyStruct() { } private enum MyEnumType() { } private class MyNestedClass() { } } Do: MyStruct.cs // Public Struct / Enum definitions for use in your class. Try to make them generic for reuse. public struct MyStruct { public string Var1; public string Var2; } MyEnumType.cs public enum MuEnumType { Value1, Value2 // <- note, no \",\" on last value to denote end of list. } MyClass.cs public class MyClass { private MyStruct myStructreference; private MyEnumType myEnumReference; } Order Enums for appropriate extension. It is critical that if an Enum is likely to be extended in the future, to order defaults at the top of the Enum, this ensures Enum indexes are not affected with new additions. Don't: public enum SDKType { WindowsMR, OpenVR, OpenXR, None, <- default value not at start Other <- anonymous value left to end of enum } Do: /// <summary> /// The SDKType lists the VR SDK's that are supported by the MRTK /// Initially, this lists proposed SDK's, not all may be implemented at this time (please see ReleaseNotes for more details) /// </summary> public enum SDKType { /// <summary> /// No specified type or Standalone / non-VR type /// </summary> None = 0, /// <summary> /// Undefined SDK. /// </summary> Other, /// <summary> /// The Windows 10 Mixed reality SDK provided by the Universal Windows Platform (UWP), for Immersive MR headsets and HoloLens. /// </summary> WindowsMR, /// <summary> /// The OpenVR platform provided by Unity (does not support the downloadable SteamVR SDK). /// </summary> OpenVR, /// <summary> /// The OpenXR platform. SDK to be determined once released. /// </summary> OpenXR } End Enum names with \"Type\" Enum names should clearly indicate their nature by using the Type suffix. Don't: public enum Ordering { First, Second, Third } public enum OrderingEnum { First, Second, Third } Do: public enum OrderingType { First = 0, Second, Third } Review Enum use for Bitfields. If there is a possibility for an enum to require multiple states as a value, e.g. Handedness = Left & Right. Then the Enum needs to be decorated correctly with BitFlags to enable it to be used correctly The Handedness.cs file has a concrete implementation for this Don't: public enum Handedness { None, Left, Right } Do: [flags] public enum HandednessType { None = 0 << 0, Left = 1 << 0, Right = 1 << 1, Both = Left | Right } Best Practices, including Unity recommendations Some of the target platforms of this project require to take performance into consideration. With this in mind always be careful when allocating memory in frequently called code in tight update loops or algorithms. Encapsulation Always use private fields and public properties if access to the field is needed from outside the class or struct. Be sure to co-locate the private field and the public property. This makes it easier to see, at a glance, what backs the property and that the field is modifiable by script. If you need to have the ability to edit your field in the inspector, it's best practice to follow the rules for Encapsulation and serialize your backing field. The only exception to this is for data structures that require the fields to be serialized by the JsonUtility , where a data class is required to have all public fields for the serialization to work. Don't: public float MyValue; Do: // private field, only accessible within script (field is not serialized in Unity) private float myValue; Do: // Enable private field to be configurable only in editor (field is correctly serialized in Unity) [SerializeField] private float myValue; Don't: private float myValue1; private float myValue2; public float MyValue1 { get{ return myValue1; } set{ myValue1 = value } } public float MyValue2 { get{ return myValue2; } set{ myValue2 = value } } Do: // Enable field to be configurable in the editor and available externally to other scripts (field is correctly serialized in Unity) [SerializeField] [ToolTip(\"If using a tooltip, the text should match the public property's summary documentation, if appropriate.\")] private float myValue; // <- Notice we co-located the backing field above our corresponding property. /// <summary> /// If using a tooltip, the text should match the public property's summary documentation, if appropriate. /// </summary> public float MyValue { get{ return myValue; } set{ myValue = value } } Use for instead of foreach when possible. In some cases a foreach is required, e.g. when looping over an IEnumerable. But for performance benefit, avoid foreach when you can. Don't: foreach(var item in items) Do: int length = items.length; // cache reference to list/array length for(int i=0; i < length; i++) Cache values and serialize them in the scene/prefab whenever possible. With the HoloLens in mind, it's best to optimize for performance and cache references in the scene or prefab to limit runtime memory allocations. Don't: void Update() { gameObject.GetComponent<Renderer>().Foo(Bar); } Do: [SerializeField] // To enable setting the reference in the inspector. private Renderer myRenderer; private void Awake() { // If you didn't set it in the inspector, then we cache it on awake. if (myRenderer == null) { myRenderer = gameObject.GetComponent<Renderer>(); } } private void Update() { myRenderer.Foo(Bar); } Cache references to materials, do not call the \".material\" each time. Unity will create a new material each time you use \".material\", which will cause a memory leak if not cleaned up properly. Don't: public class MyClass { void Update() { Material myMaterial = GetComponent<Renderer>().material; myMaterial.SetColor(\"_Color\", Color.White); } } Do: // Private references for use inside the class only public class MyClass { private Material cachedMaterial; private void Awake() { cachedMaterial = GetComponent<Renderer>().material; } void Update() { cachedMaterial.SetColor(\"_Color\", Color.White); } private void OnDestroy() { Destroy(cachedMaterial); } } Alternatively, use Unity's \"SharedMaterial\" property which does not create a new material each time it is referenced. Use platform dependent compilation to ensure the Toolkit won't break the build on another platform Use WINDOWS_UWP in order to use UWP-specific, non-Unity APIs. This will prevent them from trying to run in the Editor or on unsupported platforms. This is equivalent to UNITY_WSA && !UNITY_EDITOR and should be used in favor of. Use UNITY_WSA to use UWP-specific Unity APIs, such as the UnityEngine.XR.WSA namespace. This will run in the Editor when the platform is set to UWP, as well as in built UWP apps. This chart can help you decide which #if to use, depending on your use cases and the build settings you expect. UWP IL2CPP UWP .NET Editor UNITY_EDITOR False False True UNITY_WSA True True True WINDOWS_UWP True True False UNITY_WSA && !UNITY_EDITOR True True False ENABLE_WINMD_SUPPORT True True False NETFX_CORE False True False Prefer DateTime.UtcNow over DateTime.Now DateTime.UtcNow is faster than DateTime.Now. In previous performance investigations we've found that using DateTime.Now adds significant overhead especially when used in the Update() loop. Others have hit the same issue . Prefer using DateTime.UtcNow unless you actually need the localized times (a legitmate reason may be you wanting to show the current time in the user's time zone). If you are dealing with relative times (i.e. the delta between some last update and now), it's best to use DateTime.UtcNow to avoid the overhead of doing timezone conversions."
  },
  "DocGen/Documentation/HowTos/Contributing.html": {
    "href": "DocGen/Documentation/HowTos/Contributing.html",
    "title": "Contributing to the World Locking Tools for Unity project | World Locking Tools for Unity Documentation",
    "keywords": "Contributing to the World Locking Tools for Unity project The most valuable way to contribute to the World Locking Tools project at this time is by filing issues. Any and all feedback on better aligning the World Locking Tools for Unity project with your project's needs is extremely valuable. While any feedback you post is valuable, here are some tips on making yours more actionable. Use labels appropriately Both when initially submitting an issue, and when following up on an issue as a contributor, proper use of labels is extremely helpful on coordinating with other contributors. Try to differentiate accurately between what is a bug, what is a feature request, and what is a broader suggestion going forward. All are valuable, but they are more valuable once identified as such. Likewise, if an issue seems unactionable in its current form, applying the appropriate label (e.g. \"unclear\") can help get it improved to where it is actionable. Specific comments in the issue itself are, of course, extremely valuable. But the proper label may lead others to see a comment that might otherwise go unnoticed. Reporting a bug Issues may be submitted from the issues portal on GitHub. Taking the time to report a problem or make a suggestion that others will benefit from as well is always appreciated. Every bug report has its own context, but in general, the more of the following that are included the more quickly an issue can get resolved. Log files from the device Log files from the device can be immeasurably helpful in investigating issues, especially in conjunction with screen captures suggested below. They may be obtained using the Windows Device Portal while connected to your device, under System > File explorer > User Folders \\ LocalAppData \\ WorldLockingTools The Unity app log file: UnityPlayer.log is located in the TempState sub-folder. This is a plain text file. The World Locking Tools diagnostics recording: The diagnostics file is located in the LocalState sub-folder. The file's name is auto-generated according to the following pattern: FrozenWorld-<device name>-<capture date and time>.hkfw It is a binary file which needs specialized software to examine. Note that to capture a diagnostics recording requires enabling Diagnostics Recording on the World Locking Tools Manager component in your scene. See the diagnostics documentation for details. Repro steps Specify how readily the issue happens. The ideal is having a bug that occurs 100% of the time following a certain set of step. But even for a bug that you've only seen happen once, the more detailed you can relate the steps leading up to the issue, the better. Repro steps should follow the following general form: Starting from this normal stable state... Then I did this (or noticed this unusual thing)... Then the system started showing this incorrect behavior... Screen captures Screen captures will help identify the full context the issue occurred in. In particular, having World Locking Tools diagnostics displayed on screen can help correlate your experience to the information in the logs. These can either be snapshot images, or video captures. Device info What type of device? Running what OS-version? Build environment Unity version Visual Studio version Proposing a feature When you find that World Locking Tools almost does what you need, the chances are that someone else is suffering the same limitation. We are just as interested in fixing gaps in our documentation and examples as in providing new capabilities. In proposing a new feature, it's most valuable to make clear what it is you are trying to get done. While ideas on how to implement it can also be helpful, proposals that make clear the added value are more likely to gain traction. Make the problem the feature solves obvious, preferably with what you could accomplish with it in a real world scenario. Make sure to attach the \"enhancement\" label to the submitted proposal issue. Contributing code This is an open source project, so of course anyone can make a fork to develop on at any time. If someone is generous enough to share back work, then it is greatly appreciated, whether it gets folded back into the main repository or not. During this initial roll out period, we will have limited resources to review and accept pull requests into the main repository. It is advisable to avoid investing a lot of time into a fork under the assumption that it will be merged back to the main repository. One way to mitigate the risk is to submit an issue proposing what is intended (labeled \"enhancement\") before investing a lot of time in an implementation. This is also considerate toward other contributors that might be looking at the same problem area. See also Coding Conventions Release Process"
  },
  "DocGen/Documentation/HowTos/InitialSetup.html": {
    "href": "DocGen/Documentation/HowTos/InitialSetup.html",
    "title": "Initial setup of World Locking Tools | World Locking Tools for Unity Documentation",
    "keywords": "Initial setup of World Locking Tools Supported environments World Locking Tools for Unity currently targets UWP applications for the HoloLens family of devices. Both the original HoloLens (x86) and HoloLens 2 (ARM64) are supported. The World Locking Tools continuous integration (CI) build validates with Unity2018.4.6f1 with Visual Studio 2017. However, extensive WLT development has also been done using the gamut of Unity2018 versions, as well as a range of Unity2019. Both Visual Studio 2017 and Visual Studio 2019 have been used in the development of the tools. If you experience any compatibility issues with other versions of Unity and/or Visual Studio, we would love to hear about it! The best way to report any problems is through the issues portal on GitHub. The World Locking Tools layers World Locking Tools is broken into four layers. With the arrows pointing toward the layer depended on, the straightforward dependency graph looks like this: The dashed lines indicate optional dependencies. Note that while the Examples layer sometimes leverages the MixedRealityToolkit (MRTK), none of the other layers have any external dependencies, and the full functionality is available compatible with but independent of MRTK. Further notes on the Applications dependencies follow below. The layers may be summarized as follows: Plugin An imperative interface allowing direct communication with the Engine DLL. Common issues such as argument marshalling are accomplished here, as well as some composing of multiple functions frequently used in combination into composite directives. It remains a low level C# interface to the underlying C++ DLL. Its direct use is available, but generally not needed nor advisable. Core The Core is an encapsulation of all steps necessary for gaining the benefits of World Locking Tools' stable world-locked space, packaged into a declarative interface. A working application would be expected to ship using only functionality from the Core. Tools The Tools are largely diagnostic in nature. Visualizations of World Locking Tools processes are included in forms easy to add to any project which uses World Locking Tools. Other convenient utilities are included, but are expected to be helpful in getting started toward coding up custom solutions, rather than to be final solutions as the Core offers. Examples The Examples layer attempts to present samples of setting up common scenarios when using World Locking Tools, as well as best practices in World Locking Tools' integration into various scenarios. Any necessary MRTK dependencies for UX and object manipulation are restricted to the scripts and prefabs at the Examples layer. This leaves the lower layers free of any external dependencies. Scripts and assets in the Examples layer are not expected to be integrated directly into shipping products, although there is no prohibition against it. Rather, their construction favors simplicity and clarity over reusability and efficiency. The Application In general the Application will need take only a dependency on World Locking Tools Core. During development, many visualizations and other helpers for understanding unexpected behavior are available in the Tools layer. These would ideally be stripped out of a finished application, or at least disabled. Of course, they are free for other uses as well, either in their current form or modified. See the license for details. For advanced use, as well as experimentation of World Locking Tools' full capabilities, the Plugin layer offers low level imperative access to the Engine DLL. If access to the Plugin layer becomes necessary, it may point to a deficiency in the API surface offered in the Core layer. The World Locking Tools team is always looking to fill such gaps. Consider contributing such insights to the team. See contributing . A warning note on installation path length Some versions of MRTK have an issue with long installation paths. The full path length of deep subfolders in the MRTK installation can exceed the Windows path limit (260 characters). If a build error of the following form appears: DirectoryNotFoundException: Could not find a part of the path \"D:\\MyOverTwentyEightCharacterLongLengthInstallPath\\MixedReality-WorldLockingTools-Unity\\Assets\\MRTK\\MixedRealityToolkit.Providers\\WindowsMixedReality\\DotNetAdapter\\Plugins\\net46\\Microsoft.Windows.MixedReality.DotNetWinRT\\Editor\\Microsoft.Windows.MixedReality.DotNetWinRT.Editor.asmdef\" but the file is actually there on the drive, then the issue is likely the path length. The MRTK team is aware of this and is working to improve on it. In the meantime, the workaround is to shorten the path prefix by a combination of the following: Install the Unity project into a shorter length path root, e.g. \"D:\\Proj\" If cloning the repo, clone the root of the World Locking Tools into something shorter than the default \"\\MixedReality-WorldLockingTools-Unity\", e.g. git clone https://github.com/microsoft/MixedReality-WorldLockingTools-Unity.git d:\\MyGit\\wlt This is generally not an issue with the World Locking Tools themselves, as they don't utilize as deep a folder structure. Adding World Locking Tools to a Unity project World Locking Tools relies on NuGet for Unity for distribution. To begin, make sure NuGet for Unity is installed into the Unity project. It is available from the (NuGet for Unity github releases)[https://github.com/GlitchEnzo/NuGetForUnity/releases]. If the target Unity project is the World Locking Tools project (or a derivative of it), then all necessary and optional resources are already included. If adding World Locking Tools to an existing project, it is advisable to start with a project that has been verified to build and deploy to a HoloLens device. This will help separate issues with getting an app to run on HoloLens in the first place, which can be complicated, from issues with the World Locking Tools. Then proceed to the NuGet setup and World Locking Tools Assets sections below. NuGet setup Make sure the nuget.org feed is in sources. Check this in Unity > Edit > Preferences > NuGet for Unity. If not, either : Either use the Add New Source GUI in Unity > Edit > Preferences > NuGet For Unity to add the same share. Replace \"New Source\" with a name of your choosing (e.g. \"NuGet\"). Replace \"source_path\" with \"http://www.nuget.org/api/v2/\". Or use a text editor to add a packagesource line to Assets/NuGet.config, e.g. <packageSources> <add key=\"NuGet\" value=\"http://www.nuget.org/api/v2/\" /> </packageSources> After confirming the nuget.org feed, in Unity > NuGet > Manage NuGet Packages, find and install the latest version of Microsoft.MixedReality.FrozenWorld.Engine. (Search for \"FrozenWorld\".) World Locking Tools Assets Either import the required World Locking Tools .unitypackage files into the project (preferred method), or copy them in. They may be moved into a sub-folder within Assets to get them out of the way for application development. The latest stable .unitypackage files can be found in: https://github.com/microsoft/MixedReality-WorldLockingTools-Unity/releases The WorldLocking.Core and Engine layer will definitely be required, so a minimal install package would be WorldLockingCoreEngine.unitypackage. To determine what other layers might be required, see the discussion of World Locking Tools layers and their dependencies above. Each layer is contained in a single Unity package. Note that since some of the World Locking Tools Examples use features from MRTK, a compatible MRTK snapshot is included with the Examples unitypackage. For the latest MRTK release, look here . Adding World Locking Tools to a Unity scene Within a Unity project containing the FrozenWorld engine (from nuget.org), import any desired World Locking Tools Assets layers (but at least WorldLocking.Core), and optionally MRTK. Then create a new scene (or open an existing scene). Add an extra node at the root of the camera hierarchy. This node will be used to adjust the head tracked camera into world locked space. (If using MRTK, this new GameObject would be the parent of the MixedRealityPlayspace.) The core experience Drag a WorldLockingManager prefab from Assets/WorldLocking.Core/Prefabs into your scene. Its place in the scene doesn't matter, but it should not be in the camera tree. See a sample scene for a suggested configuration. There are settings available on the WorldLockingManager prefab, but leaving them to their default values is recommended to get started. See World Locking Tools Context for explanations of the options presented. [Optional] MRTK World Locking Tools is complementary with but orthogonal to MRTK. The use of MRTK along with World Locking Tools is entirely optional. That said, the World Locking Tools samples are built using MRTK, and MRTK is generally extremely valuable in developing the types of MR applications that benefit most from World Locking Tools. If using MRTK, rather than using the snapshot included with the examples, it's recommended to add the latest versions of at least the following packages: MixedReality.Toolkit MixedReality.Toolkit.Providers MixedReality.Toolkit.Services MixedReality.Toolkit.SDK [Optional] Visualizing spongy and world locked anchors This requires the addition of WorldLocking.Tools to the project's Assets. If you want to visualize your anchors, drag AnchorGraphVisual prefab from Assets/WorldLocking.Tools/Prefabs into your scene. Check-boxes to toggle aspects of the visualization in the inspector are on the WorldLockingManager . Note that, as diagnostics, the WorldLocking.Tools visualizations are not heavily optimized, and will become a drag on performance long before the core World Locking Tools processing time becomes relevant. [Optional] A simple dashboard for parameter control within Mixed Reality A simple HUD is available, which may be used to control the WorldLockingManager at runtime from inside MR. These are supplied in the Examples package. While they may be used as is, they are intended as patterns when building similar features into an applications own display system and UX. Drag in the WorldLocking.Examples/Prefabs/Dashboard prefab, and point its Anchor Visualizer field to the Visualizer in the previous section. Migrating an existing scene to World Locking Tools The biggest change when moving to World Locking Tools is that there is no longer a requirement for using WorldAnchors to world-lock virtual objects. WorldAnchors have traditionally been the only tool available to world-lock individual objects. But when using World Locking Tools, the coordinate space those virtual objects exist in is already world-locked. No further locking is needed. Not only are WorldAnchors unnecessary, they won't work correctly, as they fail to take into account additional transforms up the camera hierarchy (such as the MRTK Playspace transform). Therefore, any and all WorldAnchors should be removed from the scene, and any scripts adding WorldAnchors should discontinue doing so. The WorldAnchors don't need to be replaced by anything; World Locking Tools will anchor their targets to the real world. If it is desirable to compare world-locking with and without World Locking Tools, then instead of removing WorldAnchors, they may be replaced with the ToggleWorldAnchor supplied in WorldLocking.Tools. ToggleWorldAnchor works exactly the same as a WorldAnchor, with the important difference that when the World Locking Tools Manager is active, it conveniently disables itself and gets out of the way. When the World Locking Tools Manager is disabled, it behaves as a normal WorldAnchor. If for some other reason WorldAnchors are still required in the scene (e.g. for network sharing), their can be used with an adapter, supplied as WorldAnchorAdapter . The WorldAnchorAdapter transforms the raw position of a GameObject positioned by a WorldAnchor, into the world locked Unity global space, and then applies the transform to a target object. To use it, rather than adding a WorldAnchor directly to an object, the WorldAnchor should be applied to a proxy object (usually an otherwise empty GameObject), and then on Update() the WorldAnchorAdapter reads the pose of the WorldAnchor, transforms it correctly, and applies it to the target. Setup complete Having followed the above steps, the project deployed to device will run adjusted by World Locking Tools to maintain an optimally stable world-locked space. Any fixed objects placed in the scene will remain visually consistent both relative to each other and with the physical world. Available example applications Sample scenes , including both scripts and assets are provided to demonstrate more complex use of World Locking Tools' capabilities. For example, the WorldLockedPhysicsSample provides a simple environment in which physically simulated objects can be created and removed, interacting with each other and with the environment (the spatial mapping). For a more focused look at the Space Pinning feature, the SpacePin provides a much simplified example of aligning a large scale virtual object to real world features. The RayPins expands on the capabilities introduced by the SpacePin example, allowing pinning of the virtual world to the physical world with ray tests against the spatial mesh."
  },
  "DocGen/Documentation/HowTos/ReleaseProcess.html": {
    "href": "DocGen/Documentation/HowTos/ReleaseProcess.html",
    "title": "Developing new code and documentation | World Locking Tools for Unity Documentation",
    "keywords": "Developing new code and documentation Depending on access level, new code and documentation may be developed in a new feature branch, or in a fork. In general, working from a separate fork is preferred, and is sometimes the only alternative. Best practices in git/GitHub development are outside the scope of this documentation, but further reading may be found here . Submitting a pull request (PR) Any pull request should include a manual run through the CI build pipeline. The pipeline is triggered by adding a comment to the PR. The following will trigger a full build: /azp run If it is known that the changes are entirely restricted to either code or documentation, then only that side of the build may be run. For example, to check only code changes: /azp run wlt_ci Or to check only documentation changes: /azp run wlt_docs However, keep in mind that even changes restricted to code (.cs) files may trigger documentation changes. It is always safer to run the full build. Please run the appropriate version after any significant changes to a PR, and before final completion of the PR. Remember, those tools are in place to protect contributors from breaking the build. Using them is to your own benefit, as well as the benefit of others working in the same space. Code review All PRs must also be reviewed by another developer before they may be completed. When performing code reviews, please maintain a friendly and collaborative atmosphere. It is always worth a little extra time to find a way to express a suggestion or correction which leaves the other side feeling positive about the changes. Publishing a new release After thorough testing and stabilization, a new safe version of the product may be published. The product is made available through two channels: Via the open source GitHub repo, tagged for verified release commits. Via published .unitypackage files. Both channels are available on the WLTU's GitHub releases page . Building the unity packages NOTE: The exact UI of the process described here is subject to frequent change. If what you see on your screen doesn't match the screenshots here, that's probably okay. Just look for the relevant keywords and follow through. First, go to the build pipeline page . Be sure that \"wlt_ci\" is selected. Select the build that matches the commit that will be the basis for the release. That will lead to the following screen, from which the build artifacts may be accessed.* Select the unity packages. Then download as zip. After installing and testing the packages, they may be integrated into a new release. Creating the release Update the Version field in code Update the WorldLockingManager.Version field to properly reflect the new version. Create a release branch For example, create a branch named \"release/v0.3.6-alpha\". While somewhat redundant with the tag, this will facilitate hot-fixes to the release which wouldn't be suitable for the main development branch \"master\". Publish the release Go to the World Locking Tools for Unity releases page . Click the \"Create a new release\" button. Specify a tag. The tag should be of the form vX.Y.Z[-prerelease-modifier]. This X.Y.Z of this tag are 3 integers which should match the version as specified in the WorldLockingManager.Version field . This should also match the release branch name. Specify the release branch created above as the target. Fill in the title and description fields appropriately. Drag the .unitypackage files created above into the rectangle labeled \"Attach binaries by dropping them here or selecting them\". The large Examples package, which also contains a snapshot of its MRTK dependency, may take considerable time to upload. It is safest to not leave that page until the upload has completed successfully. When the .unitypackage files have successfully uploaded, click the Publish Release button. Verify that everything looks correct on the releases page."
  },
  "DocGen/Documentation/HowTos/SampleApplications.html": {
    "href": "DocGen/Documentation/HowTos/SampleApplications.html",
    "title": "Example applications | World Locking Tools for Unity Documentation",
    "keywords": "Example applications This project ships with a number of sample applications. These are working apps which demonstrate World Locking Tools' capabilities as well as scenarios which World Locking Tools enables. They also attempt to show best practices in coding against the World Locking Tools APIs. See also World Locked Physics Sample Space Pin Sample Ray Pin Sample"
  },
  "DocGen/Documentation/HowTos/Samples/RayPins.html": {
    "href": "DocGen/Documentation/HowTos/Samples/RayPins.html",
    "title": "Ray Pins Example | World Locking Tools for Unity Documentation",
    "keywords": "Ray Pins Example Related samples The Space Pins sample demonstrates setting up Space Pins by manually manipulating marker objects into position using MRTK affordances. More abstract discussion about the Space Pin feature is also relevant background for this sample. Rather than manual manipulation of objects, this sample uses ray cast tests onto the spatial reconstruction meshes to set the world alignment. Significantly, this sample also creates all required World Locking Tools components from script, rather than needing assets setup in the editor. Scene contents There are eight (8) Space Pin virtual marker objects in the RayPins scene. Four (4) are floor level, at the northeast, southeast, northwest, and southwest corners of a square four meters (4m) per side. Another four (4) pins are one meter up, suggesting they are points on walls six meters (6m) apart. Building the sample Note that the sample requires the SpatialPerception capability. The Microphone capability is also required for voice commands. Running the sample Physical setup Find a physical space with some clearance. Place markers on the floor and walls at the same separations as the virtual markers in the scene. It's not necessary to have a physical marker for every virtual marker. It is helpful to either label the physical markers with the name of the corresponding virtual marker (e.g. \"NW\"), or draw a map with their placement labeled. App setup Build and deploy the RayPins scene to device. Running the app Startup On startup, the coordinate system is based on the head position, and the virtual grid and markers placement is arbitrary. First marker On the radio selection, pick one of the markers for which there is a corresponding physical marker in the room. Click on the physical marker in the room. The scene will shift to align the selected virtual marker to the ray hit physical marker. If the alignment is unsatisfactory, for example because of a slip at the moment of selection, simply repeat selecting, with the appropriate radio button still selected, until satisfactory alignment is achieved. Second marker Move to another physical marker in the room, and select its virtual marker in the radio selection. Click on that physical marker. The grid and markers now rotate to align with both markers aligned. More markers When near either of the first two pins placed, alignment should be quite close between the physical and virtual markers. For other markers, however, there may be significant misalignments between physical and virtual. These may arise from a number of sources, but primarily from inexact placement of physical markers, or from tracker error. Repeat the radio selection and ray hit placement of virtual markers for any further physical markers placed in the room. After this placement process, any such marker should show good alignment when near it. Verification A physical tape measure may be used to verify the interpolated alignment between markers. The grid lines are spaced one meter (1m) apart, and the lines are one centimeter (1cm) wide. Persistence Note that since AutoSave and AutoLoad are enabled on the WorldLockingContext in the RayPins scene, after aligning the content to a physical room and exiting the app, on running the application again the virtual grid and markers will resume their alignment with the physical room. To clear the alignment and start over, either select the Reset radio button, or uninstall and reinstall the application."
  },
  "DocGen/Documentation/HowTos/Samples/SpacePin.html": {
    "href": "DocGen/Documentation/HowTos/Samples/SpacePin.html",
    "title": "Space Pin Sample | World Locking Tools for Unity Documentation",
    "keywords": "Space Pin Sample The functionality demonstrated in the Space Pin example is also available in the main World Locked Physics Sample scene. However, the Space Pin scene offers a simplified and more focused view of the Space Pin feature . It is intended to be closer to the inner workings of a real world application which needs to align a large object or objects with real world features. It therefore lacks many of the options and runtime UX of the more general World Locked Physics Sample . Default settings The World Locking Tools Manager settings applied may be examined in the Unity Inspector by selecting the WorldLocking > WorldLockingManager node. In particular, note that World Locking Tools' AutoSave and AutoLoad features are enabled. Therefore, after aligning the spheres and measuring beam to real world features, as described below, then subsequent session on startup will resume that alignment automatically. To reset the sample to a clean state, uninstall it and re-deploy. There are, of course, APIs to reset to a clean slate from script, but these are omitted here for clarity. See IAlignmentManager.ClearAlignmentAnchors() . Also note that the demo enables automatic refit operations. See below . Physical space setup This sample contains 4 markers. To fully explore the sample, place physical markers in a space corresponding to the layout of the virtual markers. NOTE: The layout of the virtual markers in the Unity scene may be altered to fit any physical space. There is nothing special about the default layout. However, seeing the benefits of the Space Pinning feature requires a considerable spread of the markers, with separations of at least a few meters. The layout of the physical markers in the room should match the layout of the virtual markers in the Unity scene, as shown in this diagram: Running the Sample Startup On startup for the first session, the origin of the Unity coordinate space will be at the head pose at startup. Looking to the left and forward 6 meters will reveal a cyan sphere, with a cyan cube above it. Looking to the right and back will show a red sphere and cube, 10 meters away. Moving forward from the origin and looking back reveals a white sphere and cube. Eight meters beyond it is a yellow sphere and cube. There are also beams of alternating colors running beneath the spheres. Their purpose will become clear during the walkthrough. Aligning the world Move to any one of the colored spheres. This walk-through will start with the red sphere. Walk to the red sphere. The sphere may be grabbed from a distance using hand-rays in HL2, or gaze and pinch with HL1. On HL2, it may also be grabbed in hand. Look around and find the marker placed in the physical room corresponding to the red sphere. Grab the virtual red sphere by one of the above methods and drag it to the red sphere's marker. Further adjust the sphere to align with the physical marker as well as possible. Note that the other spheres have now moved as well. However, their orientation is unchanged. That is, the virtual world has been translated to put the red sphere on its marker, but the orientation of the world has not yet been affected. Move to another sphere. For this walk-through the white sphere will be next. Repeat the above procedure, moving the virtual white sphere to align with its physical marker. Note that now the virtual space has been rotated as well as translated, so that the red, white, and cyan spheres are still in a line, with the yellow sphere on a perpendicular offset from the white sphere. Verify that when near the white sphere, it is aligned with its physical marker. Walk to the red sphere and verify that it is aligned with its physical marker. Now walk to a remaining sphere. This walk-through will proceed to the cyan sphere. Note that while the cyan sphere is in line with the red and white spheres, it is not correctly positioned at its marker. The exact vector and magnitude of the error are device and even situation dependent, ut it is likely that it is near correctly on the red-white sphere line, but short of the physical marker. Drag the cyan sphere to its correct alignment with the physical marker. Verify, by walking to each and examining them, that each of the 3 placed markers are now correctly aligned when in each one's proximity. If desired, repeat this process for the final sphere. Alternate manipulation mode The above walk-through is based on the default configuration in the application, in which the orientation of the virtual space is implied by the relative positioning of the markers. In an alternate mode, the orientation may be explicitly set by grabbing the spheres and rotating them about the Y-axis. The default manipulation mode described above is generally much easier, because positioning of objects in virtual space tends to be much more precise than rotating them to a specific orientation. Similarly, when using QR codes for automatic alignment, the position returned for a QR code marker tends to be much more reliable than the orientation. However, some applications may have advance and specific knowledge of the desired orientation of space, which they may leverage using this second method. To enable the explicit orientation method in the demo, simply disable the active Space Pin Orientable Manipulation components on the marker spheres in: Content > Manipulation > Markers > CyanSphere/RedSphere/YellowSphere/GreySphere. and enable the currently disabled Space Pin Manipulation components. The suggested walk-through is then: Position one of the spheres aligned with its physical marker, and orient it so that the other spheres are in the correct direction from it. The other spheres will now be at incorrect distances, but along approximately the correct vector. Move to the other spheres in turn and reposition each to align with it's physical marker. No further orientation changes should be required. Examining the results If a measuring tool, such as a tape measure, is available, this alignment can be further examined. If the spheres were placed correctly, there should be zero error at each of the spheres. The T-beam running beneath the spheres alternates colors at every meter. By measuring the deviation of the color changes in the beams with the meter marks in the measuring device, the error in the areas between Space Pins may be seen. Refit operations Automatic refit operations will most probably manifest as follows: After positioning one or more of the spheres, the virtual objects are aligned as expected. Subsequently, tracking is lost. Tracking resumes after moving to another physical area. The alignment from the first spheres is lost and has no effect (because they are in a different fragment ). After moving about the new section of space (possibly positioning another sphere), the head moves back to the original space. A refit operation silently and automatically combines the original and new fragments. The alignment from the first spheres becomes effective again (because they are all in the same fragment now)."
  },
  "DocGen/Documentation/HowTos/Samples/WorldLockedPhysicsSample.html": {
    "href": "DocGen/Documentation/HowTos/Samples/WorldLockedPhysicsSample.html",
    "title": "World Locked Physics Sample. | World Locking Tools for Unity Documentation",
    "keywords": "World Locked Physics Sample. The Physics Beam Sample offers a few virtual physics experiences which are enabled by World Locking Tools' world locked coordinate system. Back story On HoloLens, the relationship between a spatial anchor and the head or other spatial anchors may change at any time as a result of incoming sensor data or even re-processing of existing data. Unity's WorldAnchors react to changes in the underlying spatial anchor's pose by dragging the attached GameObject along with it. This causes difficulties for physics simulation: Because the WorldAnchor'd GameObject's pose is explicitly set by the WorldAnchor each frame, it can't be set by simulation (e.g. momentum). Because the WorldAnchor is frequently updating its GameObject's pose, it will not appear to be at rest relative to other still RigidBodies. Because of implicit shifts of Unity's coordinate system as WorldAnchors adjust the coordinates of static Holograms to keep them fixed relative to the real world, physics computations such as routes and trajectories will be off. For example, a projectile perfectly aimed at a Hologram will still miss if the Hologram is repositioned by its WorldAnchor in between the trajectory computation and it reaching the target. When the relationships between measured spatial anchors and the visible virtual objects locked to them becomes inconsistent, then rather than adjusting the virtual objects as Unity's WorldAnchors do, World Locking Tools adjusts the head transform to minimize perceived artifacts from those inconsistencies. This allows the virtual objects to appear consistent in a stable coordinate space, eliminating the above issues. Building the sample Note that the sample requires the SpatialPerception capability. The Microphone capability is also required for voice commands. This sample requires that the following layers be added to the project's Tags & Layers: Pillared SpatialMapping Running the demo The diagnostic HUD This basic HUD is not specific to this Physics Beam Sample, but only allows runtime control of World Locking Tools' behavior to explore its capabilities. It is available as a drop-in for development on any application using World Locking Tools, as described in World Locking Tools' Initial Setup . The modes radio buttons At any given time, the sample can be in any one of the following modes: Idle - The physics sample is not currently processing input. The HUD and radio button menu, of course, continue processing inputs. Throw Dart - A trajectory is computed, based on basic physics laws, and displayed. The displayed arc shows the path a projectile fired (via select gesture) will follow. The thrown dart will follow a ballistic trajectory, bouncing off of any collision surfaces, including Spatial Reconstruction (SR) meshes, that it impacts. These Darts are \"removable\", as described below. Add Pillars - On a select gesture, a ray is cast into the world in the indicated direction. If it finds a collidable surface, a vertical pillar is added to the scene there. Every Pillar added is collidable, and can serve as a beam support, as described below. However, there are two flavors of Pillars added: If the surface the pillar is set upon is \"removable\", then the pillar is physically simulated (e.g. can be knocked over). Else the pillar collidable, but static. Effectively this means if a pillar is added on the SR mesh, it will be static, else it will be dynamic. Pillars are \"removable\". Add Beam - On first select, a ray is cast into the scene to find the first end-point of the beam. After that, as the selection ray is moved through the scene, a line is drawn from the first end-point to the current end-point. The second select gesture will create a beam stretching between the first and current end-points. Balancing the Beam with endpoints on Pillars clearly requires a space in which the endpoint Pillars will remain fixed relative to each other. Beams are \"removable\". Remove Objects - On select, if the ray cast object is \"removable\", then it is removed from the scene. Any objects being supported by the removed object will then fall. See also class PhysicsBeamSample ."
  },
  "DocGen/Documentation/HowTos/WorldLockingContext.html": {
    "href": "DocGen/Documentation/HowTos/WorldLockingContext.html",
    "title": "World Locking Tools Context and Manager settings | World Locking Tools for Unity Documentation",
    "keywords": "World Locking Tools Context and Manager settings The World Locking Tools Context allows parametric customization of the World Locking Tools Manager in the Unity Inspector. While the WorldLockingContext component presents a UI for the WorldLockingManager, it is important to understand that they are not the same thing, and in some situations it may be important to understand their relationship. The Manager is a singleton The WorldLockingManager is a singleton created on demand and persisting through the lifetime of the application. If no calls are made to the WorldLockingManager, it will never be instantiated. Once instantiated, it will remain live until the application is shut down. It is never destroyed and re-instantiated. The WorldLockingManager is not a Unity object, it is a generic C# class. Its Update is driven by a proxy Unity component, an instance of the private WorldLockingManager.UpdateProxy class. It is otherwise independent from Unity's creation/update/destruction cycles. The Context is a Unity component The WorldLockingContext is a Unity component which is added to an object in the scene in the usual manner. It's fields appear in the Unity Inspector as would any other regular Unity component's fields. While it is not an error to have multiple active WorldLockingContexts in a single scene, it is probably not desired, as the behavior would be undefined, dependent on the unknown order of object loads. The settings on a context are applied when the WorldLockingContext is loaded . Specifically, the context pushes its settings onto the World Locking Tools Manager in its OnEnable call, and any time its scene becomes the active scene. The latter is applied as part of the Unity.SceneManager.activeSceneChanged callback, if and only if the new active scene is the scene the context belongs to. All settings may be applied from script At any point in the runtime, the application may apply custom settings to the WorldLockingManager via script. If any teardown and rebuilding of resources is required to effect a change in settings, that reconstruction will take place immediately on the settings change. While there are some convenience members to get individual property values from the WorldLockingManager, for example AutoSave , setting of parameters always happens in aggregate. For example, code to toggle the AutoMerge and AutoRefreeze features might look like this: /// Get a copy of the current settings var settings = WorldLockingManager.GetInstance().Settings; /// Modify the copy settings.AutoMerge = !settings.AutoMerge; settings.AutoRefreeze = !settings.AutoRefreeze; /// Update the current settings to the values in the copy. WorldLockingManager.GetInstance().Settings = settings; Likewise for the diagnostics settings. Note that changing multiple settings at once in this way only incurs the cost of a single rebuild (if any is required). Settings precedence Rules for the settings currently applied to the WorldLockingManager are very simple: If no scene containing a context has been loaded, and no settings have been explicitly set from script, the WorldLockingManager has default settings. A setting will retain its value until it is overridden by a WorldLockingContext loading with a scene, or an explicit change invoked from the application in script. Caution should be used when mixing World Locking Tools Manager settings from contexts and settings from scripts. Since the context always applies its settings on load, a script manually applying setting during load, particularly from its OnEnable callback, will likely run into race conditions and indeterminate behavior. Available settings The available settings for controlling World Locking Tools behavior are broken into three groups as follows. Manager settings Manager settings control the runtime behavior of the World Locking Tools Manager. The fields available for modification and their implications are documented within the ManagerSettings class. Linkage settings Linkage settings are used to explicitly define the scene GameObjects whose transforms will be used to apply World Locking Tools' corrections. The \"Use Existing\" field allows the linked objects to be set once in the scene with the camera rig (with \"Use Existing\" false), and not overridden by loading subsequent content scenes (with \"Use Existing\" true). Conversely, setting \"Use Existing\" to false allows allows multiple scenes each with a different camera rig to bind to the appropriate places in the camera's hierarchy. When creating and managing the camera hierarchy from script, the \"Use Existing\" field should be set to true on all Contexts,and the linkages updated explicitly from the camera managing scripts. When the required transforms are not supplied, either left null or all Contexts have \"Use Existing\", then the system issues a warning and tries to infer good choices. It is recommended, but not required, to explicitly set the appropriate transforms, rather than having the system guess. Diagnostics settings The Diagnostics settings control the gather of diagnostics for analysis of behavior and debugging. They should normally be left with \"Use Defaults\" set, which, among other things, disables the collection of diagnostics. The diagnostics collection is a great performance drag, so should be avoided unless needed. During development, when unexpected and undesirable behavior is being seen, the diagnostics data collected by disabling Use Defaults and enabling DiagnosticsSettings.Enabled will enable the collection of data which can be instrumental in understanding and fixing that behavior. The fields available for modification are described within the DiagnosticsSettings class. Default settings Both the manager and diagnostics settings each contain a \"Use Defaults\" checkbox in the settings. The \"Use Defaults\" property is also available from script. When the \"Use Defaults\" property is true, the current default settings are used. If default values for a property change in a new release, the \"Use Defaults\" property instructs the system to use the new property value. Setting the \"Use Defaults\" property to true at any time will reset all values to their current default values. To lock the values at a snapshot of the default values at a given time, enable the \"Use Defaults\" property to reset all fields to the current defaults, then unset the checkbox to prevent them from being changed with an update. It is suggested to leave the \"Use Defaults\" set to true, except during development for experimentation and debugging. See also WorldLockingManager WorldLockingContext ManagerSettings LinkageSettings DiagnosticsSettings"
  },
  "DocGen/Documentation/IntroFAQ.html": {
    "href": "DocGen/Documentation/IntroFAQ.html",
    "title": "Frequently asked questions | World Locking Tools for Unity Documentation",
    "keywords": "Frequently asked questions Definitions used in this documentation: Pose – a position and orientation. Hologram - a visible virtual object. Real world - the physical world. Physical world - the real world. Virtual world - synthetically generated and simulated world presented via electronic media. Virtual world marker – a pose in the virtual (modeling) coordinate system. That’s it, just a reference position and orientation. Real world marker – a pose relative to the real-world environment and camera corresponding to a virtual world marker. The real-world marker’s pose is established by some combination of sensed data. Visible features - Features of the physical world that are visually recognizable. What does World Locking Tools do? Given inconsistencies between virtual and real world markers, World Locking Tools provides a stable coordinate system and camera adjustment that minimizes the visible inconsistencies. Put another way, it world-locks the entire scene with a shared pool of anchors, rather than locking each group of objects with the group's own individual anchor. Why are the virtual and real world markers inconsistent? Among the many amazing technologies behind Microsoft Mixed Reality, the ability to track the headset's pose in the physical world in real time, without the aid of external devices, is especially amazing. The head tracking system is remarkably accurate at determining the head's pose relative to known virtual reference points in the physical environment. For this discussion, those virtual reference points will be called \"visible features\". On leaving a position known relative to surrounding visible features, for instance if the user walks around the room, and then returning to that same position, the system will recognize many of those same visible features. It can also determine the poses of those visible features relative to the current head pose, and do so with surprising accuracy. Now the tracker system knows where these features and the head are relative to each other, but it doesn't know in absolute terms what the coordinates are for either head or features. As the physical world has no absolute coordinate system, there is no right answer. So the tracking system assigns coordinates that are consistent with recent history, but may be inconsistent over all history. That is, on returning to the exact same pose, the head may now have different coordinates than when it left. This is a form of sensor drift. But if the new head virtual pose coordinates have shifted toward positive X, for example, then all hologram objects that are stationary in that virtual coordinate system are now shifted toward negative X relative to the head. That means that to the observer wearing the head tracker, they will be shifted relative to the real world as compared with their placement previous to the walk. Can Unity handle this? Yes, with limitations. Unity provides an excellent mechanism for dealing with this, known as WorldAnchors. If the virtual space has shifted relative to physical space, by keeping track of underlying visible features, a WorldAnchor knows to shift itself in virtual space to remain locked in physical space. Anything attached to the WorldAnchor will likewise be dragged through Unity's virtual space to remain stationary in physical space. The limitations are related to the fact that visible features become unreliable when they are far from the head tracker's cameras. This is not surprising. Visible features that aren't visible make poor reference points. A WorldAnchor's useful range is therefore limited to 3 meters. Depending on the accuracy requirements of the application, the usable range might be less. That seems pretty good, what's the problem? It's beyond good, it's simply amazing. But there are situations, important situations, where WorldAnchors do not provide a satisfactory solution. First, each WorldAnchor moves through Unity's virtual coordinate space independently attempting to remain stationary in the physical world. This means that objects anchored independently will move relative to each other as they try to remain in their physical positions. For an application trying to maintain a precise layout, this can be a large problem. Second, with its limited range, a single WorldAnchor will not provide good results for single objects which are larger than the usable range of that WorldAnchor. While the points on the object near the WorldAnchor will remain well world-locked, because of the lever arm effect, points farther and farther from the WorldAnchor will suffer ever increasing errors. This leaves an object, or a collection of objects, larger than a meter or so without a robust world-locking solution. What else can go wrong? On returning to a previously occupied pose, World Locking Tools has enough information to restore the virtual coordinate system back where it was relative to the physical world. This keeps holograms that are stationary in the virtual world also stationary in the physical world. But drift may occur on a one way trip, as well as a round trip. As a concrete example, consider measuring 10 meters between two QR codes placed in a physical room, and therefore modeling two boxes in the virtual room as 10 meters apart. But at runtime, because of drift of the head pose in the virtual space, walking the 10 meters between the QR codes moves 11 meters through virtual space. The application may opt into a feature of World Locking Tools to address this by providing information calibrating distance in virtual space to distance in physical space. The behavior that World Locking Tools provides is that, standing over the first QR code and looking down will see the first box. As the 10 meters are walked through the physical world, the extra meter in virtual space is quietly absorbed, leaving the head moved 10 meters in virtual space as well. So on reaching the second physical QR code and looking down, the second virtual box will be there as expected. Note that corresponding adjustments will be made to all of the anchors which don’t have ground truth data, as they are passed on the path between the two QR codes. That adjustment is, of course, applied smoothly to minimize its perception. What if the real-world markers aren’t stable? Furthermore, if the real-world markers are being dynamically updated, World Locking Tools can adjust its spatial frame and camera adjustment to optimally match the current configuration. For example, on HoloLens if the real-world markers are spatial anchors, then they will drift over time. They will also move on re-establishment (e.g. loop closure), and in other circumstances. As their poses are updating, World Locking Tools compensates by adjusting the camera as before to minimize the perceived inconsistencies between the sensed spatial anchors and their virtual counterparts. Note that this compensation for updates in anchor positions can happen even in the absence of ground truth data about the markers. The implied ground truth data is that the current relationships between real-world markers is (more) correct. What if the inconsistencies get really bad? World Locking Tools can detect several scenarios in which the inconsistencies between real and virtual markers are large and can be improved upon. For example, more information may be obtained which establishes the spatial relationship between two previously isolated pools of markers. Or loop closure might suggest a shift of markers along the route to allow the endpoints to meet. In these cases, World Locking Tools notifies the client of the potential fix, and on the client's bequest performs the fix and notifies the client of adjustments it should make in its objects which track virtual markers. Until the client requests such a fix (if ever), World Locking Tools continues to minimize the perceived inconsistencies."
  },
  "DocGen/Documentation/NOTICE.html": {
    "href": "DocGen/Documentation/NOTICE.html",
    "title": "| World Locking Tools for Unity Documentation",
    "keywords": "NOTICES AND INFORMATION Do Not Translate or Localize This software incorporates material from third parties. Microsoft makes certain open source code available at http://3rdpartysource.microsoft.com , or you may send a check or money order for US $5.00, including the product name, the open source component name, and version number, to: Source Code Compliance Team Microsoft Corporation One Microsoft Way Redmond, WA 98052 USA Notwithstanding any other terms, you may reverse engineer this software to the extent required to debug changes to any libraries licensed under the GNU Lesser General Public License. Oculus Controller Images Copyright (c) Facebook Technologies, LLC and its affiliates. All rights reserved. Art Attribution License 1.0 You may use these images solely for referring to the corresponding product in your video game or VR experience (including manuals for users). Otherwise, you may not use these images, or any trademarks, logos or other intellectual property owned by Facebook Technologies, LLC formerly known as Oculus VR, LLC (“Oculus”), including but not limited to use on merchandise or other product such as clothing, hats, or mugs. Do not use the Oculus images in a way that implies a partnership, sponsorship or endorsement; or features Oculus on materials associated with pornography, illegal activities, or other materials that violate Oculus Terms. THE IMAGES ARE PROVIDED TO YOU ON AN “AS IS” BASIS AND YOU ARE SOLELY RESPONSIBLE FOR YOUR USE OF THE IMAGES. OCULUS DISCLAIMS ALL WARRANTIES REGARDING THE IMAGES, INCLUDING WARRANTIES OF NON-INFRINGEMENT. OCULUS SHALL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES ARISING FROM OR RELATED TO YOUR USE OF THE IMAGES. For the avoidance of doubt, this license shall not apply to the Oculus name, trademark or service mark, logo or design OpenVR Copyright (c) 2015 Valve Corporation. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Unity 3D Async Await Util Copyright (c) 2016 Modest Tree Media Inc Licensed under the MIT License. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Visual Profiler Copyright (c) Microsoft Corporation. All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustLocationDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustLocationDelegate.html",
    "title": "Delegate AdjustLocationDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate AdjustLocationDelegate Notification that a correction in the world locked space has been computed and should be applied to this object. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void AdjustLocationDelegate(Pose adjustment); Parameters Type Name Description Pose adjustment The adjustment to apply"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustStateDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AdjustStateDelegate.html",
    "title": "Delegate AdjustStateDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate AdjustStateDelegate Notification from the system that the state of the fragment containing the attachment point has changed. The client can take action to hide objects in disconnected space if desired. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void AdjustStateDelegate(AttachmentPointStateType state); Parameters Type Name Description AttachmentPointStateType state The new state of the containing fragment"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AlignmentManager.html",
    "title": "Class AlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Class AlignmentManager Unity level implementation of aligning Unity's coordinate system with a discrete finite set of markers in the real world. Inheritance Object AlignmentManager Implements IAlignmentManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AlignmentManager : IAlignmentManager Remarks In addition to anchoring the otherwise arbitrary WorldLocked coordinate space to this set of correspondences, this addresses the tracker-scale issue, whereby due to tracker error, traversing a known distance in the real world traverses a different distance in Unity space. This means that, given a large object of length L meters in Unity space, starting at one end and walking L meters will not end up at the other end of the object, but only within +- 10% of L. Use of this service gives fairly exact correspondence at alignment points, and by interpolation gives fairly accurate correspondence within the convex set of alignment points. Note that no extrapolation is done, so outside the convex set of alignment points results, particularly with respect to scale compensation, will be less accurate. Constructors AlignmentManager(WorldLockingManager) Constructor, binds to a specific WorldLockingManager. Also registers for scene loading events. Declaration public AlignmentManager(WorldLockingManager manager) Parameters Type Name Description WorldLockingManager manager WorldLocking manager which owns this sub-manager. Properties PinnedFromLocked The pose to insert into the camera's hierarchy above the WorldLocking Adjustment transform (if any). Declaration public Pose PinnedFromLocked { get; } Property Value Type Description Pose Methods AddAlignmentAnchor(String, Pose, Pose) Declaration public AnchorId AddAlignmentAnchor(string uniqueName, Pose virtualPose, Pose lockedPose) Parameters Type Name Description String uniqueName Pose virtualPose Pose lockedPose Returns Type Description AnchorId ClearAlignmentAnchors() Declaration public void ClearAlignmentAnchors() ComputePinnedPose(Pose) Do the weighted average of all active reference poses to get an alignment pose. Declaration public void ComputePinnedPose(Pose lockedHeadPose) Parameters Type Name Description Pose lockedHeadPose Dispose() Dispose of internals on shutdown. Declaration public void Dispose() Finalize() Dispose of internals on shutdown. Declaration protected void Finalize() GetAlignmentPose(AnchorId, out Pose) Declaration public bool GetAlignmentPose(AnchorId anchorId, out Pose lockedPose) Parameters Type Name Description AnchorId anchorId Pose lockedPose Returns Type Description Boolean Load() Load the database and issue notification if loaded. Declaration public bool Load() Returns Type Description Boolean True if loaded. RegisterForLoad(PostAlignmentLoadedDelegate) Register for notification after any successful loads. Declaration public void RegisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to call after successful load. Remarks Registration holds until a corresponding call to UnregisterForLoad(PostAlignmentLoadedDelegate) . RemoveAlignmentAnchor(AnchorId) Declaration public bool RemoveAlignmentAnchor(AnchorId anchorId) Parameters Type Name Description AnchorId anchorId Returns Type Description Boolean RestoreAlignmentAnchor(String, Pose) Declaration public AnchorId RestoreAlignmentAnchor(string uniqueName, Pose virtualPose) Parameters Type Name Description String uniqueName Pose virtualPose Returns Type Description AnchorId Save() Explicitly save the database. Declaration public bool Save() Returns Type Description Boolean True if successfully saved. Remarks The database is also implicitly saved whenever dirtied if WorldLockingManager.AutoSave is enabled. SendAlignmentAnchors() Declaration public void SendAlignmentAnchors() UnregisterForLoad(PostAlignmentLoadedDelegate) Un-register for post load notifications, after registration via RegisterForLoad(PostAlignmentLoadedDelegate) . Declaration public void UnregisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del The delegate to unregister. Implements IAlignmentManager"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.html",
    "title": "Class AnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorManager Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. Inheritance Object AnchorManager Implements IAnchorManager IDisposable Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AnchorManager : IAnchorManager, IDisposable Remarks Anchor and Edge creation algorithm: Goal: a simple and robust algorithm that guarantees an even distribution of anchors, fully connected by edges between nearest neighbors with a minimum of redundant edges For simplicity, the algorithm should be stateless between time steps Rules two parameters define spheres MIN and MAX around current position whenever MIN does not contain any anchors, a new anchor is created when a new anchor is created is is linked by edges to all anchors within MAX the MAX radius is 20cm larger than MIN radius which would require 12 m/s beyond world record sprinting speed to cover in one frame whenever MIN contains more than one anchor, the anchor closest to current position is connected to all others within MIN Constructors AnchorManager(Plugin) Set up an anchor manager. Declaration public AnchorManager(Plugin plugin) Parameters Type Name Description Plugin plugin The engine interface to update with the current anchor graph. Properties ErrorStatus Error string for last error, cleared at beginning of each update. Declaration public string ErrorStatus { get; } Property Value Type Description String NumAnchors Return the current number of spongy anchors. Declaration public int NumAnchors { get; } Property Value Type Description Int32 NumEdges Declaration public int NumEdges { get; } Property Value Type Description Int32 SpongyAnchors Declaration public List<AnchorManager.SpongyAnchorWithId> SpongyAnchors { get; } Property Value Type Description List < AnchorManager.SpongyAnchorWithId > Methods Dispose() Explicit dispose to release resources. Declaration public void Dispose() Finalize() GC release of resources. Declaration protected void Finalize() GetHeadPose() Declaration public Pose GetHeadPose() Returns Type Description Pose LoadAnchors() Load the spongy anchors from persistent storage Declaration public Task LoadAnchors() Returns Type Description Task Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. Reset() Delete all spongy anchor objects and reset internal state Declaration public void Reset() SaveAnchors() Save the spongy anchors to persistent storage Declaration public Task SaveAnchors() Returns Type Description Task Update() Create missing spongy anchors/edges and feed plugin with up-to-date input Declaration public bool Update() Returns Type Description Boolean Boolean: Has the plugin received input to provide an adjustment? Implements IAnchorManager System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.SpongyAnchorWithId.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AnchorManager.SpongyAnchorWithId.html",
    "title": "Struct AnchorManager.SpongyAnchorWithId | World Locking Tools for Unity Documentation",
    "keywords": "Struct AnchorManager.SpongyAnchorWithId Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public struct SpongyAnchorWithId Fields anchorId Declaration public AnchorId anchorId Field Value Type Description AnchorId spongyAnchor Declaration public SpongyAnchor spongyAnchor Field Value Type Description SpongyAnchor"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPoint.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPoint.html",
    "title": "Class AttachmentPoint | World Locking Tools for Unity Documentation",
    "keywords": "Class AttachmentPoint Implementation of the IAttachmentPoint interface. Provides implementations, as well as a binding to the update delegates. Inheritance Object AttachmentPoint Implements IAttachmentPoint Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class AttachmentPoint : IAttachmentPoint Constructors AttachmentPoint(AdjustLocationDelegate, AdjustStateDelegate) Constructor, sets handlers Declaration public AttachmentPoint(AdjustLocationDelegate locationHandler, AdjustStateDelegate stateHandler) Parameters Type Name Description AdjustLocationDelegate locationHandler Handler for positional adjustments, may be null. AdjustStateDelegate stateHandler Handler for connectivity adjustments, may be null. Properties AnchorId Associated anchor id Declaration public AnchorId AnchorId { get; } Property Value Type Description AnchorId CachedPosition Internal history cache. Declaration public Vector3 CachedPosition { get; set; } Property Value Type Description Vector3 FragmentId Associated fragment id Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId LocationFromAnchor Position of attachment point in anchor point's space. Declaration public Vector3 LocationFromAnchor { get; set; } Property Value Type Description Vector3 LocationHandler Handler for system positional adjustments. May be null Declaration public AdjustLocationDelegate LocationHandler { get; } Property Value Type Description AdjustLocationDelegate Name Name is auto-populated on create with something unique, but can be renamed to anything useful and convenient. It is only used as a label, so can be anything (including empty or null). Declaration public string Name { get; set; } Property Value Type Description String ObjectAdjustment Cumulative transform adjustment for object(s) bound to this attachment point. Declaration public Pose ObjectAdjustment { get; set; } Property Value Type Description Pose ObjectPosition The position of object(s) bound to this attachment point. Declaration public Vector3 ObjectPosition { get; set; } Property Value Type Description Vector3 State Current state of this attachment point. Declaration public AttachmentPointStateType State { get; set; } Property Value Type Description AttachmentPointStateType Remarks Positioning information is only valid when state is Normal. See AttachmentPointStateType StateHandler Handler for system connectivity adjustments. May be null. Declaration public AdjustStateDelegate StateHandler { get; } Property Value Type Description AdjustStateDelegate Methods HandlePoseAdjustment(Pose) Keep track of cumulative transform adjustment, and pass on to client adjustment handler (if any). Declaration public void HandlePoseAdjustment(Pose adjustment) Parameters Type Name Description Pose adjustment Remarks See ObjectAdjustment and AdjustLocationDelegate HandleStateChange(AttachmentPointStateType) If state has changed, record the new state and pass on to client handler (if any). Declaration public void HandleStateChange(AttachmentPointStateType newState) Parameters Type Name Description AttachmentPointStateType newState The state to change to. MoveTo(IAttachmentPointManager, Vector3) Notify attachment point that it has moved incrementally to a new position. Declaration public void MoveTo(IAttachmentPointManager manager, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPointManager manager The mananger Vector3 newFrozenPosition The new position Remarks This should be used for conceptually continuous motion. For discontinuous motion (i.e. teleport), use TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) . This is equivalent to MoveAttachmentPoint(IAttachmentPoint, Vector3) Set(FragmentId, Vector3, AnchorId, Vector3) Set internals of attachment point to new values. Declaration public void Set(FragmentId fragmentId, Vector3 cachedPosition, AnchorId anchorId, Vector3 locationFromAnchor) Parameters Type Name Description FragmentId fragmentId New fragment Vector3 cachedPosition Cache last position moved to. AnchorId anchorId New anchor id Vector3 locationFromAnchor New displacement from anchor TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) Notify attachment point that it has teleported to a new position. Declaration public void TeleportTo(IAttachmentPointManager manager, Vector3 newFrozenPosition, IAttachmentPoint parent) Parameters Type Name Description IAttachmentPointManager manager The manager Vector3 newFrozenPosition The new position IAttachmentPoint parent Remarks This should be used for discontinuous movement, i.e. teleporting. For continuous motion, use MoveTo(IAttachmentPointManager, Vector3) . This is equivalent to TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) Implements IAttachmentPoint"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPointStateType.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.AttachmentPointStateType.html",
    "title": "Enum AttachmentPointStateType | World Locking Tools for Unity Documentation",
    "keywords": "Enum AttachmentPointStateType The states an attachment point can be in. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public enum AttachmentPointStateType Fields Name Description Invalid Normal Pending Released Unconnected"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.html",
    "title": "Class Diagnostics | World Locking Tools for Unity Documentation",
    "keywords": "Class Diagnostics Writer of diagnostics for postmortem analysis. Inheritance Object Diagnostics Implements IDisposable Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class Diagnostics : IDisposable Fields persistentDataPath Declaration protected string persistentDataPath Field Value Type Description String serializer Declaration protected Plugin.Serializer serializer Field Value Type Description Plugin.Serializer writeQueue Declaration protected BlockingCollection<Diagnostics.Record> writeQueue Field Value Type Description BlockingCollection < Diagnostics.Record > writeTask Declaration protected Task writeTask Field Value Type Description Task Properties SharedSettings Provide access to the shared configuration. Get and set of settings is through DiagnosticsSettings Declaration public SharedDiagnosticsSettings SharedSettings { get; set; } Property Value Type Description SharedDiagnosticsSettings Methods createNextFile(DateTime) Declaration protected Stream createNextFile(DateTime time) Parameters Type Name Description DateTime time Returns Type Description Stream deleteObsoleteFiles() Declaration protected void deleteObsoleteFiles() Dispose() Free all, after possible wait for finish. Declaration public void Dispose() processWriteQueue() Declaration protected void processWriteQueue() Start(Plugin) Get set up. Declaration public void Start(Plugin plugin) Parameters Type Name Description Plugin plugin The plugin providing necessary resources Update() Use a time slice for processing any accrued data. Declaration public void Update() Implements System.IDisposable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.Record.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Diagnostics.Record.html",
    "title": "Struct Diagnostics.Record | World Locking Tools for Unity Documentation",
    "keywords": "Struct Diagnostics.Record One record (chunk) of data. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax protected struct Record Fields Data Declaration public List<byte[]> Data Field Value Type Description List < Byte []> StartNextFile If true, finish current Declaration public bool StartNextFile Field Value Type Description Boolean Time Declaration public DateTime Time Field Value Type Description DateTime"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.DiagnosticsSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.DiagnosticsSettings.html",
    "title": "Struct DiagnosticsSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct DiagnosticsSettings Client tune-able settings for the diagnostics. Set through the WorldLockingManager. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct DiagnosticsSettings Fields Enabled Diagnostics can be disabled if unneeded to reclaim any lost performance. Declaration public bool Enabled Field Value Type Description Boolean MaxKilobytesPerFile Max file size. Declaration public int MaxKilobytesPerFile Field Value Type Description Int32 MaxNumberOfFiles Limit number of auto-generated files. Declaration public int MaxNumberOfFiles Field Value Type Description Int32 StorageFileTemplate Base for auto-generated unique filename. Declaration public string StorageFileTemplate Field Value Type Description String StorageSubdirectory Folder in which to keep diagnostics. Declaration public string StorageSubdirectory Field Value Type Description String Properties UseDefaults Ignore set values and use default behavior. When set, will reset all values to defaults. Declaration public bool UseDefaults { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Declaration public DiagnosticsSettings InitToDefaults() Returns Type Description DiagnosticsSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Fragment.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Fragment.html",
    "title": "Class Fragment | World Locking Tools for Unity Documentation",
    "keywords": "Class Fragment Fragment class is a container for attachment points in the same WorldLocking Fragment. It manages their update and adjustment, including merging in the attachment points from another fragment. Inheritance Object Fragment Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class Fragment Constructors Fragment(FragmentId) Declaration public Fragment(FragmentId fragmentId) Parameters Type Name Description FragmentId fragmentId Properties FragmentId Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId State Declaration public AttachmentPointStateType State { get; } Property Value Type Description AttachmentPointStateType Methods AbsorbOtherFragment(Fragment) Absorb the contents of another fragment, emptying it. Declaration public void AbsorbOtherFragment(Fragment other) Parameters Type Name Description Fragment other The fragment to lose all its contents to this. AbsorbOtherFragment(Fragment, Pose) Absorb the contents of another fragment, emptying it, and applying an adjustment transform. Declaration public void AbsorbOtherFragment(Fragment other, Pose adjustment) Parameters Type Name Description Fragment other The fragment to lose all its contents to this. Pose adjustment Pose adjustment to apply to contents of other on transition. AddAttachmentPoint(AttachmentPoint) Add an existing attachment point to this fragment. Declaration public void AddAttachmentPoint(AttachmentPoint attachPoint) Parameters Type Name Description AttachmentPoint attachPoint Remarks The attachment point might currently belong to another fragment, if it is being moved from the other to this. Since this is only used internally, it operates directly on an AttachmentPoint rather than an interface to avoid an unnecessary downcast. AdjustAll(Plugin) Run through all attachment points, get their adjustments from the plugin and apply them. Declaration public void AdjustAll(Plugin plugin) Parameters Type Name Description Plugin plugin Remarks This must be called between plugin.Refreeze() and plugin.RefreezeFinish(). ReleaseAll() Release all resources for this fragment. Declaration public void ReleaseAll() ReleaseAttachmentPoint(IAttachmentPoint) Notify system attachment point is no longer needed. See ReleaseAttachmentPoint(IAttachmentPoint) Declaration public void ReleaseAttachmentPoint(IAttachmentPoint attachmentPoint) Parameters Type Name Description IAttachmentPoint attachmentPoint UpdateState(AttachmentPointStateType) Set the state of the contents of this fragment. Declaration public void UpdateState(AttachmentPointStateType attachmentState) Parameters Type Name Description AttachmentPointStateType attachmentState New state"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core Classes AlignmentManager Unity level implementation of aligning Unity's coordinate system with a discrete finite set of markers in the real world. AnchorManager Encapsulation of spongy world (raw input) state. Its primary duty is the creation and maintenance of the graph of (spongy) anchors built up over the space traversed by the camera. AttachmentPoint Implementation of the IAttachmentPoint interface. Provides implementations, as well as a binding to the update delegates. Diagnostics Writer of diagnostics for postmortem analysis. Fragment Fragment class is a container for attachment points in the same WorldLocking Fragment. It manages their update and adjustment, including merging in the attachment points from another fragment. Orienter The Orienter class implements IOrienter. OrienterThreeBody Derived class which supports computing implicit rotations in full 3-DOF (6-DOF w/ position). PoseExtensions Extensions for Poses to enable basic transform math. ResourceMirror Class to synchronize a list of resources with associated source data (items). SharedDiagnosticsSettings The SharedSettings boxes the Settings into a sharable reference. SharedManagerSettings Shareable (reference type) version of Settings (value struct). SpacePin Component helper for pinning the world locked space at a single reference point. SpacePinOrientable A component derived from SpacePin which differs only in that, rather than using an explicit rotation passed in, an implicit rotation is calculated based on the relative positions of all active SpacePinOrientable s. SpongyAnchor Wrapper class for Unity WorldAnchor, facilitating creation and persistence. TransformExtensions Conversion function between a pose and a transform. WorldLockingContext The central component for providing WorldLocking functionality to a scene WorldLockingManager Ultimate manager of World Locking. WorldLockingManager supplies access to the sub-managers, IAnchorManager , IFragmentManager , and IAttachmentPointManager . Structs AnchorManager.SpongyAnchorWithId Diagnostics.Record One record (chunk) of data. DiagnosticsSettings Client tune-able settings for the diagnostics. Set through the WorldLockingManager. LinkageSettings Explicitly set required Transform objects. ManagerSettings Manager settings. Orienter.WeightedRotation An object whose rotation needs to be computed, and the weight of its rotation. Interfaces IAlignmentManager Manage pinning the world-locked space to user defined coordinate frame at a discrete set of points in the world. IAnchorManager Create and persist a network of anchors around the camera as it moves around, and feed them into the plugin. IAttachmentPoint Opaque handle to an attachment point. Create one of these to enable WorldLocking to adjust an attached object as corrections to the world locked space optimization are made. IAttachmentPointManager Interface for application creation and manipulation of attachment points. In particular, the creation and release of attachment points must be conducted through the IAttachmentPointManager. IFragmentManager Interface for managing fragments. This mostly comprises the bookkeeping of managing IAttachmentPoint associations, and the intimately related application of refit operations. IOrientable Base class for a thing whose orientation can be inferred from the positions of a collection of IOrientables. IOrienter An object capable of computing self-consistent rotations for IOrientables based on their positions. Enums AttachmentPointStateType The states an attachment point can be in. Delegates AdjustLocationDelegate Notification that a correction in the world locked space has been computed and should be applied to this object. AdjustStateDelegate Notification from the system that the state of the fragment containing the attachment point has changed. The client can take action to hide objects in disconnected space if desired. PostAlignmentLoadedDelegate RefitNotificationDelegate Delegate type for notification of refit operations. ResourceMirror.CompareToResource<ItemType, ResourceType> Function to compare a source item with a resource. It should return: -1 if resource is associated with a smaller item than item. 1 if resource is associated with a larger item than item. 0 if resource is associated with item. ResourceMirror.CreateResource<ItemType, ResourceType> Callback for creating a new instance of a resource matching a specific item. This will be called for each item in Sync's currentItems list which doesn't have a matching resource in Sync's resources list. ResourceMirror.DestroyResource<ResourceType> Callback to release resources. This will be called for each resource in Sync's resource list for which there is no corresponding source data in Sync's currentItems. ResourceMirror.UpdateResource<ItemType, ResourceType> Callback to update existing resources. This will be called for each item and its associated resource in the Sync's currentItems and resources lists."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAlignmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAlignmentManager.html",
    "title": "Interface IAlignmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAlignmentManager Manage pinning the world-locked space to user defined coordinate frame at a discrete set of points in the world. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAlignmentManager Properties PinnedFromLocked The pose to insert into the camera's hierarchy above the WorldLocking Adjustment transform (if any). Declaration Pose PinnedFromLocked { get; } Property Value Type Description Pose Methods AddAlignmentAnchor(String, Pose, Pose) Add an anchor for aligning a virtual pose to a pose in real space. Declaration AnchorId AddAlignmentAnchor(string uniqueName, Pose virtualPose, Pose lockedPose) Parameters Type Name Description String uniqueName Pose virtualPose The pose in modeling space. Pose lockedPose The pose in world locked space. Returns Type Description AnchorId The id for the added anchor if successful, else AnchorId.Unknown. See remarks. Remarks This must be followed by SendAlignmentAnchors() before it will have any effect. The returned AnchorId may be stored for future manipulation of the created anchor (e.g. for individual removal in RemoveAlignmentAnchor(AnchorId) ). The system must be currently tracking to successfully add an alignment anchor. The alignment anchor will be in the current Fragment . The current fragment will be available when there is no tracking, and so this call will fail. If this call fails, indicated by a return of AnchorId.Unknown, then it should be called again on a later frame until it succeeds. ClearAlignmentAnchors() Remove all alignment anchors that have been added. More efficient than removing them individually, and doesn't require having stored their ids on creation. Declaration void ClearAlignmentAnchors() Remarks This is more efficient than removing one by one, but take care to discard all existing AnchorIds returned by AddAlignmentAnchor(String, Pose, Pose) after this call, as it will be an error to try to use any of them. Also note that this clears the Alignment Anchors staged for commit with the next SendAlignmentAnchors() , but the current ones will remain effective until the next call to SendAlignmentAnchors, which will send an empty list, unless it has been repopulated after the call to ClearAlignmentAnchors. ComputePinnedPose(Pose) Update based on new head position. Declaration void ComputePinnedPose(Pose lockedHeadPose) Parameters Type Name Description Pose lockedHeadPose Head pose in world locked space. GetAlignmentPose(AnchorId, out Pose) Get the world locked space pose associated with this alignment anchor. Declaration bool GetAlignmentPose(AnchorId anchorId, out Pose lockedPose) Parameters Type Name Description AnchorId anchorId Which anchor. Pose lockedPose Pose to fill out if alignment anchor is found. Returns Type Description Boolean True if anchor is found and lockedPose filled in, else false and lockedPose set to identity. Load() Load all persisted state required for reconstructing the current pinning. Declaration bool Load() Returns Type Description Boolean True if loaded. Remarks The state required for reconstructing the pinning is loaded, but the reconstruction does not occur. Rather, the PostAlignmentLoadedDelegate is triggered, to prompt external actors to use the RestoreAlignmentAnchor(String, Pose) API to effect the reconstruction. 👍 RegisterForLoad(PostAlignmentLoadedDelegate) Register for notification that pin data has finished loaded and is available. Declaration void RegisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to notify. Remarks The delegate should be unregistered when no longer needed, e.g. owning object is destroyed. RemoveAlignmentAnchor(AnchorId) Remove the given alignment anchor from the system. Declaration bool RemoveAlignmentAnchor(AnchorId anchorId) Parameters Type Name Description AnchorId anchorId The anchor to remove (as returned by AddAlignmentAnchor(String, Pose, Pose) Returns Type Description Boolean True if the anchor was found. RestoreAlignmentAnchor(String, Pose) Attempt to restore an alignment anchor from an earlier session. Stored alignment anchor must match in both uniqueName and virtual pose. Declaration AnchorId RestoreAlignmentAnchor(string uniqueName, Pose virtualPose) Parameters Type Name Description String uniqueName Unique name use previously to create the alignment anchor. Pose virtualPose Virtual pose to match with stored anchor pose. Returns Type Description AnchorId AnchorId of restored Alignment Anchor on success, else AnchorId.Invalid. Remarks If successful, alignment anchor is added but not sent. It must be followed by a call to SendAlignmentAnchors to take effect. Save() Save state needed to reconstruct later from persistent storage. Declaration bool Save() Returns Type Description Boolean True if saved (even if empty). SendAlignmentAnchors() Submit all accumulated alignment anchors. Declaration void SendAlignmentAnchors() Remarks All anchors previously submitted via SendAlignmentAnchors() will be cleared and replaced by the current set. SendAlignmentAnchors() submits the current set of anchors, but they will have no effect until the next Refreeze() is successfully performed. UnregisterForLoad(PostAlignmentLoadedDelegate) Unregister for notification that pin data has finished loaded and is available. Declaration void UnregisterForLoad(PostAlignmentLoadedDelegate del) Parameters Type Name Description PostAlignmentLoadedDelegate del Delegate to remove from notifications."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAnchorManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAnchorManager.html",
    "title": "Interface IAnchorManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAnchorManager Create and persist a network of anchors around the camera as it moves around, and feed them into the plugin. Inherited Members IDisposable.Dispose() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAnchorManager : IDisposable Properties ErrorStatus Error string for last error, cleared at beginning of each update. Declaration string ErrorStatus { get; } Property Value Type Description String NumAnchors Return the current number of spongy anchors. Declaration int NumAnchors { get; } Property Value Type Description Int32 Remarks The number of anchors known to AnchorManager should always be identical to the frozen anchors known to the engine. NumEdges The number of edges connecting spongy anchors. Declaration int NumEdges { get; } Property Value Type Description Int32 Methods LoadAnchors() Load the spongy anchors from persistent storage Declaration Task LoadAnchors() Returns Type Description Task Remarks The set of spongy anchors loaded by this routine is defined by the frozen anchors previously loaded into the plugin. Likewise, when a spongy anchor fails to load, this routine will delete its frozen counterpart from the plugin. Reset() Delete all spongy anchor objects and reset internal state Declaration void Reset() SaveAnchors() Save the spongy anchors to persistent storage Declaration Task SaveAnchors() Returns Type Description Task Update() Create any needed anchors/edges and update plugin Declaration bool Update() Returns Type Description Boolean Whether any anchors are active and were updated."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPoint.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPoint.html",
    "title": "Interface IAttachmentPoint | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAttachmentPoint Opaque handle to an attachment point. Create one of these to enable WorldLocking to adjust an attached object as corrections to the world locked space optimization are made. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAttachmentPoint Remarks The attachment point gives an interface for notifying the system that you have moved the attached object, and the system indicates that it has computed an adjustment for the object through the callbacks passed into the creation routine. Alternatively, polling is also supported through the State and ObjectAdjustment accessors. Properties AnchorId Associated anchor id Declaration AnchorId AnchorId { get; } Property Value Type Description AnchorId CachedPosition Internal history cache. Declaration Vector3 CachedPosition { get; } Property Value Type Description Vector3 FragmentId Associated fragment id Declaration FragmentId FragmentId { get; } Property Value Type Description FragmentId LocationFromAnchor Position of attachment point in anchor point's space. Declaration Vector3 LocationFromAnchor { get; } Property Value Type Description Vector3 Name Name is auto-populated on create with something unique, but can be renamed to anything useful and convenient. It is only used as a label, so can be anything (including empty or null). Declaration string Name { get; set; } Property Value Type Description String ObjectAdjustment Cumulative transform adjustment for object(s) bound to this attachment point. Declaration Pose ObjectAdjustment { get; } Property Value Type Description Pose ObjectPosition The position of object(s) bound to this attachment point. Declaration Vector3 ObjectPosition { get; } Property Value Type Description Vector3 State Current state of this attachment point. Declaration AttachmentPointStateType State { get; } Property Value Type Description AttachmentPointStateType Remarks Positioning information is only valid when state is Normal. See AttachmentPointStateType Methods MoveTo(IAttachmentPointManager, Vector3) Notify attachment point that it has moved incrementally to a new position. Declaration void MoveTo(IAttachmentPointManager manager, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPointManager manager The mananger Vector3 newFrozenPosition The new position Remarks This should be used for conceptually continuous motion. For discontinuous motion (i.e. teleport), use TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) . This is equivalent to MoveAttachmentPoint(IAttachmentPoint, Vector3) TeleportTo(IAttachmentPointManager, Vector3, IAttachmentPoint) Notify attachment point that it has teleported to a new position. Declaration void TeleportTo(IAttachmentPointManager manager, Vector3 newFrozenPosition, IAttachmentPoint context) Parameters Type Name Description IAttachmentPointManager manager The manager Vector3 newFrozenPosition The new position IAttachmentPoint context The context into which to teleport. Can be null. CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) Remarks This should be used for discontinuous movement, i.e. teleporting. For continuous motion, use MoveTo(IAttachmentPointManager, Vector3) . This is equivalent to TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint)"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPointManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IAttachmentPointManager.html",
    "title": "Interface IAttachmentPointManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IAttachmentPointManager Interface for application creation and manipulation of attachment points. In particular, the creation and release of attachment points must be conducted through the IAttachmentPointManager. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IAttachmentPointManager Remarks Obtain access to the attachment point manager through the WorldLockingManager. Methods CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) Create and register a new attachment point. Declaration IAttachmentPoint CreateAttachmentPoint(Vector3 frozenPosition, IAttachmentPoint context, AdjustLocationDelegate locationHandler, AdjustStateDelegate stateHandler) Parameters Type Name Description Vector3 frozenPosition The position in the frozen space at which to start the attachment point IAttachmentPoint context The optional context into which to create the attachment point (may be null) AdjustLocationDelegate locationHandler Delegate to handle Frozen World engine system adjustments to position AdjustStateDelegate stateHandler Delegate to handle Frozen World engine connectivity changes Returns Type Description IAttachmentPoint The new attachment point interface. Remarks The attachment point itself is a fairly opaque handle. Its effects are propagated to the client via the two handlers associated with it. The context interface is optional. It should be given if the new attachment point is conceptually spawned from an existing attachment point (or its target object). If null, then conceptually the new attachment point was spawned from the current camera. The attachment point itself is a fairly opaque handle. The actual adjustments are made via notifications through the two delegates passed into the creation. The locationHandler is strictly to notify of adjustments when refitting (Merge or Refreeze). The stateHandler notifies whether this attachment point is \"connected\" with the current fragment. Both handlers are optional and may be null. MoveAttachmentPoint(IAttachmentPoint, Vector3) Move (as opposed to Teleport) means that the object is meant to have traversed frozen space from its old position to the given new position on some continuous path. Declaration void MoveAttachmentPoint(IAttachmentPoint attachPointIface, Vector3 newFrozenPosition) Parameters Type Name Description IAttachmentPoint attachPointIface Vector3 newFrozenPosition The new position in frozen space Remarks Not to be used for automatic (i.e. FrozenWorld Engine instigated) moves. Use this for continuous movement through space. For discontinuous movement (i.e. teleportation), use TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) ReleaseAttachmentPoint(IAttachmentPoint) Release an attachment point for disposal. The attachment point is no longer valid after this call. This also un-registers the handlers (if any) given when it was created. Declaration void ReleaseAttachmentPoint(IAttachmentPoint attachPointIface) Parameters Type Name Description IAttachmentPoint attachPointIface The attachment point to release. Remarks In the unlikely circumstance that another attachment point has been spawned from this one but has not yet been processed (is still in the pending queue), that relationship is broken on release of this one, and when the other attachment point is finally processed, it will be as if it was created with a null context. TeleportAttachmentPoint(IAttachmentPoint, Vector3, IAttachmentPoint) Teleport (as opposed to Move) means that the object is meant to have disappeared at its old position and instantaneously reappeared at its new position in frozen space without traversing the space in between. Declaration void TeleportAttachmentPoint(IAttachmentPoint attachPointIface, Vector3 newFrozenPosition, IAttachmentPoint context) Parameters Type Name Description IAttachmentPoint attachPointIface The attachment point to teleport Vector3 newFrozenPosition The position to teleport to. IAttachmentPoint context The optional context. Remarks Use this for discontinuous movement through space (i.e. teleportation). For continuous movement, use MoveAttachmentPoint(IAttachmentPoint, Vector3) . This is equivalent to releasing the attachment point ( ReleaseAttachmentPoint(IAttachmentPoint) ) and creating it ( CreateAttachmentPoint(Vector3, IAttachmentPoint, AdjustLocationDelegate, AdjustStateDelegate) ) at the new location in the given context, except that using Teleport allows the reference to the existing attachment point to remains valid."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IFragmentManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IFragmentManager.html",
    "title": "Interface IFragmentManager | World Locking Tools for Unity Documentation",
    "keywords": "Interface IFragmentManager Interface for managing fragments. This mostly comprises the bookkeeping of managing IAttachmentPoint associations, and the intimately related application of refit operations. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IFragmentManager Properties CurrentFragmentId Get id of currently active fragment Declaration FragmentId CurrentFragmentId { get; } Property Value Type Description FragmentId FragmentIds Return a copy of the current list of fragment ids. Declaration FragmentId[] FragmentIds { get; } Property Value Type Description FragmentId [] NumFragments Current number of fragments. Declaration int NumFragments { get; } Property Value Type Description Int32 Methods ApplyActiveCurrentFragment() Notify all fragments of their current state. Declaration void ApplyActiveCurrentFragment() GetFragmentState(FragmentId) Get the current state of a given fragment. Declaration AttachmentPointStateType GetFragmentState(FragmentId id) Parameters Type Name Description FragmentId id Identifier of the fragment to query. Returns Type Description AttachmentPointStateType The state Merge() Call on the plugin to compute the merge, then apply by setting transforms and adjusting scene graph. Declaration bool Merge() Returns Type Description Boolean True for successful merge. Remarks It is unnecessary to manually merge if autoMerge is true with Update() Pause() Set all fragments unconnected during a temporary system outage, especially while tracking is lost. Declaration void Pause() Remarks Fragments to resume as they were on next update. Pause may be called multiple consecutive frames, as long as the system outage continues, but only Pause or Update should be called on a given frame. Refreeze() Manually invoke a refreeze operation on the plugin, and make all necessary adjustments in bookkeeping after. Declaration bool Refreeze() Returns Type Description Boolean True for successful refreeze. Remarks It is unnecessary to manually refreeze if autoRefreeze is true with Update() RegisterForRefitNotifications(RefitNotificationDelegate) Register a delegate for refit notifications. Declaration void RegisterForRefitNotifications(RefitNotificationDelegate del) Parameters Type Name Description RefitNotificationDelegate del The delegate to call. Reset() Clear all internal state and resources. Declaration void Reset() UnregisterForRefitNotifications(RefitNotificationDelegate) Unregister a previously registered delegate for refit notifications. Declaration void UnregisterForRefitNotifications(RefitNotificationDelegate del) Parameters Type Name Description RefitNotificationDelegate del The delegate to unregister. Update(Boolean, Boolean) Perform any pending refit operations and reconcile state accordingly. Declaration void Update(bool autoRefreeze, bool autoMerge) Parameters Type Name Description Boolean autoRefreeze True to automatically perform a refreeze if indicated by the plugin. Boolean autoMerge True to automatically perform a merge if indicated by the plugin."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrientable.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrientable.html",
    "title": "Interface IOrientable | World Locking Tools for Unity Documentation",
    "keywords": "Interface IOrientable Base class for a thing whose orientation can be inferred from the positions of a collection of IOrientables. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IOrientable Properties FragmentId What fragment the object belongs in. Objects in different fragments don't affect each other. Declaration FragmentId FragmentId { get; } Property Value Type Description FragmentId LockedPosition The desired position of the object in world locked space. Declaration Vector3 LockedPosition { get; } Property Value Type Description Vector3 ModelPosition The position of the object in Modeling space. Declaration Vector3 ModelPosition { get; } Property Value Type Description Vector3 Methods PushRotation(IAlignmentManager, Quaternion) Accept a rotation computed externally (by an IOrienter ). Declaration void PushRotation(IAlignmentManager mgr, Quaternion lockedRotation) Parameters Type Name Description IAlignmentManager mgr The Alignment Manager in charge. Quaternion lockedRotation The rotation to apply, in world locked space."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrienter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.IOrienter.html",
    "title": "Interface IOrienter | World Locking Tools for Unity Documentation",
    "keywords": "Interface IOrienter An object capable of computing self-consistent rotations for IOrientables based on their positions. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public interface IOrienter Methods Register(IOrientable) Add this orientable to the list to be both source of rotation computation, and targets to apply the computed rotation. Declaration void Register(IOrientable orientable) Parameters Type Name Description IOrientable orientable The object to start maintining the orientation of. Reorient(FragmentId, IAlignmentManager) Compute a consistent orientation for all registered IOrientables in the given fragment. Declaration void Reorient(FragmentId fragmentId, IAlignmentManager mgr) Parameters Type Name Description FragmentId fragmentId The fragment to selectively apply to. IAlignmentManager mgr The manager governing the process. Unregister(IOrientable) Stop managing orientation for this object, and release all references to it. Declaration void Unregister(IOrientable orientable) Parameters Type Name Description IOrientable orientable The object to forget."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.LinkageSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.LinkageSettings.html",
    "title": "Struct LinkageSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct LinkageSettings Explicitly set required Transform objects. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct LinkageSettings Remarks If Use Existing is not set, then null Transform objects will override the currently set Transforms. When one of the Transform objects is set to null, the system attempts to infer a reasonable choice. For complicated scenes, this inference may be incorrect. For non-trivial scenes: ** If the camera rig is loaded per scene, then a Linkage Setting (via WorldLockingContext) should be set per scene explicitly pointing into that scene's camera hierarchy. ** If the camera rig is loaded once in a shared scene, the Linkage Setting should be in that scene only, and all other Linkage Settings should set \"Use Existing\" to true. ** If the camera rig is created/managed dynamically from script, then that script should also be responsible for setting the appropriate linkages, and all LinkageSettings should specify \"Use Existing\". Fields AdjustmentFrame The transform at which to apply the camera adjustment. This can't be the camera node, as its transform is overwritten every frame with head pose data. But the camera should be an attached descendant of this node. Declaration public Transform AdjustmentFrame Field Value Type Description Transform CameraParent The camera parent node defines the \"spongy frame of reference\". All raw head based data, such as the spatial mapping, gesture events, and XR head pose data, are relative to this transform. Declaration public Transform CameraParent Field Value Type Description Transform Properties UseExisting Ignore set values keep existing linkage, and use whatever was set last. Declaration public bool UseExisting { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Init all fields to default values. Declaration public void InitToDefaults()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ManagerSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ManagerSettings.html",
    "title": "Struct ManagerSettings | World Locking Tools for Unity Documentation",
    "keywords": "Struct ManagerSettings Manager settings. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public struct ManagerSettings Fields AutoLoad Automatically load the WorldLocking state from disk from previous run at startup. Declaration public bool AutoLoad Field Value Type Description Boolean AutoMerge Automatically trigger a fragment merge whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoMerge Field Value Type Description Boolean AutoRefreeze Automatically trigger a refreeze whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoRefreeze Field Value Type Description Boolean AutoSave Periodically save the WorldLocking state to disk. Declaration public bool AutoSave Field Value Type Description Boolean Enabled Whether the WorldLocking stabilization is active or bypassed (if not Enabled). Declaration public bool Enabled Field Value Type Description Boolean Properties UseDefaults Ignore set values and use default behavior. When set, will reset all values to defaults. Declaration public bool UseDefaults { get; set; } Property Value Type Description Boolean Methods InitToDefaults() Put this into default initialized state. Declaration public ManagerSettings InitToDefaults() Returns Type Description ManagerSettings This initialized to defaults."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.html",
    "title": "Class Orienter | World Locking Tools for Unity Documentation",
    "keywords": "Class Orienter The Orienter class implements IOrienter. Inheritance Object Orienter OrienterThreeBody Implements IOrienter Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class Orienter : MonoBehaviour, IOrienter Remarks It derives from MonoBehaviour only to facilitate assigning it in the Inspector. Alternatively, it could be implemented as a singleton service. There are pros and cons in either direction. The MonoBehaviour assigned in inspector was chosen to make explicit the dependency, rather than a dependency hidden by a static get internally. Fields actives Orientables in the currently processing fragment. Declaration protected readonly List<Orienter.WeightedRotation> actives Field Value Type Description List < Orienter.WeightedRotation > Methods AverageRotation(Orienter.WeightedRotation, Orienter.WeightedRotation) Compute a new weighted rotation representing the two input weighted rotations. Declaration protected Orienter.WeightedRotation AverageRotation(Orienter.WeightedRotation accum, Orienter.WeightedRotation add) Parameters Type Name Description Orienter.WeightedRotation accum The accumulator rotation. Orienter.WeightedRotation add The rotation to add in. Returns Type Description Orienter.WeightedRotation A new aggregate weighted rotation. ComputeRotation(IOrientable, IOrientable) Compute the rotation that aligns a and b correctly in pinned space. Declaration protected virtual Orienter.WeightedRotation ComputeRotation(IOrientable a, IOrientable b) Parameters Type Name Description IOrientable a IOrientable b Returns Type Description Orienter.WeightedRotation ComputeRotations() Compute rotations by pairs, weighting by distance and averaging for each orientable. Declaration protected virtual bool ComputeRotations() Returns Type Description Boolean Register(IOrientable) Declaration public void Register(IOrientable orientable) Parameters Type Name Description IOrientable orientable Reorient(FragmentId, IAlignmentManager) Declaration public void Reorient(FragmentId fragmentId, IAlignmentManager mgr) Parameters Type Name Description FragmentId fragmentId IAlignmentManager mgr Unregister(IOrientable) Declaration public void Unregister(IOrientable orientable) Parameters Type Name Description IOrientable orientable Implements IOrienter"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.WeightedRotation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Orienter.WeightedRotation.html",
    "title": "Struct Orienter.WeightedRotation | World Locking Tools for Unity Documentation",
    "keywords": "Struct Orienter.WeightedRotation An object whose rotation needs to be computed, and the weight of its rotation. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax protected struct WeightedRotation Fields orientable Declaration public IOrientable orientable Field Value Type Description IOrientable rotation Declaration public Quaternion rotation Field Value Type Description Quaternion weight Declaration public float weight Field Value Type Description Single Properties FragmentId Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.OrienterThreeBody.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.OrienterThreeBody.html",
    "title": "Class OrienterThreeBody | World Locking Tools for Unity Documentation",
    "keywords": "Class OrienterThreeBody Derived class which supports computing implicit rotations in full 3-DOF (6-DOF w/ position). Inheritance Object Orienter OrienterThreeBody Implements IOrienter Inherited Members Orienter.actives Orienter.Register(IOrientable) Orienter.Unregister(IOrientable) Orienter.Reorient(FragmentId, IAlignmentManager) Orienter.AverageRotation(Orienter.WeightedRotation, Orienter.WeightedRotation) Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class OrienterThreeBody : Orienter, IOrienter Remarks Whereas the base Orienter class uses the simplifying assumption of only adjusting yaw, that is rotation about the gravity vector Y-axis, the OrienterThreeBody computes an arbitrary 3-DOF rotation to align modeling space with the supplied physical reference points. Since at least three non-collinear points are necessary to compute such a rotation, until they are available, it falls back on a simplified computation. To summarize: Zero points - identity transform One point - position alignment only (identity rotation) All points collinear - yaw and pitch about the line, but no roll about the line. Non-collinear - 3-DOF alignment. Methods ComputeRotation(IOrientable, IOrientable) Compute yaw and pitch to align virtual line with physical. Declaration protected override Orienter.WeightedRotation ComputeRotation(IOrientable a, IOrientable b) Parameters Type Name Description IOrientable a First point IOrientable b Second point Returns Type Description Orienter.WeightedRotation Computed rotation weighted by inverse distance between points. Overrides Orienter.ComputeRotation(IOrientable, IOrientable) ComputeRotations() Override to compute rotations unconstrained as a rotation about the gravity vector, Y-axis. Declaration protected override bool ComputeRotations() Returns Type Description Boolean True on success. Overrides Orienter.ComputeRotations() Remarks It takes at least 3 non-collinear points to imply a rotation. If there are fewer than that, this reverts back to the behavior of computing a rotation which pitches to align points but doesn't introduce roll. Implements IOrienter"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PoseExtensions.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PoseExtensions.html",
    "title": "Class PoseExtensions | World Locking Tools for Unity Documentation",
    "keywords": "Class PoseExtensions Extensions for Poses to enable basic transform math. Inheritance Object PoseExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public static class PoseExtensions Methods Inverse(Pose) Declaration public static Pose Inverse(this Pose t) Parameters Type Name Description Pose t Returns Type Description Pose Multiply(Pose, Pose) Declaration public static Pose Multiply(this Pose lhs, Pose rhs) Parameters Type Name Description Pose lhs Pose rhs Returns Type Description Pose Multiply(Pose, Vector3) Declaration public static Vector3 Multiply(this Pose pose, Vector3 position) Parameters Type Name Description Pose pose Vector3 position Returns Type Description Vector3"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PostAlignmentLoadedDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.PostAlignmentLoadedDelegate.html",
    "title": "Delegate PostAlignmentLoadedDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate PostAlignmentLoadedDelegate Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void PostAlignmentLoadedDelegate();"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.RefitNotificationDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.RefitNotificationDelegate.html",
    "title": "Delegate RefitNotificationDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate RefitNotificationDelegate Delegate type for notification of refit operations. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void RefitNotificationDelegate(FragmentId mergedId, FragmentId[] absorbedIds); Parameters Type Name Description FragmentId mergedId The fragment id of the target merged fragment. FragmentId [] absorbedIds Fragment ids of all affected fragments. Remarks In the case of a merge operation, absorbedIds will contain all and only the ids of the fragments that were merged into mergedId, but not including mergedId. In the case of a refreeze operation, absorbedIds will also contain mergedId."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CompareToResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CompareToResource-2.html",
    "title": "Delegate ResourceMirror.CompareToResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.CompareToResource<ItemType, ResourceType> Function to compare a source item with a resource. It should return: -1 if resource is associated with a smaller item than item. 1 if resource is associated with a larger item than item. 0 if resource is associated with item. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate int CompareToResource<ItemType, ResourceType>(ItemType item, ResourceType resource); Parameters Type Name Description ItemType item Instance of source data. ResourceType resource Instance of resource. Returns Type Description Int32 Type Parameters Name Description ItemType Type of source data. ResourceType Type of managed resource. Remarks Note that \"smaller\" and \"larger\" above must have the identical meaning to the comparison the lists input into Sync are sorted by."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CreateResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.CreateResource-2.html",
    "title": "Delegate ResourceMirror.CreateResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.CreateResource<ItemType, ResourceType> Callback for creating a new instance of a resource matching a specific item. This will be called for each item in Sync's currentItems list which doesn't have a matching resource in Sync's resources list. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate bool CreateResource<ItemType, ResourceType>(ItemType item, out ResourceType resource); Parameters Type Name Description ItemType item The source item to create a new resource for. ResourceType resource out param for created resource. Returns Type Description Boolean Returns true if a resource was created successfully. Type Parameters Name Description ItemType Type of the source data. ResourceType Type of the resources to be managed. Remarks Note that it is not an error to return false, it only means that for any reason the resource was not created. However, if the resource is not created, then in the next call to Sync, it will be noted that the item doesn't have a matching resource and the create call will be made again. To prevent fruitless and possibly expensive create calls, the offending item should be removed from the items list passed into Sync. As noted below, all additions and removals from the items list must happen outside the Sync call."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.DestroyResource-1.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.DestroyResource-1.html",
    "title": "Delegate ResourceMirror.DestroyResource<ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.DestroyResource<ResourceType> Callback to release resources. This will be called for each resource in Sync's resource list for which there is no corresponding source data in Sync's currentItems. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void DestroyResource<ResourceType>(ResourceType resource); Parameters Type Name Description ResourceType resource The resource instance to destroy. Type Parameters Name Description ResourceType Type of the resource to destroy."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.html",
    "title": "Class ResourceMirror | World Locking Tools for Unity Documentation",
    "keywords": "Class ResourceMirror Class to synchronize a list of resources with associated source data (items). Inheritance Object ResourceMirror Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class ResourceMirror Methods Sync<ItemType, ResourceType>(IReadOnlyList<ItemType>, List<ResourceType>, ResourceMirror.CompareToResource<ItemType, ResourceType>, ResourceMirror.CreateResource<ItemType, ResourceType>, ResourceMirror.UpdateResource<ItemType, ResourceType>, ResourceMirror.DestroyResource<ResourceType>) Given a sorted list of source data items (currentItems), and a sorted list of resources: For each source item that doesn't have a matching resource, attempt to create a resource. For each resource that doesn't have a matching source item, destroy that resource. For each source item with a matching resource, update the resource. Declaration public static void Sync<ItemType, ResourceType>(IReadOnlyList<ItemType> currentItems, List<ResourceType> resources, ResourceMirror.CompareToResource<ItemType, ResourceType> compareIds, ResourceMirror.CreateResource<ItemType, ResourceType> creator, ResourceMirror.UpdateResource<ItemType, ResourceType> updater, ResourceMirror.DestroyResource<ResourceType> destroyer) Parameters Type Name Description IReadOnlyList <ItemType> currentItems List of current source items. List <ResourceType> resources List of resources to by synced to currentItems. ResourceMirror.CompareToResource <ItemType, ResourceType> compareIds Function to compare an item with a resource. See above. ResourceMirror.CreateResource <ItemType, ResourceType> creator Callback to create a missing resource. See above. ResourceMirror.UpdateResource <ItemType, ResourceType> updater Callback to update an existing resource. See above. ResourceMirror.DestroyResource <ResourceType> destroyer Callback to destroy a resource which no longer has a matching source item. Type Parameters Name Description ItemType Type of source items. ResourceType Type of resources. Remarks After this Sync, the list of resources will have exactly one resource for each item in currentItems, and currentItems and resources will be the same length. The exception is if the creator function returns false for any item(s), then those item(s) will not have matching resources, and resources will be shorter than currentItems. In any case, resources will remain sorted. Sync completes in a single pass over the data, so in O(max(currentItems.Count, resources.Count)) time."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.UpdateResource-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirror.UpdateResource-2.html",
    "title": "Delegate ResourceMirror.UpdateResource<ItemType, ResourceType> | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ResourceMirror.UpdateResource<ItemType, ResourceType> Callback to update existing resources. This will be called for each item and its associated resource in the Sync's currentItems and resources lists. Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public delegate void UpdateResource<ItemType, ResourceType>(ItemType item, ResourceType resource); Parameters Type Name Description ItemType item The source item. ResourceType resource The associated resource. Type Parameters Name Description ItemType Type of the source data. ResourceType Type of the managed resources. Remarks Only one of create/update/destroy will be called for a given item/resource pair during a single Sync."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper Structs IdPair<IdType, T> Helper pair for keeping track of things by ID."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.IdPair-2.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper.IdPair-2.html",
    "title": "Struct IdPair<IdType, T> | World Locking Tools for Unity Documentation",
    "keywords": "Struct IdPair<IdType, T> Helper pair for keeping track of things by ID. Inherited Members ValueType.Equals(Object) ValueType.GetHashCode() ValueType.ToString() Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetType() Namespace : Microsoft.MixedReality.WorldLocking.Core.ResourceMirrorHelper Assembly : cs.temp.dll.dll Syntax public struct IdPair<IdType, T> Type Parameters Name Description IdType Type of the identifier. T Type of the data associated with the identifier. Remarks The IdType is typically an AnchorId, but any type using the Comparer.Default.Compare is fine. Note this is independent of the ResourceMirror, and currently only used to internally for resources identified by anchorId, and to expedite tests. Fields id Identifier field. Declaration public IdType id Field Value Type Description IdType target Data associated with identifier. Declaration public T target Field Value Type Description T Methods CompareById(IdPair<IdType, T>, IdPair<IdType, T>) Convenience comparison function comparing by identifier (ignoring associated data). Declaration public static int CompareById(IdPair<IdType, T> lhs, IdPair<IdType, T> rhs) Parameters Type Name Description IdPair <IdType, T> lhs The left hand side. IdPair <IdType, T> rhs The right hand side. Returns Type Description Int32 If lhs GT rhs then -1 else if lhs LT rhs then 1 else 0"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedDiagnosticsSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedDiagnosticsSettings.html",
    "title": "Class SharedDiagnosticsSettings | World Locking Tools for Unity Documentation",
    "keywords": "Class SharedDiagnosticsSettings The SharedSettings boxes the Settings into a sharable reference. Inheritance Object SharedDiagnosticsSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class SharedDiagnosticsSettings Constructors SharedDiagnosticsSettings() Declaration public SharedDiagnosticsSettings() Fields settings Declaration public DiagnosticsSettings settings Field Value Type Description DiagnosticsSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedManagerSettings.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SharedManagerSettings.html",
    "title": "Class SharedManagerSettings | World Locking Tools for Unity Documentation",
    "keywords": "Class SharedManagerSettings Shareable (reference type) version of Settings (value struct). Inheritance Object SharedManagerSettings Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax [Serializable] public class SharedManagerSettings Constructors SharedManagerSettings() Wrap a copy of settings initialized to default values. Declaration public SharedManagerSettings() Fields linkageSettings Transform links to be shared. Declaration public LinkageSettings linkageSettings Field Value Type Description LinkageSettings settings The manager settings to be shared. Declaration public ManagerSettings settings Field Value Type Description ManagerSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePin.html",
    "title": "Class SpacePin | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePin Component helper for pinning the world locked space at a single reference point. Inheritance Object SpacePin SpacePinOrientable Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpacePin : MonoBehaviour Remarks This component captures the initial pose of its gameObject, and then a second pose. It then adds that pair to the WorldLocking Alignment Manager. The manager then negotiates between all such added pins, based on the current head pose, to generate a frame-to-frame mapping aligning the Frozen Space, i.e. Unity's Global Space, such that the pins match up as well as possible. Another way to phrase this is: Given an arbitrary pose (the \"modeling pose\"), and a pose aligned somehow to the real world (the \"world locked pose\"), apply a correction to the camera such that a virtual object with coordinates of the modeling pose will appear overlaid on the real world at the position and orientation described by the locked pose. For this component, the locked pose must come in via one of the following three APIs: SetFrozenPose(Pose) with input pose in Frozen Space, which includes pinning. SetSpongyPose(Pose) with input pose in Spongy Space, which is the space of the camera's parent, and is the same space the camera moves in, and that native APIs return values in (e.g. XR). SetLockedPose(Pose) with input pose in Locked Space, which is the space stabilized by the Frozen World engine DLL but excluding pinning. Note that since the Frozen Space is shifted by the AlignmentManager, calling SetFrozenPose(p) with the same Pose p twice is probably an error, since the Pose p would refer to different a location after the first call. Properties AnchorId This wrapper for the anchorId is because the anchorId has to be stored as a ulong, which is the base class for the AnchorId enum. Unity only supports int-based enums, so will complain on serialization etc. for the ulong based AnchorId. Declaration public AnchorId AnchorId { get; } Property Value Type Description AnchorId AnchorName Provide a unique anchor name. This is used for persistence. Declaration protected virtual string AnchorName { get; } Property Value Type Description String FragmentId Id for fragment this pin belongs in. Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId InitialPose Pose at startup. Declaration protected Pose InitialPose { get; } Property Value Type Description Pose LockedPose Accessor for world locked pose for derived classes. Declaration public Pose LockedPose { get; protected set; } Property Value Type Description Pose Manager Read only access to manager dependency from derived classes. Declaration protected WorldLockingManager Manager { get; } Property Value Type Description WorldLockingManager ModelingPose First of the pair of poses submitted to alignment manager for alignment. Declaration public virtual Pose ModelingPose { get; } Property Value Type Description Pose PinActive Whether this space pin is in active use pinning space Declaration public bool PinActive { get; } Property Value Type Description Boolean Methods ForceAttachment() Ensure that there is an attachment, and it is positioned up to date. Declaration protected void ForceAttachment() OnDestroy() On destroy, unregister for the loaded event. Declaration protected virtual void OnDestroy() OnLocationUpdate(Pose) Callback for refit operations. Apply adjustment transform to locked pose. Declaration protected virtual void OnLocationUpdate(Pose adjustment) Parameters Type Name Description Pose adjustment Adjustment to apply. PushAlignmentData(IAlignmentManager) Communicate the data from this point to the alignment manager. Declaration protected void PushAlignmentData(IAlignmentManager mgr) Parameters Type Name Description IAlignmentManager mgr ReleaseAttachment() Dispose of any previously created attachment point. Declaration protected void ReleaseAttachment() Reset() Go back to initial state, including removal of self-artifacts from alignment manager. Declaration public virtual void Reset() ResetModelingPose() Reset the modeling pose to the current transform. Declaration public void ResetModelingPose() Remarks In normal usage, the modeling pose is the transform as set in Unity and as cached at start. In some circumstances, such as creation of pins from script, it may be convenient to set the transform after Start(). In this case, the change of transform should be recorded by a call to ResetModelingPose(). This must happen before the modeling pose is used implicitly by a call to set the virtual pose, via SetFrozenPose, SetSpongyPose, or SetLockedPose. RestoreOnLoad() Callback on notification of the alignment manager's database to check if this preset has been persisted, and restore it to operation if it has. Declaration protected virtual void RestoreOnLoad() SendAlignmentData(IAlignmentManager) Notify the manager that all necessary updates have been submitted and are ready for processing. Declaration protected void SendAlignmentData(IAlignmentManager mgr) Parameters Type Name Description IAlignmentManager mgr SetFrozenPose(Pose) Transform pose to Locked Space and pass through. Declaration public void SetFrozenPose(Pose frozenPose) Parameters Type Name Description Pose frozenPose Pose in frozen space. SetLockedPose(Pose) Record the locked pose and push data to the manager. Declaration public virtual void SetLockedPose(Pose lockedPose) Parameters Type Name Description Pose lockedPose SetSpongyPose(Pose) Transform pose to Locked Space and pass through. Declaration public void SetSpongyPose(Pose spongyPose) Parameters Type Name Description Pose spongyPose Pose in spongy space. Start() Declaration protected virtual void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePinOrientable.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpacePinOrientable.html",
    "title": "Class SpacePinOrientable | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinOrientable A component derived from SpacePin which differs only in that, rather than using an explicit rotation passed in, an implicit rotation is calculated based on the relative positions of all active SpacePinOrientable s. Inheritance Object SpacePin SpacePinOrientable Implements IOrientable Inherited Members SpacePin.Manager SpacePin.AnchorId SpacePin.AnchorName SpacePin.PinActive SpacePin.InitialPose SpacePin.LockedPose SpacePin.OnDestroy() SpacePin.SetFrozenPose(Pose) SpacePin.SetSpongyPose(Pose) SpacePin.ResetModelingPose() SpacePin.ForceAttachment() SpacePin.ReleaseAttachment() SpacePin.PushAlignmentData(IAlignmentManager) SpacePin.SendAlignmentData(IAlignmentManager) Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpacePinOrientable : SpacePin, IOrientable Remarks The implementation of IOrientable allows it to provide an input position and receive an output rotation from the managing IOrienter . Properties FragmentId The fragment this belongs to. Public property to satisfy IOrientable interface. Declaration public FragmentId FragmentId { get; } Property Value Type Description FragmentId Remarks Only elements within the same fragment are allowed to interact with each other, because by definition the relationship between coordinates of elements of differing fragments are undefined. LockedPosition The position in locked space. Declaration public Vector3 LockedPosition { get; } Property Value Type Description Vector3 ModelingPose The modeling (virtual) space pose for this pin. Declaration public override Pose ModelingPose { get; } Property Value Type Description Pose Overrides SpacePin.ModelingPose Remarks The rotation here is nulled because an explicit target rotation is computed which includes the initial rotation. Also having the initial rotation input as part of the modeling pose would apply that rotation twice. It would also be possible to leave this rotation as is and factor it out of the computed rotation with some additional math. ModelPosition The position in modeling space. Declaration public Vector3 ModelPosition { get; } Property Value Type Description Vector3 Orienter Input dependency of the managing Orienter which will arbitrate individual rotations. Declaration public IOrienter Orienter { get; set; } Property Value Type Description IOrienter Remarks Access to the orienter is strictly by interface IOrienter. The type of the orienter member is Orienter to allow it to be set explicitly in the Inspector (see notes in Orienter ), but any object implementing IOrienter can be used by explicit setting through SetOrienter(IOrienter) . Methods OnLocationUpdate(Pose) Callback for refit operations. Declaration protected override void OnLocationUpdate(Pose adjustment) Parameters Type Name Description Pose adjustment Adjustment transform to apply. Overrides SpacePin.OnLocationUpdate(Pose) Remarks Note that the FragmentId may change here. PushRotation(IAlignmentManager, Quaternion) Accept the rotation as computed by the IOrienter. Declaration public void PushRotation(IAlignmentManager mgr, Quaternion lockedRotation) Parameters Type Name Description IAlignmentManager mgr The alignment manager which needs to receive the updated Pose. Quaternion lockedRotation The new world locked rotation to adopt. Reset() Reset and unregister from the IOrienter. Declaration public override void Reset() Overrides SpacePin.Reset() RestoreOnLoad() If base restore on load succeeds, register with orienter for further manipulation. Declaration protected override void RestoreOnLoad() Overrides SpacePin.RestoreOnLoad() SetFrozenPosition(Vector3) Set the position in frozen space. Rotation not needed since it is computed based on relative positions. Declaration public void SetFrozenPosition(Vector3 frozenPosition) Parameters Type Name Description Vector3 frozenPosition Position in frozen space. SetLockedPose(Pose) Override of base SetLockedPose to allow insertion of the computation of rotation. Declaration public override void SetLockedPose(Pose lockedPose) Parameters Type Name Description Pose lockedPose The new pose in world locked space. Overrides SpacePin.SetLockedPose(Pose) Remarks Note that base class implementation is not invoked here, but rather this override performs the same steps but with additional computations (for the rotation) interleaved. SetLockedPosition(Vector3) Set the position in world locked space. Rotation not needed since it is computed based on relative positions. Declaration public void SetLockedPosition(Vector3 lockedPosition) Parameters Type Name Description Vector3 lockedPosition Position in locked space. SetOrienter(IOrienter) Explicitly set the managing IOrienter, overriding any setting from the Inspector. Declaration public void SetOrienter(IOrienter iorienter) Parameters Type Name Description IOrienter iorienter Remarks The Orienter is nominally a completely internal artifact. The public setter is to allow construction from script. SetSpongyPosition(Vector3) Set the position in spongy space. Rotation not needed since it is computed based on relative positions. Declaration public void SetSpongyPosition(Vector3 spongyPosition) Parameters Type Name Description Vector3 spongyPosition Position in spongyt space. Start() Adopt the Inspector set Orienter as the interface iorienter. Declaration protected override void Start() Overrides SpacePin.Start() Implements IOrientable"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchor.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.SpongyAnchor.html",
    "title": "Class SpongyAnchor | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchor Wrapper class for Unity WorldAnchor, facilitating creation and persistence. Inheritance Object SpongyAnchor Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class SpongyAnchor : MonoBehaviour Fields TrackingStartDelayTime Timeout that protects against SpatialAnchor easing Declaration public static readonly float TrackingStartDelayTime Field Value Type Description Single Properties isLocated Returns true if the anchor is reliably located. False might mean loss of tracking or not fully initialized. Declaration public bool isLocated { get; } Property Value Type Description Boolean"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.TransformExtensions.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.TransformExtensions.html",
    "title": "Class TransformExtensions | World Locking Tools for Unity Documentation",
    "keywords": "Class TransformExtensions Conversion function between a pose and a transform. Inheritance Object TransformExtensions Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public static class TransformExtensions Methods GetGlobalPose(Transform) Declaration public static Pose GetGlobalPose(this Transform transform) Parameters Type Name Description Transform transform Returns Type Description Pose GetLocalPose(Transform) Declaration public static Pose GetLocalPose(this Transform transform) Parameters Type Name Description Transform transform Returns Type Description Pose SetGlobalPose(Transform, Pose) Declaration public static void SetGlobalPose(this Transform transform, Pose pose) Parameters Type Name Description Transform transform Pose pose SetLocalPose(Transform, Pose) Declaration public static void SetLocalPose(this Transform transform, Pose pose) Parameters Type Name Description Transform transform Pose pose"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Core.Triangulator | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Core.Triangulator Classes Interpolant Container for three indices and a weight for each index, everything needed to interpolate between the data associated with each index, except for the data itself. SimpleTriangulator Basic implementation of ITriangulator. Not optimized. Interfaces ITriangulator Very simple interface for triangulator, to avoid building complex dependencies."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.Interpolant.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.Interpolant.html",
    "title": "Class Interpolant | World Locking Tools for Unity Documentation",
    "keywords": "Class Interpolant Container for three indices and a weight for each index, everything needed to interpolate between the data associated with each index, except for the data itself. Inheritance Object Interpolant Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public class Interpolant Remarks This could be generalized to have N-indices and weights instead, for example to represent interpolation along an edge, or exact hit on a single index, or even weighted averages of N-polygons. Fields idx Three indices. Declaration public readonly int[] idx Field Value Type Description Int32 [] weights Three weights. Declaration public readonly float[] weights Field Value Type Description Single [] Properties IsInterior True if this represents a true interpolation (rather than an extrapolation). Declaration public bool IsInterior { get; } Property Value Type Description Boolean"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.ITriangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.ITriangulator.html",
    "title": "Interface ITriangulator | World Locking Tools for Unity Documentation",
    "keywords": "Interface ITriangulator Very simple interface for triangulator, to avoid building complex dependencies. Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public interface ITriangulator Methods Add(Vector3[]) Add vertices. Declaration bool Add(Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The vertices to add. Returns Type Description Boolean True on success. Clear() Clear out all vertices added so far. Declaration void Clear() Find(Vector3) Find the interpolant for the given query position. Declaration Interpolant Find(Vector3 pos) Parameters Type Name Description Vector3 pos The query positon. Returns Type Description Interpolant An interpolant if found, else null. Remarks Note that one or more weights may be zero, but otherwise all indices returned will be valid. But while the data behind a vertex with weight zero may be referenced (as the index is valid), it is otherwise meaningless. The return value of null only happens if no vertices have been added to be interpolated. SetBounds(Vector3, Vector3) Set the bounds of vertices to be triangulated. All vertices entered in Add() should be inside the quad formed by these bounds. Declaration void SetBounds(Vector3 minPos, Vector3 maxPos) Parameters Type Name Description Vector3 minPos The minimum coordinates of the bounds. Vector3 maxPos The maximum coordinates of the bounds. Remarks The vertical coordinate Y is ignored. Note that queries outsde the bounds are okay, only all vertices must be contained."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.SimpleTriangulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.Triangulator.SimpleTriangulator.html",
    "title": "Class SimpleTriangulator | World Locking Tools for Unity Documentation",
    "keywords": "Class SimpleTriangulator Basic implementation of ITriangulator. Not optimized. Inheritance Object SimpleTriangulator Implements ITriangulator Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core.Triangulator Assembly : cs.temp.dll.dll Syntax public class SimpleTriangulator : ITriangulator Remarks This has been written for simplicity for triangulating a small number of vertices. It lacks optimizations such as a full Delaunay triangulation on setup or hierarchical search (e.g. quadtree) on search. Methods Add(Vector3[]) Add vertices to further triangulate. Declaration public bool Add(Vector3[] vertices) Parameters Type Name Description Vector3 [] vertices The new vertices to add. Returns Type Description Boolean True on success. Remarks Bounds should already be set. Also, the bounds should be big enough to contain all vertices being added. Clear() Reset to original state, discarding all. Declaration public void Clear() Remarks Note this discards the bounds as well, so they must be set again after each clear. Find(Vector3) Declaration public Interpolant Find(Vector3 pos) Parameters Type Name Description Vector3 pos Returns Type Description Interpolant SetBounds(Vector3, Vector3) Declaration public void SetBounds(Vector3 minPos, Vector3 maxPos) Parameters Type Name Description Vector3 minPos Vector3 maxPos Implements ITriangulator"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingContext.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingContext.html",
    "title": "Class WorldLockingContext | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldLockingContext The central component for providing WorldLocking functionality to a scene Inheritance Object WorldLockingContext Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class WorldLockingContext : MonoBehaviour Remarks This component must be placed on a single GameObject in the scene. Typically, this would be a dedicated root GameObject with identity transform. Properties DiagnosticsSettings Diagnostics settings. These are shared with the manager when active. Changes from script should be made through the manager's interface, but will be visible here in inspector. Declaration public SharedDiagnosticsSettings DiagnosticsSettings { get; } Property Value Type Description SharedDiagnosticsSettings SharedSettings WorldLocking settings. These are shared with the manager when active. Changes from script should be made through the manager's interface, but will be visible here in inspector. Declaration public SharedManagerSettings SharedSettings { get; } Property Value Type Description SharedManagerSettings"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingManager.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Core.WorldLockingManager.html",
    "title": "Class WorldLockingManager | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldLockingManager Ultimate manager of World Locking. WorldLockingManager supplies access to the sub-managers, IAnchorManager , IFragmentManager , and IAttachmentPointManager . Inheritance Object WorldLockingManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Core Assembly : cs.temp.dll.dll Syntax public class WorldLockingManager Fields Plugin Direct interface to the plugin. It is not generally necessary or desired to directly manipulate the plugin, but may be useful for manual override of some plugin inputs, outputs, or controls. Declaration public readonly Plugin Plugin Field Value Type Description Plugin Properties AdjustmentFrame The transform at which to apply the camera adjustment. This can't be the camera node, as its transform is overwritten every frame with head pose data. But the camera should be an attached descendant of this node. Declaration public Transform AdjustmentFrame { get; set; } Property Value Type Description Transform AlignmentManager Declaration public IAlignmentManager AlignmentManager { get; } Property Value Type Description IAlignmentManager AnchorManager Interface to the Anchor Manager. Declaration public IAnchorManager AnchorManager { get; } Property Value Type Description IAnchorManager AttachmentPointManager Interface to the attachment point manager. Use for creating and manipulating attachment points. Declaration public IAttachmentPointManager AttachmentPointManager { get; } Property Value Type Description IAttachmentPointManager AutoLoad Automatically load the WorldLocking state from disk at startup. Declaration public bool AutoLoad { get; } Property Value Type Description Boolean AutoMerge Automatically trigger a fragment merge whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoMerge { get; } Property Value Type Description Boolean AutoRefreeze Automatically trigger a refreeze whenever the FrozenWorld engine indicates that one would be appropriate. Declaration public bool AutoRefreeze { get; } Property Value Type Description Boolean AutoSave Periodically save the WorldLocking state to disk. Declaration public bool AutoSave { get; } Property Value Type Description Boolean CameraFromSpongy Inverse of the camera transform (camera from parent). Declaration public Pose CameraFromSpongy { get; } Property Value Type Description Pose CameraParent The camera parent node defines the \"spongy frame of reference\". All raw head based data, such as the spatial mapping, gesture events, and XR head pose data, are relative to this transform. Declaration public Transform CameraParent { get; set; } Property Value Type Description Transform DiagnosticsSettings Get a copy of the shared diagnostics configuration settings, or set the shared settings to a copy of the input. Declaration public DiagnosticsSettings DiagnosticsSettings { get; set; } Property Value Type Description DiagnosticsSettings Enabled Whether the system is currently active and stabilizing space. Declaration public bool Enabled { get; } Property Value Type Description Boolean ErrorStatus The current error status of the WorldLockingManager Declaration public string ErrorStatus { get; } Property Value Type Description String FragmentManager Interface to the fragment manager. Declaration public IFragmentManager FragmentManager { get; } Property Value Type Description IFragmentManager FrozenFromLocked Declaration public Pose FrozenFromLocked { get; } Property Value Type Description Pose FrozenFromPinned Any application applied transform above the adjustment node. Declaration public Pose FrozenFromPinned { get; } Property Value Type Description Pose FrozenFromSpongy Transform from spongy space to frozen space. Spongy space is that native to XR interfaces. Frozen is Unity's global coordinate space. Transform includes the WorldLocking adjustment to the camera, as well as any other transforms applied to the camera (e.g. teleport). Declaration public Pose FrozenFromSpongy { get; } Property Value Type Description Pose LockedFromFrozen Declaration public Pose LockedFromFrozen { get; } Property Value Type Description Pose LockedFromPinned From pinned space back to the world-locked space. Declaration public Pose LockedFromPinned { get; } Property Value Type Description Pose LockedFromPlayspace Adjustment transform to world-lock the coordinate space. Declaration public Pose LockedFromPlayspace { get; set; } Property Value Type Description Pose LockedFromSpongy Declaration public Pose LockedFromSpongy { get; } Property Value Type Description Pose MergeIndicated Indicator for the FrozenWorld engine internal heuristics of whether a merge should be performed Declaration public bool MergeIndicated { get; } Property Value Type Description Boolean PinnedFromFrozen Transform from application's frozen space back to space computed by WorldLocking. Declaration public Pose PinnedFromFrozen { get; } Property Value Type Description Pose PinnedFromLocked Transform from the world locked space computed by WorldLocking to the space pinned in place. Declaration public Pose PinnedFromLocked { get; set; } Property Value Type Description Pose PlayspaceFromLocked Inverse of adjustment transform to world-lock the coordinate space. Declaration public Pose PlayspaceFromLocked { get; } Property Value Type Description Pose PlayspaceFromSpongy Transform applied by (optional) camera parent node (e.g. for teleport). Declaration public Pose PlayspaceFromSpongy { get; } Property Value Type Description Pose RefreezeIndicated Indicator for the FrozenWorld engine internal heuristics of whether a refreeze should be performed Declaration public bool RefreezeIndicated { get; } Property Value Type Description Boolean Settings The configuration settings may only be set as a block. Get returns a snapshot of current settings, and set copies entire block. Declaration public ManagerSettings Settings { get; set; } Property Value Type Description ManagerSettings Remarks To change an individual field in the settings, retrieve the entire settings block, change the desired field(s), then set the entire block. E.g. var settings = mgr.Settings; settings.AutoLoad = false; settings.AutoSave = true; mgr.Settings = settings; SpongyFromCamera The camera transform (parent from camera). Declaration public Pose SpongyFromCamera { get; set; } Property Value Type Description Pose SpongyFromFrozen Transform from frozen space to XR native spongy space, including other transforms accumulated in the camera's ancestors (e.g. teleport). Declaration public Pose SpongyFromFrozen { get; } Property Value Type Description Pose SpongyFromLocked Declaration public Pose SpongyFromLocked { get; } Property Value Type Description Pose SpongyFromPlayspace Inverse of transform applied by (optional) camera parent node (e.g. for teleport). Declaration public Pose SpongyFromPlayspace { get; } Property Value Type Description Pose Version The version of this release. This will be displayed in the WorldLockingContext component in the Unity Inspector, allowing quick visual verification of the version of World Locking Tools for Unity currently installed. It has no effect in code, but serves only as a label. Declaration public static string Version { get; } Property Value Type Description String Methods Dispose() Dispose of internals on shutdown. Declaration public void Dispose() Finalize() Dispose of internals on shutdown. Declaration protected void Finalize() GetInstance() Get the WorldLockingManager instance. This may be called at any time in program execution, but if called during load its settings may not have been loaded from a new scene yet. Declaration public static WorldLockingManager GetInstance() Returns Type Description WorldLockingManager The WorldLockingManager Load() Manually trigger a load operation for the WorldLocking state Declaration public void Load() Reset() Bring WorldLocking to a well-defined, empty state Declaration public void Reset() Save() Manually trigger a save operation for the WorldLocking state Declaration public void Save() SetContext(WorldLockingContext) Start using shared settings from given context. Declaration public void SetContext(WorldLockingContext context) Parameters Type Name Description WorldLockingContext context The context supplying the new shared settings."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.AlignmentControl.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.AlignmentControl.html",
    "title": "Class AlignmentControl | World Locking Tools for Unity Documentation",
    "keywords": "Class AlignmentControl Inheritance Object AlignmentControl Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class AlignmentControl : MonoBehaviour Methods Clear() Declaration public void Clear()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardCommand.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardCommand.html",
    "title": "Class DashboardCommand | World Locking Tools for Unity Documentation",
    "keywords": "Class DashboardCommand The DashboardCommand class provides a proxy layer between interactive elements (e.g. buttons) and the actions that need to be performed (e.g. WorldLockingManager perform a merge). Inheritance Object DashboardCommand Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class DashboardCommand : MonoBehaviour Properties AnchorVisualization Toggle anchor visualization. Declaration public bool AnchorVisualization { get; set; } Property Value Type Description Boolean AutoMerge Toggle automatic merging whenever indicated by underlying system. Declaration public bool AutoMerge { get; set; } Property Value Type Description Boolean AutoRefreeze Toggle automatic refreezing whenever indicated by underlying system. Declaration public bool AutoRefreeze { get; set; } Property Value Type Description Boolean AutoSave Toggle automatic saving of state for later restore. Declaration public bool AutoSave { get; set; } Property Value Type Description Boolean HasSpatialMap Return whether there is an available frozen spatial mapping setup and attached. Declaration public bool HasSpatialMap { get; } Property Value Type Description Boolean InfoEnabled Toggle info display. Declaration public bool InfoEnabled { get; set; } Property Value Type Description Boolean ManagerEnabled Whether the WorldLockingManager is actively stabilizing space or being bypassed. Declaration public bool ManagerEnabled { get; set; } Property Value Type Description Boolean MetricsEnabled Toggle Metrics display Declaration public bool MetricsEnabled { get; set; } Property Value Type Description Boolean SpatialMapDisplayEnabled Toggle whether the spatial mapping mesh is displayed. Declaration public bool SpatialMapDisplayEnabled { get; set; } Property Value Type Description Boolean StateEnabled Toggle state display Declaration public bool StateEnabled { get; set; } Property Value Type Description Boolean StatusEnabled Toggle status display Declaration public bool StatusEnabled { get; set; } Property Value Type Description Boolean Methods Load() Load the last frozen world state, overwriting current state. Declaration public void Load() Merge() Perform a merge. Declaration public void Merge() Refreeze() Perform a refreeze Declaration public void Refreeze() Reset() Reset the frozen world state to a starting condition. Declaration public void Reset() Save() Save current frozen world state. Declaration public void Save() ToggleGui() Declaration public void ToggleGui() ToggleManager() Declaration public void ToggleManager()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardUI.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.DashboardUI.html",
    "title": "Class DashboardUI | World Locking Tools for Unity Documentation",
    "keywords": "Class DashboardUI Simple class to manage synchronizing state up to UI elements. Inheritance Object DashboardUI Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class DashboardUI : MonoBehaviour Fields ButtonLoad Manual perform load of last saved anchor state, overwriting current state. Declaration public Interactable ButtonLoad Field Value Type Description Interactable ButtonMerge Button to perform a merge, only enabled when a refreeze is available. Declaration public Interactable ButtonMerge Field Value Type Description Interactable ButtonRefreeze Button to perform a refreeze, only enabled when a refreeze is available. Declaration public Interactable ButtonRefreeze Field Value Type Description Interactable ButtonSave Manual perform save of current anchor state. Declaration public Interactable ButtonSave Field Value Type Description Interactable CheckBoxAutoMerge Toggle automatic merge operation when indicated by engine. Declaration public Interactable CheckBoxAutoMerge Field Value Type Description Interactable CheckBoxAutoRefreeze Toggle automatic refreeze operations when indicated by engine. Declaration public Interactable CheckBoxAutoRefreeze Field Value Type Description Interactable CheckBoxAutoSave Toggle periodic automatic saves of anchor state. Declaration public Interactable CheckBoxAutoSave Field Value Type Description Interactable CheckBoxManagerEnabled Toggle Frozen World Manager. Declaration public Interactable CheckBoxManagerEnabled Field Value Type Description Interactable CheckBoxShowAnchors Toggle diagnostic display of anchors. Declaration public Interactable CheckBoxShowAnchors Field Value Type Description Interactable CheckBoxShowInfo Toggle display of basic information. Declaration public Interactable CheckBoxShowInfo Field Value Type Description Interactable CheckBoxShowMetrics Toggle display of detailed metrics. Declaration public Interactable CheckBoxShowMetrics Field Value Type Description Interactable CheckBoxShowSpatMap Toggle display of spatial map. Declaration public Interactable CheckBoxShowSpatMap Field Value Type Description Interactable dashboardCommand Dashboard command dispatcher. Declaration public DashboardCommand dashboardCommand Field Value Type Description DashboardCommand"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.FallOut.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.FallOut.html",
    "title": "Class FallOut | World Locking Tools for Unity Documentation",
    "keywords": "Class FallOut Inheritance Object FallOut Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class FallOut : MonoBehaviour Fields KillHeight The height below the camera at which a falling object disappears. Object's position is based on local space origin, not bounds. Declaration public float KillHeight Field Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Examples | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Examples Classes AlignmentControl DashboardCommand The DashboardCommand class provides a proxy layer between interactive elements (e.g. buttons) and the actions that need to be performed (e.g. WorldLockingManager perform a merge). DashboardUI Simple class to manage synchronizing state up to UI elements. FallOut PhysicsBeamSample Example component using Frozen World to facilitate physics simulation. PinManipulator Helper class to add MRTK object manipulation controls to an object. RayPins SpacePinManipulation Make the SpacePin manually manipulable, using MRTK controls. SpacePinOrientableManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable . Delegates ManipulationEndedDelegate Callback for when the user has finished positioning and/or orienting the target."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationEndedDelegate.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.ManipulationEndedDelegate.html",
    "title": "Delegate ManipulationEndedDelegate | World Locking Tools for Unity Documentation",
    "keywords": "Delegate ManipulationEndedDelegate Callback for when the user has finished positioning and/or orienting the target. Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public delegate void ManipulationEndedDelegate();"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PhysicsBeamSample.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PhysicsBeamSample.html",
    "title": "Class PhysicsBeamSample | World Locking Tools for Unity Documentation",
    "keywords": "Class PhysicsBeamSample Example component using Frozen World to facilitate physics simulation. Inheritance Object PhysicsBeamSample Implements IMixedRealityPointerHandler Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class PhysicsBeamSample : InputSystemGlobalHandlerListener, IMixedRealityPointerHandler Remarks This MRTK based component uses MRTK for inputs to abstract out device. In all modes, the ray cast intersection as reported by MRTK is further filtered to specifically exclude UI elements. Along with collidable objects in the scene, a collidable spatial map is also included as ray cast target. The \"hit point\" is the intersection of the currently active pointer ray with those collidables, along with information about that object and the intersection (e.g. surface normal at hit point). If there is no current hit point, after excluding UI elements, no operation is performed. The component itself has 5 modes of operation: Idle - ignore inputs, do nothing Throw darts - compute and display an ballistic arc to toss a physics rigid body at the current hit point. Place pillar - Place an upright pillar at hit point. If the hit object is not a beam or pillar (e.g. is the spatial map), then a static pillar is added, else a physically simulated pillar. Place beam - A two part operation. The first select of a hit point establishes the first end point of a beam, and the second hit point the other beam's end point. A physically simulated beam stretched to have those two endpoints is generated and added to the scene. Remove object - Clicking on an object added to the scene in one of the above modes will remove it from the scene. Mode selection is done via the MRTK radio buttons (see Microsoft.MixedReality.Toolkit.UI.InteractableToggleCollection) included in the scene as an addition to the dashboard. Properties AttachRoot The subroot to attach created objects to. Declaration public Transform AttachRoot { get; } Property Value Type Description Transform LineMaterial Material to use when rendering line for beam placement. Declaration public Material LineMaterial { get; } Property Value Type Description Material PrefabBeam The prefab of the beam to place in the world at gaze position on air taps. Declaration public GameObject PrefabBeam { get; } Property Value Type Description GameObject PrefabDart The prefab of the dart to place in the world at gaze position on air taps. Declaration public GameObject PrefabDart { get; } Property Value Type Description GameObject PrefabHybridLockedSphere The prefab of the hybrid-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabHybridLockedSphere { get; } Property Value Type Description GameObject PrefabPillarDynamic The prefab of dynamic pillars to place in the world at gaze position on air taps. Declaration public GameObject PrefabPillarDynamic { get; } Property Value Type Description GameObject PrefabPillarFixed The prefab of fixed pillars to place in the world at gaze position on air taps. Declaration public GameObject PrefabPillarFixed { get; } Property Value Type Description GameObject PrefabUnlockedSphere The prefab of the non-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabUnlockedSphere { get; } Property Value Type Description GameObject PrefabWorldLockedSphere The prefab of the world-locked 'sphere' to place in the world at gaze position on air taps in Pin Sphere Mode. Declaration public GameObject PrefabWorldLockedSphere { get; } Property Value Type Description GameObject Methods EnterBeamMode() Switch into cross-beam placement mode. Declaration public void EnterBeamMode() EnterDartMode() Switch into dart tossing mode. Declaration public void EnterDartMode() EnterIdleMode() Switch into idle mode. Declaration public void EnterIdleMode() EnterPillarMode() Switch into pillar placement mode. Declaration public void EnterPillarMode() EnterPinSphereMode() Declaration public void EnterPinSphereMode() EnterRemoveMode() Switch into object removal mode. Declaration public void EnterRemoveMode() EnterWorldLockHybridLocked() Declaration public void EnterWorldLockHybridLocked() EnterWorldLockUnlocked() Declaration public void EnterWorldLockUnlocked() EnterWorldLockWorldLocked() Declaration public void EnterWorldLockWorldLocked() OnPointerClicked(MixedRealityPointerEventData) Process pointer clicked event if ray cast has result. Declaration public void OnPointerClicked(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDown(MixedRealityPointerEventData) No-op on pointer down. Declaration public void OnPointerDown(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDragged(MixedRealityPointerEventData) No-op on pointer drag. Declaration public void OnPointerDragged(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerUp(MixedRealityPointerEventData) No-op on pointer up. Declaration public void OnPointerUp(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData RegisterHandlers() Declaration protected override void RegisterHandlers() Start() Override InputSystemGlobalListener Start() method for additional one-time setup. Declaration protected override void Start() UnregisterHandlers() Declaration protected override void UnregisterHandlers() Implements IMixedRealityPointerHandler"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PinManipulator.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.PinManipulator.html",
    "title": "Class PinManipulator | World Locking Tools for Unity Documentation",
    "keywords": "Class PinManipulator Helper class to add MRTK object manipulation controls to an object. Inheritance Object PinManipulator Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class PinManipulator Constructors PinManipulator(Transform, GameObject, ManipulationEndedDelegate) Constructor accepts readonly dependencies. Declaration public PinManipulator(Transform owner, GameObject prefab, ManipulationEndedDelegate del) Parameters Type Name Description Transform owner The object to manipulate. GameObject prefab The visualization prefab to instantiate. ManipulationEndedDelegate del The manipulation ended callback. Properties UserOriented Whether to enable user orientation of the object. If false, only positioning enabled. Declaration public bool UserOriented { get; set; } Property Value Type Description Boolean Remarks May be toggled from script during runtime. Methods Shutdown() Cleanup. Declaration public virtual void Shutdown() Startup() Get set up. Declaration public void Startup() Update() If active, position and orient the visualization. Declaration public virtual void Update()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.RayPins.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.RayPins.html",
    "title": "Class RayPins | World Locking Tools for Unity Documentation",
    "keywords": "Class RayPins Inheritance Object RayPins Implements IMixedRealityPointerHandler Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class RayPins : InputSystemGlobalHandlerListener, IMixedRealityPointerHandler Fields spacePinPoints Global position of each of the space pins points can be matched to a ray cast against the environment. Declaration public List<Transform> spacePinPoints Field Value Type Description List < Transform > Properties ActivePin Accessor for currently active pin. Declaration public int ActivePin { get; set; } Property Value Type Description Int32 Methods ClearAll() Disable the effects of all pins, as if they had never been set. Declaration public void ClearAll() CreateSpacePins() Destroy any existing pins, and create new pins, one for each spacePinPoint. Declaration public bool CreateSpacePins() Returns Type Description Boolean True on success. Remarks If the spacePinPoint list is modified from script, CreateSpacePins should be called to resynchronize. OnPointerClicked(MixedRealityPointerEventData) Process pointer clicked event if ray cast has result. Declaration public void OnPointerClicked(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDown(MixedRealityPointerEventData) No-op on pointer down. Declaration public void OnPointerDown(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerDragged(MixedRealityPointerEventData) No-op on pointer drag. Declaration public void OnPointerDragged(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData OnPointerUp(MixedRealityPointerEventData) No-op on pointer up. Declaration public void OnPointerUp(MixedRealityPointerEventData eventData) Parameters Type Name Description MixedRealityPointerEventData eventData RegisterHandlers() Declaration protected override void RegisterHandlers() SetActivePin(Int32) Function for setting active pin from MRTK GUI callbacks. Declaration public void SetActivePin(int i) Parameters Type Name Description Int32 i The new current pin. Start() Create a shared orienter, and create space pins for any spacePinPoints set in the inspector. Declaration protected override void Start() UnregisterHandlers() Declaration protected override void UnregisterHandlers() Implements IMixedRealityPointerHandler"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinManipulation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinManipulation.html",
    "title": "Class SpacePinManipulation | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinManipulation Make the SpacePin manually manipulable, using MRTK controls. Inheritance Object SpacePinManipulation Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class SpacePinManipulation : SpacePin Properties Prefab_FeelerRay Proxy renderable to show axis alignment during manipulations. Declaration public GameObject Prefab_FeelerRay { get; set; } Property Value Type Description GameObject Methods OnDestroy() Shutdown the manipulation controls. Declaration protected override void OnDestroy() Start() Start(), and set up MRTK manipulation controls. Declaration protected override void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinOrientableManipulation.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Examples.SpacePinOrientableManipulation.html",
    "title": "Class SpacePinOrientableManipulation | World Locking Tools for Unity Documentation",
    "keywords": "Class SpacePinOrientableManipulation Component that adds MRTK object manipulation capabilities on top of the auto-orienting SpacePinOrientable . Inheritance Object SpacePinOrientableManipulation Namespace : Microsoft.MixedReality.WorldLocking.Examples Assembly : cs.temp.dll.dll Syntax public class SpacePinOrientableManipulation : SpacePinOrientable Properties Prefab_FeelerRay Proxy renderable to show axis alignment during manipulations. Declaration public GameObject Prefab_FeelerRay { get; set; } Property Value Type Description GameObject Methods OnDestroy() Shutdown the manipulation controls. Declaration protected override void OnDestroy() Start() Start(), and set up MRTK manipulation controls. Declaration protected override void Start()"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterBase.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterBase.html",
    "title": "Class AdjusterBase | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterBase Dummy class to identify components as implementing Frozen World's adjustment handler(s). Inheritance Object AdjusterBase AdjusterFixed Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterBase : MonoBehaviour Remarks Derivation from this class is not necessary to implement the necessary handling of state and transform messages from the system, as that handling is implemented by delegates, not inheritance. However, having a component derived from this base class attached to an object notifies the system that the object's handling of Frozen World system adjustments is covered, and prevents the system from automatically adding its own handlers to that object (if so configured)."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterFixed.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterFixed.html",
    "title": "Class AdjusterFixed | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterFixed Component to handle frozen world adjustments for fixed (stationary) objects. Inheritance Object AdjusterBase AdjusterFixed AdjusterMoving Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterFixed : AdjusterBase Remarks For dynamic objects, use AdjusterMoving Properties AttachmentPoint Declaration protected IAttachmentPoint AttachmentPoint { get; } Property Value Type Description IAttachmentPoint Manager Declaration protected IAttachmentPointManager Manager { get; } Property Value Type Description IAttachmentPointManager Methods HandleAdjustLocation(Pose) Declaration protected virtual void HandleAdjustLocation(Pose adjustment) Parameters Type Name Description Pose adjustment HandleAdjustState(AttachmentPointStateType) Declaration protected virtual void HandleAdjustState(AttachmentPointStateType state) Parameters Type Name Description AttachmentPointStateType state"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterMoving.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AdjusterMoving.html",
    "title": "Class AdjusterMoving | World Locking Tools for Unity Documentation",
    "keywords": "Class AdjusterMoving Component to handle frozen world adjustments for dynamic (moving) objects. Inheritance Object AdjusterBase AdjusterFixed AdjusterMoving Inherited Members AdjusterFixed.Manager AdjusterFixed.AttachmentPoint AdjusterFixed.HandleAdjustLocation(Pose) AdjusterFixed.HandleAdjustState(AttachmentPointStateType) Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AdjusterMoving : AdjusterFixed Remarks For stationary objects, use AdjusterFixed"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AnchorGraphVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.AnchorGraphVisual.html",
    "title": "Class AnchorGraphVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class AnchorGraphVisual Optional visualizer of anchors and edges Inheritance Object AnchorGraphVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class AnchorGraphVisual : MonoBehaviour Fields Prefab_FrameViz Prefab for the frame (axes) visualization. Declaration public FrameVisual Prefab_FrameViz Field Value Type Description FrameVisual Prefab_FrozenAnchorViz Prefab for frozen anchors. Declaration public FrozenAnchorVisual Prefab_FrozenAnchorViz Field Value Type Description FrozenAnchorVisual Prefab_SpongyAnchorViz Prefab for spongy anchors. Declaration public SpongyAnchorVisual Prefab_SpongyAnchorViz Field Value Type Description SpongyAnchorVisual"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ConnectingLine.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ConnectingLine.html",
    "title": "Class ConnectingLine | World Locking Tools for Unity Documentation",
    "keywords": "Class ConnectingLine Helper class for visualizing a graph of connected transforms. Inheritance Object ConnectingLine Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class ConnectingLine : MonoBehaviour Methods Create(Transform, Transform, Transform, Single, Color) Create line segment connecting two transforms and attached to a third Declaration public static ConnectingLine Create(Transform parent, Transform transformA, Transform transformB, float width, Color color) Parameters Type Name Description Transform parent Parent to hang the line segment off of Transform transformA Beginning endpoint of line segment Transform transformB Enging endpoint of line segment Single width Width of the Unity LineRenderer Color color Color of the line segment Returns Type Description ConnectingLine"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrameVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrameVisual.html",
    "title": "Class FrameVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class FrameVisual Component for adjusting color and description text of visual origin markers in a frame (coordinate system axes). Inheritance Object FrameVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrameVisual : MonoBehaviour Properties color Text and axes color Declaration public Color color { get; set; } Property Value Type Description Color"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenAnchorVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenAnchorVisual.html",
    "title": "Class FrozenAnchorVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenAnchorVisual Component for controlling color and ID text of anchor visualizations. Inheritance Object FrozenAnchorVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenAnchorVisual : MonoBehaviour Remarks The text will be set to the AnchorID. The color will be kept in sync with the parent frame. Methods Instantiate(String, FrameVisual) Create an instance of a frame visualizer Declaration public FrozenAnchorVisual Instantiate(string name, FrameVisual parent) Parameters Type Name Description String name The name of the anchor to be displayed FrameVisual parent The frame visualization object that defines the color of this anchor Returns Type Description FrozenAnchorVisual"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.html",
    "title": "Class FrozenSpatialMapping | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenSpatialMapping Class to reinterpret spatial mapping data from \"spongy\" space into \"frozen\" space. This is unnecessary when using MRTK's spatial mapping, which provides this and other enhancements over the native spatial mapping. Inheritance Object FrozenSpatialMapping Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenSpatialMapping : MonoBehaviour Properties Active Whether the Mapping is active. If inactive, all resources disposed and only remade when active again. Declaration public bool Active { get; set; } Property Value Type Description Boolean CenterObject Object around which spatial mappings are centered. Set to null to center around the camera. Declaration public Transform CenterObject { get; } Property Value Type Description Transform Collide Whether to perform collisions and raycasts against these surfaces. Declaration public bool Collide { get; } Property Value Type Description Boolean Display Whether to render the active surfaces with the given material. Declaration public bool Display { get; set; } Property Value Type Description Boolean DrawMaterial Material to draw surfaces with. May be null if no display wanted. Declaration public Material DrawMaterial { get; } Property Value Type Description Material HangerObject Object to attach surface objects to. May be null to add surface objects to scene root. Declaration public Transform HangerObject { get; } Property Value Type Description Transform Quality Quality at which to tessellate. Declaration public FrozenSpatialMapping.QualityType Quality { get; } Property Value Type Description FrozenSpatialMapping.QualityType Radius Radius around the camera to map. Declaration public float Radius { get; } Property Value Type Description Single UpdatePeriod Period in seconds at which to update surfaces. Declaration public float UpdatePeriod { get; } Property Value Type Description Single"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.QualityType.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenSpatialMapping.QualityType.html",
    "title": "Enum FrozenSpatialMapping.QualityType | World Locking Tools for Unity Documentation",
    "keywords": "Enum FrozenSpatialMapping.QualityType Supported tessellation quality levels. Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public enum QualityType Fields Name Description High Low Medium"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenTapToAdd.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.FrozenTapToAdd.html",
    "title": "Class FrozenTapToAdd | World Locking Tools for Unity Documentation",
    "keywords": "Class FrozenTapToAdd Simple class to adapt Unity's input results from spongy space into frozen space. This is unnecessary when using MRTK's input system, which already provides this and other enhancements and abstactions. Inheritance Object FrozenTapToAdd Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class FrozenTapToAdd : MonoBehaviour Properties Active Enable and disable processing of tap events. Declaration public bool Active { get; set; } Property Value Type Description Boolean PrefabToPlace The prefab to place in the world at gaze position on air taps. Declaration public GameObject PrefabToPlace { get; } Property Value Type Description GameObject"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.html",
    "title": "Namespace Microsoft.MixedReality.WorldLocking.Tools | World Locking Tools for Unity Documentation",
    "keywords": "Namespace Microsoft.MixedReality.WorldLocking.Tools Classes AdjusterBase Dummy class to identify components as implementing Frozen World's adjustment handler(s). AdjusterFixed Component to handle frozen world adjustments for fixed (stationary) objects. AdjusterMoving Component to handle frozen world adjustments for dynamic (moving) objects. AnchorGraphVisual Optional visualizer of anchors and edges ConnectingLine Helper class for visualizing a graph of connected transforms. FrameVisual Component for adjusting color and description text of visual origin markers in a frame (coordinate system axes). FrozenAnchorVisual Component for controlling color and ID text of anchor visualizations. FrozenSpatialMapping Class to reinterpret spatial mapping data from \"spongy\" space into \"frozen\" space. This is unnecessary when using MRTK's spatial mapping, which provides this and other enhancements over the native spatial mapping. FrozenTapToAdd Simple class to adapt Unity's input results from spongy space into frozen space. This is unnecessary when using MRTK's input system, which already provides this and other enhancements and abstactions. SimpleSprite Very simple class to rotate sprites to face the camera. SpongyAnchorVisual Component for controlling location, visual appearance and ID text of a spongy anchor visualization. StatusToText Helper to bind WorldLockingManager diagnostics to text meshes for display. ToggleWorldAnchor WorldAnchorAdapter Adapter for aligning an object with a WorldAnchor. Enums FrozenSpatialMapping.QualityType Supported tessellation quality levels."
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleSprite.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SimpleSprite.html",
    "title": "Class SimpleSprite | World Locking Tools for Unity Documentation",
    "keywords": "Class SimpleSprite Very simple class to rotate sprites to face the camera. Inheritance Object SimpleSprite Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SimpleSprite : MonoBehaviour Properties Swivel Swivel means rotate about Y-axis, set to false to face directly at target. Declaration public bool Swivel { get; set; } Property Value Type Description Boolean Target Object to face towards. Defaults to camera at time Start is called. Declaration public Transform Target { get; set; } Property Value Type Description Transform"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpongyAnchorVisual.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.SpongyAnchorVisual.html",
    "title": "Class SpongyAnchorVisual | World Locking Tools for Unity Documentation",
    "keywords": "Class SpongyAnchorVisual Component for controlling location, visual appearance and ID text of a spongy anchor visualization. Inheritance Object SpongyAnchorVisual Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class SpongyAnchorVisual : MonoBehaviour Remarks Each spongy anchor is paired with a WorldAnchor component connected to a different GameObject. The WorldAnchor component has its globalPose controlled by Unity, which may not appear correct when the camera position is adjusted by FrozenWorld. Therefore this component allows connecting a separate visualization GameObject located in the camera's frame of reference while the WorldAnchor remains invisible in the top-level Unity frame of reference, keeping the localPose of both objects in sync. Spongy anchors are visualized by a concentric pair of an outer ring and an inner disc The outer ring of fixed size indicates the state of the WorldAnchor by its color: green: support(area of inner circle indicating relevance) red: support with zero relevance yellow: not a support gray: WorldAnchor not located(i.e.currently not part of spongy world) The inner disc indicates the relevance of the spongy anchor (0..100%) by its area. Methods Instantiate(FrameVisual, WorldAnchor) Create a visualizer for a spongy anchor. Declaration public SpongyAnchorVisual Instantiate(FrameVisual parent, WorldAnchor worldAnchor) Parameters Type Name Description FrameVisual parent Coordinate space to create the visualizer in WorldAnchor worldAnchor The worldanchor component assigned to some other object that this object is supposed to sync with Returns Type Description SpongyAnchorVisual SetNoSupport() Declare as not being a support. Declaration public void SetNoSupport() SetSupportRelevance(Single) Set the relevance, which sets the color. Declaration public void SetSupportRelevance(float relevance) Parameters Type Name Description Single relevance The new relevance"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.StatusToText.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.StatusToText.html",
    "title": "Class StatusToText | World Locking Tools for Unity Documentation",
    "keywords": "Class StatusToText Helper to bind WorldLockingManager diagnostics to text meshes for display. Inheritance Object StatusToText Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class StatusToText : MonoBehaviour Properties ErrorStatusEnabled Text mesh for display of error status. Declaration public bool ErrorStatusEnabled { get; set; } Property Value Type Description Boolean InfoEnabled Text mesh for display of summary info. Declaration public bool InfoEnabled { get; set; } Property Value Type Description Boolean MetricsEnabled Whether display of detailed metrics currently enabled. Declaration public bool MetricsEnabled { get; set; } Property Value Type Description Boolean StateIndicatorEnabled Text mesh for display of current state. Declaration public bool StateIndicatorEnabled { get; set; } Property Value Type Description Boolean VersionTimestampEnabled Text mesh to display version and timestamp. Declaration public bool VersionTimestampEnabled { get; set; } Property Value Type Description Boolean"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ToggleWorldAnchor.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.ToggleWorldAnchor.html",
    "title": "Class ToggleWorldAnchor | World Locking Tools for Unity Documentation",
    "keywords": "Class ToggleWorldAnchor Inheritance Object ToggleWorldAnchor Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class ToggleWorldAnchor : MonoBehaviour Properties AlwaysLock Always use WorldAnchor to world lock, whether Frozen World is active or not. Declaration public bool AlwaysLock { get; set; } Property Value Type Description Boolean AttachmentPoint Declaration protected IAttachmentPoint AttachmentPoint { get; } Property Value Type Description IAttachmentPoint"
  },
  "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldAnchorAdapter.html": {
    "href": "DocGen/Temp/api/Microsoft.MixedReality.WorldLocking.Tools.WorldAnchorAdapter.html",
    "title": "Class WorldAnchorAdapter | World Locking Tools for Unity Documentation",
    "keywords": "Class WorldAnchorAdapter Adapter for aligning an object with a WorldAnchor. Inheritance Object WorldAnchorAdapter Namespace : Microsoft.MixedReality.WorldLocking.Tools Assembly : cs.temp.dll.dll Syntax public class WorldAnchorAdapter : MonoBehaviour Properties TargetObject The GameObject to be aligned to the WorldAnchor. Declaration public Transform TargetObject { get; set; } Property Value Type Description Transform WorldAnchorObject The GameObject holding the WorldAnchor component. Declaration public GameObject WorldAnchorObject { get; set; } Property Value Type Description GameObject"
  },
  "README.html": {
    "href": "README.html",
    "title": "Welcome! | World Locking Tools for Unity Documentation",
    "keywords": "Welcome! World Locking Tools for Unity provides a stable and reliable world-locked coordinate system, binding the virtual/holographic world to the physical world. World Locking Tools take the burden of world-locking holograms off of the developer, as well as enabling scenarios that were previously unreachable. It currently supports the HoloLens family of devices . World Locking Tools locks the entire holograph space of your application to the physical world. A hologram put in position relative to physical world features will stay fixed relative to those features, as well as remaining fixed relative to other holograms. World Locking Tools scale naturally with both the size and complexity of the scene. Large models, large collections of models, and multi-room environments are all handled gracefully. Published documentation For the most up-to-date documentation, see the World Locking Tools for Unity documentation portal . Getting started Dive into the full documentation, beginning with the organization of the documentation itself, from the Guides section . Or a quick overview of key concepts behind World Locking Tools is contained in this FAQ . Or skip straight into introduction of key concepts, leading to further details of concepts and solutions, beginning in the Concepts section . Easy and efficient World Locking Tools is both powerful and easy to use. Furthermore, it strives to supply only as much as a specific application requires. Any World Locking Tools feature not required by an application will incur no cost in resources or performance. See also These ideas are further explored in the conceptual guide. To complement the theoretical description, pragmatic samples are provided, along with how-to articles to walk through the steps involved in building applications using the World Locking Tools' stable and reliable coordinate system. Conceptual guide How-to articles Samples Further, reference materials for interfacing through script with World Locking Tools is included in the API Documentation . Build Status Branch CI Status Docs Status master Open source and related resources This project has adopted the Microsoft Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. Useful resources on Microsoft Windows Dev Center Academy Design Development Community See code examples. Do a coding tutorial. Watch guest lectures. Get design guides. Build user interface. Learn interactions and input. Get development guides. Learn the technology. Understand the science. Join open source projects. Ask questions on forums. Attend events and meetups. How to Contribute This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit https://cla.microsoft.com . When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA. This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments. View the How To Contribute page for the most up to date instructions on contributing to World Locking Tools for Unity."
  }
}